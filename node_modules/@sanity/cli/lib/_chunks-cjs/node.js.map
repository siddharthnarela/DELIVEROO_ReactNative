{"version":3,"file":"node.js","sources":["../../../../../node_modules/.pnpm/eventsource@2.0.2/node_modules/eventsource/lib/eventsource.js","../../../../../node_modules/.pnpm/@sanity+eventsource@5.0.1/node_modules/@sanity/eventsource/node.js"],"sourcesContent":["var parse = require('url').parse\nvar events = require('events')\nvar https = require('https')\nvar http = require('http')\nvar util = require('util')\n\nvar httpsOptions = [\n  'pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers',\n  'rejectUnauthorized', 'secureProtocol', 'servername', 'checkServerIdentity'\n]\n\nvar bom = [239, 187, 191]\nvar colon = 58\nvar space = 32\nvar lineFeed = 10\nvar carriageReturn = 13\n// Beyond 256KB we could not observe any gain in performance\nvar maxBufferAheadAllocation = 1024 * 256\n// Headers matching the pattern should be removed when redirecting to different origin\nvar reUnsafeHeader = /^(cookie|authorization)$/i\n\nfunction hasBom (buf) {\n  return bom.every(function (charCode, index) {\n    return buf[index] === charCode\n  })\n}\n\n/**\n * Creates a new EventSource object\n *\n * @param {String} url the URL to which to connect\n * @param {Object} [eventSourceInitDict] extra init params. See README for details.\n * @api public\n **/\nfunction EventSource (url, eventSourceInitDict) {\n  var readyState = EventSource.CONNECTING\n  var headers = eventSourceInitDict && eventSourceInitDict.headers\n  var hasNewOrigin = false\n  Object.defineProperty(this, 'readyState', {\n    get: function () {\n      return readyState\n    }\n  })\n\n  Object.defineProperty(this, 'url', {\n    get: function () {\n      return url\n    }\n  })\n\n  var self = this\n  self.reconnectInterval = 1000\n  self.connectionInProgress = false\n\n  function onConnectionClosed (message) {\n    if (readyState === EventSource.CLOSED) return\n    readyState = EventSource.CONNECTING\n    _emit('error', new Event('error', {message: message}))\n\n    // The url may have been changed by a temporary redirect. If that's the case,\n    // revert it now, and flag that we are no longer pointing to a new origin\n    if (reconnectUrl) {\n      url = reconnectUrl\n      reconnectUrl = null\n      hasNewOrigin = false\n    }\n    setTimeout(function () {\n      if (readyState !== EventSource.CONNECTING || self.connectionInProgress) {\n        return\n      }\n      self.connectionInProgress = true\n      connect()\n    }, self.reconnectInterval)\n  }\n\n  var req\n  var lastEventId = ''\n  if (headers && headers['Last-Event-ID']) {\n    lastEventId = headers['Last-Event-ID']\n    delete headers['Last-Event-ID']\n  }\n\n  var discardTrailingNewline = false\n  var data = ''\n  var eventName = ''\n\n  var reconnectUrl = null\n\n  function connect () {\n    var options = parse(url)\n    var isSecure = options.protocol === 'https:'\n    options.headers = { 'Cache-Control': 'no-cache', 'Accept': 'text/event-stream' }\n    if (lastEventId) options.headers['Last-Event-ID'] = lastEventId\n    if (headers) {\n      var reqHeaders = hasNewOrigin ? removeUnsafeHeaders(headers) : headers\n      for (var i in reqHeaders) {\n        var header = reqHeaders[i]\n        if (header) {\n          options.headers[i] = header\n        }\n      }\n    }\n\n    // Legacy: this should be specified as `eventSourceInitDict.https.rejectUnauthorized`,\n    // but for now exists as a backwards-compatibility layer\n    options.rejectUnauthorized = !(eventSourceInitDict && !eventSourceInitDict.rejectUnauthorized)\n\n    if (eventSourceInitDict && eventSourceInitDict.createConnection !== undefined) {\n      options.createConnection = eventSourceInitDict.createConnection\n    }\n\n    // If specify http proxy, make the request to sent to the proxy server,\n    // and include the original url in path and Host headers\n    var useProxy = eventSourceInitDict && eventSourceInitDict.proxy\n    if (useProxy) {\n      var proxy = parse(eventSourceInitDict.proxy)\n      isSecure = proxy.protocol === 'https:'\n\n      options.protocol = isSecure ? 'https:' : 'http:'\n      options.path = url\n      options.headers.Host = options.host\n      options.hostname = proxy.hostname\n      options.host = proxy.host\n      options.port = proxy.port\n    }\n\n    // If https options are specified, merge them into the request options\n    if (eventSourceInitDict && eventSourceInitDict.https) {\n      for (var optName in eventSourceInitDict.https) {\n        if (httpsOptions.indexOf(optName) === -1) {\n          continue\n        }\n\n        var option = eventSourceInitDict.https[optName]\n        if (option !== undefined) {\n          options[optName] = option\n        }\n      }\n    }\n\n    // Pass this on to the XHR\n    if (eventSourceInitDict && eventSourceInitDict.withCredentials !== undefined) {\n      options.withCredentials = eventSourceInitDict.withCredentials\n    }\n\n    req = (isSecure ? https : http).request(options, function (res) {\n      self.connectionInProgress = false\n      // Handle HTTP errors\n      if (res.statusCode === 500 || res.statusCode === 502 || res.statusCode === 503 || res.statusCode === 504) {\n        _emit('error', new Event('error', {status: res.statusCode, message: res.statusMessage}))\n        onConnectionClosed()\n        return\n      }\n\n      // Handle HTTP redirects\n      if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n        var location = res.headers.location\n        if (!location) {\n          // Server sent redirect response without Location header.\n          _emit('error', new Event('error', {status: res.statusCode, message: res.statusMessage}))\n          return\n        }\n        var prevOrigin = new URL(url).origin\n        var nextOrigin = new URL(location).origin\n        hasNewOrigin = prevOrigin !== nextOrigin\n        if (res.statusCode === 307) reconnectUrl = url\n        url = location\n        process.nextTick(connect)\n        return\n      }\n\n      if (res.statusCode !== 200) {\n        _emit('error', new Event('error', {status: res.statusCode, message: res.statusMessage}))\n        return self.close()\n      }\n\n      readyState = EventSource.OPEN\n      res.on('close', function () {\n        res.removeAllListeners('close')\n        res.removeAllListeners('end')\n        onConnectionClosed()\n      })\n\n      res.on('end', function () {\n        res.removeAllListeners('close')\n        res.removeAllListeners('end')\n        onConnectionClosed()\n      })\n      _emit('open', new Event('open'))\n\n      // text/event-stream parser adapted from webkit's\n      // Source/WebCore/page/EventSource.cpp\n      var buf\n      var newBuffer\n      var startingPos = 0\n      var startingFieldLength = -1\n      var newBufferSize = 0\n      var bytesUsed = 0\n\n      res.on('data', function (chunk) {\n        if (!buf) {\n          buf = chunk\n          if (hasBom(buf)) {\n            buf = buf.slice(bom.length)\n          }\n          bytesUsed = buf.length\n        } else {\n          if (chunk.length > buf.length - bytesUsed) {\n            newBufferSize = (buf.length * 2) + chunk.length\n            if (newBufferSize > maxBufferAheadAllocation) {\n              newBufferSize = buf.length + chunk.length + maxBufferAheadAllocation\n            }\n            newBuffer = Buffer.alloc(newBufferSize)\n            buf.copy(newBuffer, 0, 0, bytesUsed)\n            buf = newBuffer\n          }\n          chunk.copy(buf, bytesUsed)\n          bytesUsed += chunk.length\n        }\n\n        var pos = 0\n        var length = bytesUsed\n\n        while (pos < length) {\n          if (discardTrailingNewline) {\n            if (buf[pos] === lineFeed) {\n              ++pos\n            }\n            discardTrailingNewline = false\n          }\n\n          var lineLength = -1\n          var fieldLength = startingFieldLength\n          var c\n\n          for (var i = startingPos; lineLength < 0 && i < length; ++i) {\n            c = buf[i]\n            if (c === colon) {\n              if (fieldLength < 0) {\n                fieldLength = i - pos\n              }\n            } else if (c === carriageReturn) {\n              discardTrailingNewline = true\n              lineLength = i - pos\n            } else if (c === lineFeed) {\n              lineLength = i - pos\n            }\n          }\n\n          if (lineLength < 0) {\n            startingPos = length - pos\n            startingFieldLength = fieldLength\n            break\n          } else {\n            startingPos = 0\n            startingFieldLength = -1\n          }\n\n          parseEventStreamLine(buf, pos, fieldLength, lineLength)\n\n          pos += lineLength + 1\n        }\n\n        if (pos === length) {\n          buf = void 0\n          bytesUsed = 0\n        } else if (pos > 0) {\n          buf = buf.slice(pos, bytesUsed)\n          bytesUsed = buf.length\n        }\n      })\n    })\n\n    req.on('error', function (err) {\n      self.connectionInProgress = false\n      onConnectionClosed(err.message)\n    })\n\n    if (req.setNoDelay) req.setNoDelay(true)\n    req.end()\n  }\n\n  connect()\n\n  function _emit () {\n    if (self.listeners(arguments[0]).length > 0) {\n      self.emit.apply(self, arguments)\n    }\n  }\n\n  this._close = function () {\n    if (readyState === EventSource.CLOSED) return\n    readyState = EventSource.CLOSED\n    if (req.abort) req.abort()\n    if (req.xhr && req.xhr.abort) req.xhr.abort()\n  }\n\n  function parseEventStreamLine (buf, pos, fieldLength, lineLength) {\n    if (lineLength === 0) {\n      if (data.length > 0) {\n        var type = eventName || 'message'\n        _emit(type, new MessageEvent(type, {\n          data: data.slice(0, -1), // remove trailing newline\n          lastEventId: lastEventId,\n          origin: new URL(url).origin\n        }))\n        data = ''\n      }\n      eventName = void 0\n    } else if (fieldLength > 0) {\n      var noValue = fieldLength < 0\n      var step = 0\n      var field = buf.slice(pos, pos + (noValue ? lineLength : fieldLength)).toString()\n\n      if (noValue) {\n        step = lineLength\n      } else if (buf[pos + fieldLength + 1] !== space) {\n        step = fieldLength + 1\n      } else {\n        step = fieldLength + 2\n      }\n      pos += step\n\n      var valueLength = lineLength - step\n      var value = buf.slice(pos, pos + valueLength).toString()\n\n      if (field === 'data') {\n        data += value + '\\n'\n      } else if (field === 'event') {\n        eventName = value\n      } else if (field === 'id') {\n        lastEventId = value\n      } else if (field === 'retry') {\n        var retry = parseInt(value, 10)\n        if (!Number.isNaN(retry)) {\n          self.reconnectInterval = retry\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = EventSource\n\nutil.inherits(EventSource, events.EventEmitter)\nEventSource.prototype.constructor = EventSource; // make stacktraces readable\n\n['open', 'error', 'message'].forEach(function (method) {\n  Object.defineProperty(EventSource.prototype, 'on' + method, {\n    /**\n     * Returns the current listener\n     *\n     * @return {Mixed} the set function or undefined\n     * @api private\n     */\n    get: function get () {\n      var listener = this.listeners(method)[0]\n      return listener ? (listener._listener ? listener._listener : listener) : undefined\n    },\n\n    /**\n     * Start listening for events\n     *\n     * @param {Function} listener the listener\n     * @return {Mixed} the set function or undefined\n     * @api private\n     */\n    set: function set (listener) {\n      this.removeAllListeners(method)\n      this.addEventListener(method, listener)\n    }\n  })\n})\n\n/**\n * Ready states\n */\nObject.defineProperty(EventSource, 'CONNECTING', {enumerable: true, value: 0})\nObject.defineProperty(EventSource, 'OPEN', {enumerable: true, value: 1})\nObject.defineProperty(EventSource, 'CLOSED', {enumerable: true, value: 2})\n\nEventSource.prototype.CONNECTING = 0\nEventSource.prototype.OPEN = 1\nEventSource.prototype.CLOSED = 2\n\n/**\n * Closes the connection, if one is made, and sets the readyState attribute to 2 (closed)\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventSource/close\n * @api public\n */\nEventSource.prototype.close = function () {\n  this._close()\n}\n\n/**\n * Emulates the W3C Browser based WebSocket interface using addEventListener.\n *\n * @param {String} type A string representing the event type to listen out for\n * @param {Function} listener callback\n * @see https://developer.mozilla.org/en/DOM/element.addEventListener\n * @see http://dev.w3.org/html5/websockets/#the-websocket-interface\n * @api public\n */\nEventSource.prototype.addEventListener = function addEventListener (type, listener) {\n  if (typeof listener === 'function') {\n    // store a reference so we can return the original function again\n    listener._listener = listener\n    this.on(type, listener)\n  }\n}\n\n/**\n * Emulates the W3C Browser based WebSocket interface using dispatchEvent.\n *\n * @param {Event} event An event to be dispatched\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent\n * @api public\n */\nEventSource.prototype.dispatchEvent = function dispatchEvent (event) {\n  if (!event.type) {\n    throw new Error('UNSPECIFIED_EVENT_TYPE_ERR')\n  }\n  // if event is instance of an CustomEvent (or has 'details' property),\n  // send the detail object as the payload for the event\n  this.emit(event.type, event.detail)\n}\n\n/**\n * Emulates the W3C Browser based WebSocket interface using removeEventListener.\n *\n * @param {String} type A string representing the event type to remove\n * @param {Function} listener callback\n * @see https://developer.mozilla.org/en/DOM/element.removeEventListener\n * @see http://dev.w3.org/html5/websockets/#the-websocket-interface\n * @api public\n */\nEventSource.prototype.removeEventListener = function removeEventListener (type, listener) {\n  if (typeof listener === 'function') {\n    listener._listener = undefined\n    this.removeListener(type, listener)\n  }\n}\n\n/**\n * W3C Event\n *\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#interface-Event\n * @api private\n */\nfunction Event (type, optionalProperties) {\n  Object.defineProperty(this, 'type', { writable: false, value: type, enumerable: true })\n  if (optionalProperties) {\n    for (var f in optionalProperties) {\n      if (optionalProperties.hasOwnProperty(f)) {\n        Object.defineProperty(this, f, { writable: false, value: optionalProperties[f], enumerable: true })\n      }\n    }\n  }\n}\n\n/**\n * W3C MessageEvent\n *\n * @see http://www.w3.org/TR/webmessaging/#event-definitions\n * @api private\n */\nfunction MessageEvent (type, eventInitDict) {\n  Object.defineProperty(this, 'type', { writable: false, value: type, enumerable: true })\n  for (var f in eventInitDict) {\n    if (eventInitDict.hasOwnProperty(f)) {\n      Object.defineProperty(this, f, { writable: false, value: eventInitDict[f], enumerable: true })\n    }\n  }\n}\n\n/**\n * Returns a new object of headers that does not include any authorization and cookie headers\n *\n * @param {Object} headers An object of headers ({[headerName]: headerValue})\n * @return {Object} a new object of headers\n * @api private\n */\nfunction removeUnsafeHeaders (headers) {\n  var safe = {}\n  for (var key in headers) {\n    if (reUnsafeHeader.test(key)) {\n      continue\n    }\n\n    safe[key] = headers[key]\n  }\n\n  return safe\n}\n","module.exports = require('eventsource')\n"],"names":["require$$0","require$$1","require$$2","require$$3","require$$4","i"],"mappings":"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","x_google_ignoreList":[0,1]}