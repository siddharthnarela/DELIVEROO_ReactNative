"use strict";
var loadEnv = require("./loadEnv.js"), require$$0$1 = require("url"), require$$3 = require("events"), require$$2 = require("https"), require$$6 = require("http"), require$$0 = require("util");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var require$$0__default$1 = /* @__PURE__ */ _interopDefaultCompat(require$$0$1), require$$3__default = /* @__PURE__ */ _interopDefaultCompat(require$$3), require$$2__default = /* @__PURE__ */ _interopDefaultCompat(require$$2), require$$6__default = /* @__PURE__ */ _interopDefaultCompat(require$$6), require$$0__default = /* @__PURE__ */ _interopDefaultCompat(require$$0), parse = require$$0__default$1.default.parse, events = require$$3__default.default, https = require$$2__default.default, http = require$$6__default.default, util = require$$0__default.default, httpsOptions = [
  "pfx",
  "key",
  "passphrase",
  "cert",
  "ca",
  "ciphers",
  "rejectUnauthorized",
  "secureProtocol",
  "servername",
  "checkServerIdentity"
], bom = [239, 187, 191], colon = 58, space = 32, lineFeed = 10, carriageReturn = 13, maxBufferAheadAllocation = 1024 * 256, reUnsafeHeader = /^(cookie|authorization)$/i;
function hasBom(buf) {
  return bom.every(function(charCode, index) {
    return buf[index] === charCode;
  });
}
function EventSource(url, eventSourceInitDict) {
  var readyState = EventSource.CONNECTING, headers = eventSourceInitDict && eventSourceInitDict.headers, hasNewOrigin = !1;
  Object.defineProperty(this, "readyState", {
    get: function() {
      return readyState;
    }
  }), Object.defineProperty(this, "url", {
    get: function() {
      return url;
    }
  });
  var self = this;
  self.reconnectInterval = 1e3, self.connectionInProgress = !1;
  function onConnectionClosed(message) {
    readyState !== EventSource.CLOSED && (readyState = EventSource.CONNECTING, _emit("error", new Event("error", { message })), reconnectUrl && (url = reconnectUrl, reconnectUrl = null, hasNewOrigin = !1), setTimeout(function() {
      readyState !== EventSource.CONNECTING || self.connectionInProgress || (self.connectionInProgress = !0, connect());
    }, self.reconnectInterval));
  }
  var req, lastEventId = "";
  headers && headers["Last-Event-ID"] && (lastEventId = headers["Last-Event-ID"], delete headers["Last-Event-ID"]);
  var discardTrailingNewline = !1, data = "", eventName = "", reconnectUrl = null;
  function connect() {
    var options = parse(url), isSecure = options.protocol === "https:";
    if (options.headers = { "Cache-Control": "no-cache", Accept: "text/event-stream" }, lastEventId && (options.headers["Last-Event-ID"] = lastEventId), headers) {
      var reqHeaders = hasNewOrigin ? removeUnsafeHeaders(headers) : headers;
      for (var i in reqHeaders) {
        var header = reqHeaders[i];
        header && (options.headers[i] = header);
      }
    }
    options.rejectUnauthorized = !(eventSourceInitDict && !eventSourceInitDict.rejectUnauthorized), eventSourceInitDict && eventSourceInitDict.createConnection !== void 0 && (options.createConnection = eventSourceInitDict.createConnection);
    var useProxy = eventSourceInitDict && eventSourceInitDict.proxy;
    if (useProxy) {
      var proxy = parse(eventSourceInitDict.proxy);
      isSecure = proxy.protocol === "https:", options.protocol = isSecure ? "https:" : "http:", options.path = url, options.headers.Host = options.host, options.hostname = proxy.hostname, options.host = proxy.host, options.port = proxy.port;
    }
    if (eventSourceInitDict && eventSourceInitDict.https) {
      for (var optName in eventSourceInitDict.https)
        if (httpsOptions.indexOf(optName) !== -1) {
          var option = eventSourceInitDict.https[optName];
          option !== void 0 && (options[optName] = option);
        }
    }
    eventSourceInitDict && eventSourceInitDict.withCredentials !== void 0 && (options.withCredentials = eventSourceInitDict.withCredentials), req = (isSecure ? https : http).request(options, function(res) {
      if (self.connectionInProgress = !1, res.statusCode === 500 || res.statusCode === 502 || res.statusCode === 503 || res.statusCode === 504) {
        _emit("error", new Event("error", { status: res.statusCode, message: res.statusMessage })), onConnectionClosed();
        return;
      }
      if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {
        var location = res.headers.location;
        if (!location) {
          _emit("error", new Event("error", { status: res.statusCode, message: res.statusMessage }));
          return;
        }
        var prevOrigin = new URL(url).origin, nextOrigin = new URL(location).origin;
        hasNewOrigin = prevOrigin !== nextOrigin, res.statusCode === 307 && (reconnectUrl = url), url = location, process.nextTick(connect);
        return;
      }
      if (res.statusCode !== 200)
        return _emit("error", new Event("error", { status: res.statusCode, message: res.statusMessage })), self.close();
      readyState = EventSource.OPEN, res.on("close", function() {
        res.removeAllListeners("close"), res.removeAllListeners("end"), onConnectionClosed();
      }), res.on("end", function() {
        res.removeAllListeners("close"), res.removeAllListeners("end"), onConnectionClosed();
      }), _emit("open", new Event("open"));
      var buf, newBuffer, startingPos = 0, startingFieldLength = -1, newBufferSize = 0, bytesUsed = 0;
      res.on("data", function(chunk) {
        buf ? (chunk.length > buf.length - bytesUsed && (newBufferSize = buf.length * 2 + chunk.length, newBufferSize > maxBufferAheadAllocation && (newBufferSize = buf.length + chunk.length + maxBufferAheadAllocation), newBuffer = Buffer.alloc(newBufferSize), buf.copy(newBuffer, 0, 0, bytesUsed), buf = newBuffer), chunk.copy(buf, bytesUsed), bytesUsed += chunk.length) : (buf = chunk, hasBom(buf) && (buf = buf.slice(bom.length)), bytesUsed = buf.length);
        for (var pos = 0, length = bytesUsed; pos < length; ) {
          discardTrailingNewline && (buf[pos] === lineFeed && ++pos, discardTrailingNewline = !1);
          for (var lineLength = -1, fieldLength = startingFieldLength, c, i2 = startingPos; lineLength < 0 && i2 < length; ++i2)
            c = buf[i2], c === colon ? fieldLength < 0 && (fieldLength = i2 - pos) : c === carriageReturn ? (discardTrailingNewline = !0, lineLength = i2 - pos) : c === lineFeed && (lineLength = i2 - pos);
          if (lineLength < 0) {
            startingPos = length - pos, startingFieldLength = fieldLength;
            break;
          } else
            startingPos = 0, startingFieldLength = -1;
          parseEventStreamLine(buf, pos, fieldLength, lineLength), pos += lineLength + 1;
        }
        pos === length ? (buf = void 0, bytesUsed = 0) : pos > 0 && (buf = buf.slice(pos, bytesUsed), bytesUsed = buf.length);
      });
    }), req.on("error", function(err) {
      self.connectionInProgress = !1, onConnectionClosed(err.message);
    }), req.setNoDelay && req.setNoDelay(!0), req.end();
  }
  connect();
  function _emit() {
    self.listeners(arguments[0]).length > 0 && self.emit.apply(self, arguments);
  }
  this._close = function() {
    readyState !== EventSource.CLOSED && (readyState = EventSource.CLOSED, req.abort && req.abort(), req.xhr && req.xhr.abort && req.xhr.abort());
  };
  function parseEventStreamLine(buf, pos, fieldLength, lineLength) {
    if (lineLength === 0) {
      if (data.length > 0) {
        var type = eventName || "message";
        _emit(type, new MessageEvent(type, {
          data: data.slice(0, -1),
          // remove trailing newline
          lastEventId,
          origin: new URL(url).origin
        })), data = "";
      }
      eventName = void 0;
    } else if (fieldLength > 0) {
      var noValue = fieldLength < 0, step = 0, field = buf.slice(pos, pos + (noValue ? lineLength : fieldLength)).toString();
      noValue ? step = lineLength : buf[pos + fieldLength + 1] !== space ? step = fieldLength + 1 : step = fieldLength + 2, pos += step;
      var valueLength = lineLength - step, value = buf.slice(pos, pos + valueLength).toString();
      if (field === "data")
        data += value + `
`;
      else if (field === "event")
        eventName = value;
      else if (field === "id")
        lastEventId = value;
      else if (field === "retry") {
        var retry = parseInt(value, 10);
        Number.isNaN(retry) || (self.reconnectInterval = retry);
      }
    }
  }
}
var eventsource = EventSource;
util.inherits(EventSource, events.EventEmitter);
EventSource.prototype.constructor = EventSource;
["open", "error", "message"].forEach(function(method) {
  Object.defineProperty(EventSource.prototype, "on" + method, {
    /**
     * Returns the current listener
     *
     * @return {Mixed} the set function or undefined
     * @api private
     */
    get: function() {
      var listener = this.listeners(method)[0];
      return listener ? listener._listener ? listener._listener : listener : void 0;
    },
    /**
     * Start listening for events
     *
     * @param {Function} listener the listener
     * @return {Mixed} the set function or undefined
     * @api private
     */
    set: function(listener) {
      this.removeAllListeners(method), this.addEventListener(method, listener);
    }
  });
});
Object.defineProperty(EventSource, "CONNECTING", { enumerable: !0, value: 0 });
Object.defineProperty(EventSource, "OPEN", { enumerable: !0, value: 1 });
Object.defineProperty(EventSource, "CLOSED", { enumerable: !0, value: 2 });
EventSource.prototype.CONNECTING = 0;
EventSource.prototype.OPEN = 1;
EventSource.prototype.CLOSED = 2;
EventSource.prototype.close = function() {
  this._close();
};
EventSource.prototype.addEventListener = function(type, listener) {
  typeof listener == "function" && (listener._listener = listener, this.on(type, listener));
};
EventSource.prototype.dispatchEvent = function(event) {
  if (!event.type)
    throw new Error("UNSPECIFIED_EVENT_TYPE_ERR");
  this.emit(event.type, event.detail);
};
EventSource.prototype.removeEventListener = function(type, listener) {
  typeof listener == "function" && (listener._listener = void 0, this.removeListener(type, listener));
};
function Event(type, optionalProperties) {
  if (Object.defineProperty(this, "type", { writable: !1, value: type, enumerable: !0 }), optionalProperties)
    for (var f in optionalProperties)
      optionalProperties.hasOwnProperty(f) && Object.defineProperty(this, f, { writable: !1, value: optionalProperties[f], enumerable: !0 });
}
function MessageEvent(type, eventInitDict) {
  Object.defineProperty(this, "type", { writable: !1, value: type, enumerable: !0 });
  for (var f in eventInitDict)
    eventInitDict.hasOwnProperty(f) && Object.defineProperty(this, f, { writable: !1, value: eventInitDict[f], enumerable: !0 });
}
function removeUnsafeHeaders(headers) {
  var safe = {};
  for (var key in headers)
    reUnsafeHeader.test(key) || (safe[key] = headers[key]);
  return safe;
}
var node = eventsource, node$1 = /* @__PURE__ */ loadEnv.getDefaultExportFromCjs(node), node$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  default: node$1
});
exports.node = node$2;
//# sourceMappingURL=node.js.map
