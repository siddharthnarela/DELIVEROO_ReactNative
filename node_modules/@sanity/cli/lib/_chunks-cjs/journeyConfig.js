"use strict";
var fs = require("fs/promises"), path = require("path"), require$$1 = require("module"), require$$0 = require("url"), process3 = require("process"), require$$0$2 = require("os"), tty = require("tty"), require$$1$1 = require("assert"), require$$0$3 = require("fs"), v8 = require("v8"), require$$0$1 = require("util"), worker_threads = require("worker_threads"), cliWorker = require("./cliWorker.js"), _documentCurrentScript = typeof document < "u" ? document.currentScript : null;
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
function _interopNamespaceCompat(e) {
  if (e && typeof e == "object" && "default" in e)
    return e;
  var n = /* @__PURE__ */ Object.create(null);
  return e && Object.keys(e).forEach(function(k) {
    if (k !== "default") {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: !0,
        get: function() {
          return e[k];
        }
      });
    }
  }), n.default = e, Object.freeze(n);
}
var fs__default = /* @__PURE__ */ _interopDefaultCompat(fs), path__namespace = /* @__PURE__ */ _interopNamespaceCompat(path), require$$0__default$1 = /* @__PURE__ */ _interopDefaultCompat(require$$0), process3__default = /* @__PURE__ */ _interopDefaultCompat(process3), require$$0__default = /* @__PURE__ */ _interopDefaultCompat(require$$0$2), tty__default = /* @__PURE__ */ _interopDefaultCompat(tty), require$$1__default = /* @__PURE__ */ _interopDefaultCompat(require$$1$1), require$$0__default$2 = /* @__PURE__ */ _interopDefaultCompat(require$$0$3), v8__default = /* @__PURE__ */ _interopDefaultCompat(v8), __defProp$1 = Object.defineProperty, __export$1 = (target, all) => {
  for (var name in all)
    __defProp$1(target, name, { get: all[name], enumerable: !0 });
}, public_exports$1 = {};
__export$1(public_exports$1, {
  builders: () => builders,
  printer: () => printer,
  utils: () => utils
});
var DOC_TYPE_STRING$1 = "string", DOC_TYPE_ARRAY$1 = "array", DOC_TYPE_CURSOR$1 = "cursor", DOC_TYPE_INDENT$1 = "indent", DOC_TYPE_ALIGN$1 = "align", DOC_TYPE_TRIM$1 = "trim", DOC_TYPE_GROUP$1 = "group", DOC_TYPE_FILL$1 = "fill", DOC_TYPE_IF_BREAK$1 = "if-break", DOC_TYPE_INDENT_IF_BREAK$1 = "indent-if-break", DOC_TYPE_LINE_SUFFIX$1 = "line-suffix", DOC_TYPE_LINE_SUFFIX_BOUNDARY$1 = "line-suffix-boundary", DOC_TYPE_LINE$1 = "line", DOC_TYPE_LABEL$1 = "label", DOC_TYPE_BREAK_PARENT$1 = "break-parent", VALID_OBJECT_DOC_TYPES$1 = /* @__PURE__ */ new Set([
  DOC_TYPE_CURSOR$1,
  DOC_TYPE_INDENT$1,
  DOC_TYPE_ALIGN$1,
  DOC_TYPE_TRIM$1,
  DOC_TYPE_GROUP$1,
  DOC_TYPE_FILL$1,
  DOC_TYPE_IF_BREAK$1,
  DOC_TYPE_INDENT_IF_BREAK$1,
  DOC_TYPE_LINE_SUFFIX$1,
  DOC_TYPE_LINE_SUFFIX_BOUNDARY$1,
  DOC_TYPE_LINE$1,
  DOC_TYPE_LABEL$1,
  DOC_TYPE_BREAK_PARENT$1
]);
function getDocType$1(doc2) {
  if (typeof doc2 == "string")
    return DOC_TYPE_STRING$1;
  if (Array.isArray(doc2))
    return DOC_TYPE_ARRAY$1;
  if (!doc2)
    return;
  const { type: type2 } = doc2;
  if (VALID_OBJECT_DOC_TYPES$1.has(type2))
    return type2;
}
var get_doc_type_default$1 = getDocType$1, disjunctionListFormat$1 = (list) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(list);
function getDocErrorMessage$1(doc2) {
  const type2 = doc2 === null ? "null" : typeof doc2;
  if (type2 !== "string" && type2 !== "object")
    return `Unexpected doc '${type2}', 
Expected it to be 'string' or 'object'.`;
  if (get_doc_type_default$1(doc2))
    throw new Error("doc is valid.");
  const objectType = Object.prototype.toString.call(doc2);
  if (objectType !== "[object Object]")
    return `Unexpected doc '${objectType}'.`;
  const EXPECTED_TYPE_VALUES = disjunctionListFormat$1(
    [...VALID_OBJECT_DOC_TYPES$1].map((type22) => `'${type22}'`)
  );
  return `Unexpected doc.type '${doc2.type}'.
Expected it to be ${EXPECTED_TYPE_VALUES}.`;
}
var InvalidDocError$1 = class extends Error {
  name = "InvalidDocError";
  constructor(doc2) {
    super(getDocErrorMessage$1(doc2)), this.doc = doc2;
  }
}, invalid_doc_error_default$1 = InvalidDocError$1, traverseDocOnExitStackMarker$1 = {};
function traverseDoc$1(doc2, onEnter, onExit, shouldTraverseConditionalGroups) {
  const docsStack = [doc2];
  for (; docsStack.length > 0; ) {
    const doc22 = docsStack.pop();
    if (doc22 === traverseDocOnExitStackMarker$1) {
      onExit(docsStack.pop());
      continue;
    }
    onExit && docsStack.push(doc22, traverseDocOnExitStackMarker$1);
    const docType = get_doc_type_default$1(doc22);
    if (!docType)
      throw new invalid_doc_error_default$1(doc22);
    if (onEnter?.(doc22) !== !1)
      switch (docType) {
        case DOC_TYPE_ARRAY$1:
        case DOC_TYPE_FILL$1: {
          const parts = docType === DOC_TYPE_ARRAY$1 ? doc22 : doc22.parts;
          for (let ic = parts.length, i2 = ic - 1; i2 >= 0; --i2)
            docsStack.push(parts[i2]);
          break;
        }
        case DOC_TYPE_IF_BREAK$1:
          docsStack.push(doc22.flatContents, doc22.breakContents);
          break;
        case DOC_TYPE_GROUP$1:
          if (shouldTraverseConditionalGroups && doc22.expandedStates)
            for (let ic = doc22.expandedStates.length, i2 = ic - 1; i2 >= 0; --i2)
              docsStack.push(doc22.expandedStates[i2]);
          else
            docsStack.push(doc22.contents);
          break;
        case DOC_TYPE_ALIGN$1:
        case DOC_TYPE_INDENT$1:
        case DOC_TYPE_INDENT_IF_BREAK$1:
        case DOC_TYPE_LABEL$1:
        case DOC_TYPE_LINE_SUFFIX$1:
          docsStack.push(doc22.contents);
          break;
        case DOC_TYPE_STRING$1:
        case DOC_TYPE_CURSOR$1:
        case DOC_TYPE_TRIM$1:
        case DOC_TYPE_LINE_SUFFIX_BOUNDARY$1:
        case DOC_TYPE_LINE$1:
        case DOC_TYPE_BREAK_PARENT$1:
          break;
        default:
          throw new invalid_doc_error_default$1(doc22);
      }
  }
}
var traverse_doc_default$1 = traverseDoc$1;
function indent$1(contents) {
  return { type: DOC_TYPE_INDENT$1, contents };
}
function align$1(widthOrString, contents) {
  return { type: DOC_TYPE_ALIGN$1, contents, n: widthOrString };
}
function group(contents, opts = {}) {
  return {
    type: DOC_TYPE_GROUP$1,
    id: opts.id,
    contents,
    break: !!opts.shouldBreak,
    expandedStates: opts.expandedStates
  };
}
function dedentToRoot(contents) {
  return align$1(Number.NEGATIVE_INFINITY, contents);
}
function markAsRoot(contents) {
  return align$1({ type: "root" }, contents);
}
function dedent(contents) {
  return align$1(-1, contents);
}
function conditionalGroup(states, opts) {
  return group(states[0], { ...opts, expandedStates: states });
}
function fill$1(parts) {
  return { type: DOC_TYPE_FILL$1, parts };
}
function ifBreak(breakContents, flatContents = "", opts = {}) {
  return {
    type: DOC_TYPE_IF_BREAK$1,
    breakContents,
    flatContents,
    groupId: opts.groupId
  };
}
function indentIfBreak(contents, opts) {
  return {
    type: DOC_TYPE_INDENT_IF_BREAK$1,
    contents,
    groupId: opts.groupId,
    negate: opts.negate
  };
}
function lineSuffix$1(contents) {
  return { type: DOC_TYPE_LINE_SUFFIX$1, contents };
}
var lineSuffixBoundary = { type: DOC_TYPE_LINE_SUFFIX_BOUNDARY$1 }, breakParent$1 = { type: DOC_TYPE_BREAK_PARENT$1 }, trim$1 = { type: DOC_TYPE_TRIM$1 }, hardlineWithoutBreakParent$1 = { type: DOC_TYPE_LINE$1, hard: !0 }, literallineWithoutBreakParent = {
  type: DOC_TYPE_LINE$1,
  hard: !0,
  literal: !0
}, line$1 = { type: DOC_TYPE_LINE$1 }, softline = { type: DOC_TYPE_LINE$1, soft: !0 }, hardline$1 = [hardlineWithoutBreakParent$1, breakParent$1], literalline = [literallineWithoutBreakParent, breakParent$1], cursor$1 = { type: DOC_TYPE_CURSOR$1 };
function join(separator, docs) {
  const parts = [];
  for (let i2 = 0; i2 < docs.length; i2++)
    i2 !== 0 && parts.push(separator), parts.push(docs[i2]);
  return parts;
}
function addAlignmentToDoc$1(doc2, size, tabWidth) {
  let aligned = doc2;
  if (size > 0) {
    for (let i2 = 0; i2 < Math.floor(size / tabWidth); ++i2)
      aligned = indent$1(aligned);
    aligned = align$1(size % tabWidth, aligned), aligned = align$1(Number.NEGATIVE_INFINITY, aligned);
  }
  return aligned;
}
function label(label2, contents) {
  return label2 ? { type: DOC_TYPE_LABEL$1, label: label2, contents } : contents;
}
var at$1 = (isOptionalObject, object, index) => {
  if (!(isOptionalObject && object == null))
    return Array.isArray(object) || typeof object == "string" ? object[index < 0 ? object.length + index : index] : object.at(index);
}, at_default$1 = at$1, stringReplaceAll$1 = (isOptionalObject, original, pattern, replacement) => {
  if (!(isOptionalObject && original == null))
    return original.replaceAll ? original.replaceAll(pattern, replacement) : pattern.global ? original.replace(pattern, replacement) : original.split(pattern).join(replacement);
}, string_replace_all_default$1 = stringReplaceAll$1;
function convertEndOfLineToChars$1(value) {
  switch (value) {
    case "cr":
      return "\r";
    case "crlf":
      return `\r
`;
    default:
      return `
`;
  }
}
var emoji_regex_default$1 = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
function isFullWidth$1(x) {
  return x === 12288 || x >= 65281 && x <= 65376 || x >= 65504 && x <= 65510;
}
function isWide$1(x) {
  return x >= 4352 && x <= 4447 || x === 8986 || x === 8987 || x === 9001 || x === 9002 || x >= 9193 && x <= 9196 || x === 9200 || x === 9203 || x === 9725 || x === 9726 || x === 9748 || x === 9749 || x >= 9800 && x <= 9811 || x === 9855 || x === 9875 || x === 9889 || x === 9898 || x === 9899 || x === 9917 || x === 9918 || x === 9924 || x === 9925 || x === 9934 || x === 9940 || x === 9962 || x === 9970 || x === 9971 || x === 9973 || x === 9978 || x === 9981 || x === 9989 || x === 9994 || x === 9995 || x === 10024 || x === 10060 || x === 10062 || x >= 10067 && x <= 10069 || x === 10071 || x >= 10133 && x <= 10135 || x === 10160 || x === 10175 || x === 11035 || x === 11036 || x === 11088 || x === 11093 || x >= 11904 && x <= 11929 || x >= 11931 && x <= 12019 || x >= 12032 && x <= 12245 || x >= 12272 && x <= 12287 || x >= 12289 && x <= 12350 || x >= 12353 && x <= 12438 || x >= 12441 && x <= 12543 || x >= 12549 && x <= 12591 || x >= 12593 && x <= 12686 || x >= 12688 && x <= 12771 || x >= 12783 && x <= 12830 || x >= 12832 && x <= 12871 || x >= 12880 && x <= 19903 || x >= 19968 && x <= 42124 || x >= 42128 && x <= 42182 || x >= 43360 && x <= 43388 || x >= 44032 && x <= 55203 || x >= 63744 && x <= 64255 || x >= 65040 && x <= 65049 || x >= 65072 && x <= 65106 || x >= 65108 && x <= 65126 || x >= 65128 && x <= 65131 || x >= 94176 && x <= 94180 || x === 94192 || x === 94193 || x >= 94208 && x <= 100343 || x >= 100352 && x <= 101589 || x >= 101632 && x <= 101640 || x >= 110576 && x <= 110579 || x >= 110581 && x <= 110587 || x === 110589 || x === 110590 || x >= 110592 && x <= 110882 || x === 110898 || x >= 110928 && x <= 110930 || x === 110933 || x >= 110948 && x <= 110951 || x >= 110960 && x <= 111355 || x === 126980 || x === 127183 || x === 127374 || x >= 127377 && x <= 127386 || x >= 127488 && x <= 127490 || x >= 127504 && x <= 127547 || x >= 127552 && x <= 127560 || x === 127568 || x === 127569 || x >= 127584 && x <= 127589 || x >= 127744 && x <= 127776 || x >= 127789 && x <= 127797 || x >= 127799 && x <= 127868 || x >= 127870 && x <= 127891 || x >= 127904 && x <= 127946 || x >= 127951 && x <= 127955 || x >= 127968 && x <= 127984 || x === 127988 || x >= 127992 && x <= 128062 || x === 128064 || x >= 128066 && x <= 128252 || x >= 128255 && x <= 128317 || x >= 128331 && x <= 128334 || x >= 128336 && x <= 128359 || x === 128378 || x === 128405 || x === 128406 || x === 128420 || x >= 128507 && x <= 128591 || x >= 128640 && x <= 128709 || x === 128716 || x >= 128720 && x <= 128722 || x >= 128725 && x <= 128727 || x >= 128732 && x <= 128735 || x === 128747 || x === 128748 || x >= 128756 && x <= 128764 || x >= 128992 && x <= 129003 || x === 129008 || x >= 129292 && x <= 129338 || x >= 129340 && x <= 129349 || x >= 129351 && x <= 129535 || x >= 129648 && x <= 129660 || x >= 129664 && x <= 129672 || x >= 129680 && x <= 129725 || x >= 129727 && x <= 129733 || x >= 129742 && x <= 129755 || x >= 129760 && x <= 129768 || x >= 129776 && x <= 129784 || x >= 131072 && x <= 196605 || x >= 196608 && x <= 262141;
}
var _isNarrowWidth$1 = (codePoint) => !(isFullWidth$1(codePoint) || isWide$1(codePoint)), notAsciiRegex$1 = /[^\x20-\x7F]/;
function getStringWidth$1(text) {
  if (!text)
    return 0;
  if (!notAsciiRegex$1.test(text))
    return text.length;
  text = text.replace(emoji_regex_default$1(), "  ");
  let width = 0;
  for (const character of text) {
    const codePoint = character.codePointAt(0);
    codePoint <= 31 || codePoint >= 127 && codePoint <= 159 || codePoint >= 768 && codePoint <= 879 || (width += _isNarrowWidth$1(codePoint) ? 1 : 2);
  }
  return width;
}
var get_string_width_default$1 = getStringWidth$1, getDocParts$1 = (doc2) => {
  if (Array.isArray(doc2))
    return doc2;
  if (doc2.type !== DOC_TYPE_FILL$1)
    throw new Error(`Expect doc to be 'array' or '${DOC_TYPE_FILL$1}'.`);
  return doc2.parts;
};
function mapDoc$1(doc2, cb) {
  if (typeof doc2 == "string")
    return cb(doc2);
  const mapped = /* @__PURE__ */ new Map();
  return rec(doc2);
  function rec(doc22) {
    if (mapped.has(doc22))
      return mapped.get(doc22);
    const result = process2(doc22);
    return mapped.set(doc22, result), result;
  }
  function process2(doc22) {
    switch (get_doc_type_default$1(doc22)) {
      case DOC_TYPE_ARRAY$1:
        return cb(doc22.map(rec));
      case DOC_TYPE_FILL$1:
        return cb({
          ...doc22,
          parts: doc22.parts.map(rec)
        });
      case DOC_TYPE_IF_BREAK$1:
        return cb({
          ...doc22,
          breakContents: rec(doc22.breakContents),
          flatContents: rec(doc22.flatContents)
        });
      case DOC_TYPE_GROUP$1: {
        let {
          expandedStates,
          contents
        } = doc22;
        return expandedStates ? (expandedStates = expandedStates.map(rec), contents = expandedStates[0]) : contents = rec(contents), cb({
          ...doc22,
          contents,
          expandedStates
        });
      }
      case DOC_TYPE_ALIGN$1:
      case DOC_TYPE_INDENT$1:
      case DOC_TYPE_INDENT_IF_BREAK$1:
      case DOC_TYPE_LABEL$1:
      case DOC_TYPE_LINE_SUFFIX$1:
        return cb({
          ...doc22,
          contents: rec(doc22.contents)
        });
      case DOC_TYPE_STRING$1:
      case DOC_TYPE_CURSOR$1:
      case DOC_TYPE_TRIM$1:
      case DOC_TYPE_LINE_SUFFIX_BOUNDARY$1:
      case DOC_TYPE_LINE$1:
      case DOC_TYPE_BREAK_PARENT$1:
        return cb(doc22);
      default:
        throw new invalid_doc_error_default$1(doc22);
    }
  }
}
function findInDoc(doc2, fn, defaultValue) {
  let result = defaultValue, shouldSkipFurtherProcessing = !1;
  function findInDocOnEnterFn(doc22) {
    if (shouldSkipFurtherProcessing)
      return !1;
    const maybeResult = fn(doc22);
    maybeResult !== void 0 && (shouldSkipFurtherProcessing = !0, result = maybeResult);
  }
  return traverse_doc_default$1(doc2, findInDocOnEnterFn), result;
}
function willBreakFn(doc2) {
  if (doc2.type === DOC_TYPE_GROUP$1 && doc2.break || doc2.type === DOC_TYPE_LINE$1 && doc2.hard || doc2.type === DOC_TYPE_BREAK_PARENT$1)
    return !0;
}
function willBreak(doc2) {
  return findInDoc(doc2, willBreakFn, !1);
}
function breakParentGroup$1(groupStack) {
  if (groupStack.length > 0) {
    const parentGroup = at_default$1(
      /* isOptionalObject*/
      !1,
      groupStack,
      -1
    );
    !parentGroup.expandedStates && !parentGroup.break && (parentGroup.break = "propagated");
  }
  return null;
}
function propagateBreaks$1(doc2) {
  const alreadyVisitedSet = /* @__PURE__ */ new Set(), groupStack = [];
  function propagateBreaksOnEnterFn(doc22) {
    if (doc22.type === DOC_TYPE_BREAK_PARENT$1 && breakParentGroup$1(groupStack), doc22.type === DOC_TYPE_GROUP$1) {
      if (groupStack.push(doc22), alreadyVisitedSet.has(doc22))
        return !1;
      alreadyVisitedSet.add(doc22);
    }
  }
  function propagateBreaksOnExitFn(doc22) {
    doc22.type === DOC_TYPE_GROUP$1 && groupStack.pop().break && breakParentGroup$1(groupStack);
  }
  traverse_doc_default$1(
    doc2,
    propagateBreaksOnEnterFn,
    propagateBreaksOnExitFn,
    /* shouldTraverseConditionalGroups */
    !0
  );
}
function removeLinesFn(doc2) {
  return doc2.type === DOC_TYPE_LINE$1 && !doc2.hard ? doc2.soft ? "" : " " : doc2.type === DOC_TYPE_IF_BREAK$1 ? doc2.flatContents : doc2;
}
function removeLines(doc2) {
  return mapDoc$1(doc2, removeLinesFn);
}
function stripTrailingHardlineFromParts$1(parts) {
  for (parts = [...parts]; parts.length >= 2 && at_default$1(
    /* isOptionalObject*/
    !1,
    parts,
    -2
  ).type === DOC_TYPE_LINE$1 && at_default$1(
    /* isOptionalObject*/
    !1,
    parts,
    -1
  ).type === DOC_TYPE_BREAK_PARENT$1; )
    parts.length -= 2;
  if (parts.length > 0) {
    const lastPart = stripTrailingHardlineFromDoc$1(at_default$1(
      /* isOptionalObject*/
      !1,
      parts,
      -1
    ));
    parts[parts.length - 1] = lastPart;
  }
  return parts;
}
function stripTrailingHardlineFromDoc$1(doc2) {
  switch (get_doc_type_default$1(doc2)) {
    case DOC_TYPE_ALIGN$1:
    case DOC_TYPE_INDENT$1:
    case DOC_TYPE_INDENT_IF_BREAK$1:
    case DOC_TYPE_GROUP$1:
    case DOC_TYPE_LINE_SUFFIX$1:
    case DOC_TYPE_LABEL$1: {
      const contents = stripTrailingHardlineFromDoc$1(doc2.contents);
      return {
        ...doc2,
        contents
      };
    }
    case DOC_TYPE_IF_BREAK$1:
      return {
        ...doc2,
        breakContents: stripTrailingHardlineFromDoc$1(doc2.breakContents),
        flatContents: stripTrailingHardlineFromDoc$1(doc2.flatContents)
      };
    case DOC_TYPE_FILL$1:
      return {
        ...doc2,
        parts: stripTrailingHardlineFromParts$1(doc2.parts)
      };
    case DOC_TYPE_ARRAY$1:
      return stripTrailingHardlineFromParts$1(doc2);
    case DOC_TYPE_STRING$1:
      return doc2.replace(/[\n\r]*$/, "");
    case DOC_TYPE_CURSOR$1:
    case DOC_TYPE_TRIM$1:
    case DOC_TYPE_LINE_SUFFIX_BOUNDARY$1:
    case DOC_TYPE_LINE$1:
    case DOC_TYPE_BREAK_PARENT$1:
      break;
    default:
      throw new invalid_doc_error_default$1(doc2);
  }
  return doc2;
}
function stripTrailingHardline$1(doc2) {
  return stripTrailingHardlineFromDoc$1(cleanDoc$1(doc2));
}
function cleanDocFn$1(doc2) {
  switch (get_doc_type_default$1(doc2)) {
    case DOC_TYPE_FILL$1:
      if (doc2.parts.every((part) => part === ""))
        return "";
      break;
    case DOC_TYPE_GROUP$1:
      if (!doc2.contents && !doc2.id && !doc2.break && !doc2.expandedStates)
        return "";
      if (doc2.contents.type === DOC_TYPE_GROUP$1 && doc2.contents.id === doc2.id && doc2.contents.break === doc2.break && doc2.contents.expandedStates === doc2.expandedStates)
        return doc2.contents;
      break;
    case DOC_TYPE_ALIGN$1:
    case DOC_TYPE_INDENT$1:
    case DOC_TYPE_INDENT_IF_BREAK$1:
    case DOC_TYPE_LINE_SUFFIX$1:
      if (!doc2.contents)
        return "";
      break;
    case DOC_TYPE_IF_BREAK$1:
      if (!doc2.flatContents && !doc2.breakContents)
        return "";
      break;
    case DOC_TYPE_ARRAY$1: {
      const parts = [];
      for (const part of doc2) {
        if (!part)
          continue;
        const [currentPart, ...restParts] = Array.isArray(part) ? part : [part];
        typeof currentPart == "string" && typeof at_default$1(
          /* isOptionalObject*/
          !1,
          parts,
          -1
        ) == "string" ? parts[parts.length - 1] += currentPart : parts.push(currentPart), parts.push(...restParts);
      }
      return parts.length === 0 ? "" : parts.length === 1 ? parts[0] : parts;
    }
    case DOC_TYPE_STRING$1:
    case DOC_TYPE_CURSOR$1:
    case DOC_TYPE_TRIM$1:
    case DOC_TYPE_LINE_SUFFIX_BOUNDARY$1:
    case DOC_TYPE_LINE$1:
    case DOC_TYPE_LABEL$1:
    case DOC_TYPE_BREAK_PARENT$1:
      break;
    default:
      throw new invalid_doc_error_default$1(doc2);
  }
  return doc2;
}
function cleanDoc$1(doc2) {
  return mapDoc$1(doc2, (currentDoc) => cleanDocFn$1(currentDoc));
}
function replaceEndOfLine(doc2, replacement = literalline) {
  return mapDoc$1(doc2, (currentDoc) => typeof currentDoc == "string" ? join(replacement, currentDoc.split(`
`)) : currentDoc);
}
function canBreakFn(doc2) {
  if (doc2.type === DOC_TYPE_LINE$1)
    return !0;
}
function canBreak(doc2) {
  return findInDoc(doc2, canBreakFn, !1);
}
var MODE_BREAK$1 = Symbol("MODE_BREAK"), MODE_FLAT$1 = Symbol("MODE_FLAT"), CURSOR_PLACEHOLDER$1 = Symbol("cursor");
function rootIndent$1() {
  return {
    value: "",
    length: 0,
    queue: []
  };
}
function makeIndent$1(ind, options8) {
  return generateInd$1(ind, {
    type: "indent"
  }, options8);
}
function makeAlign$1(indent2, widthOrDoc, options8) {
  return widthOrDoc === Number.NEGATIVE_INFINITY ? indent2.root || rootIndent$1() : widthOrDoc < 0 ? generateInd$1(indent2, {
    type: "dedent"
  }, options8) : widthOrDoc ? widthOrDoc.type === "root" ? {
    ...indent2,
    root: indent2
  } : generateInd$1(indent2, {
    type: typeof widthOrDoc == "string" ? "stringAlign" : "numberAlign",
    n: widthOrDoc
  }, options8) : indent2;
}
function generateInd$1(ind, newPart, options8) {
  const queue = newPart.type === "dedent" ? ind.queue.slice(0, -1) : [...ind.queue, newPart];
  let value = "", length = 0, lastTabs = 0, lastSpaces = 0;
  for (const part of queue)
    switch (part.type) {
      case "indent":
        flush(), options8.useTabs ? addTabs(1) : addSpaces(options8.tabWidth);
        break;
      case "stringAlign":
        flush(), value += part.n, length += part.n.length;
        break;
      case "numberAlign":
        lastTabs += 1, lastSpaces += part.n;
        break;
      default:
        throw new Error(`Unexpected type '${part.type}'`);
    }
  return flushSpaces(), {
    ...ind,
    value,
    length,
    queue
  };
  function addTabs(count) {
    value += "	".repeat(count), length += options8.tabWidth * count;
  }
  function addSpaces(count) {
    value += " ".repeat(count), length += count;
  }
  function flush() {
    options8.useTabs ? flushTabs() : flushSpaces();
  }
  function flushTabs() {
    lastTabs > 0 && addTabs(lastTabs), resetLast();
  }
  function flushSpaces() {
    lastSpaces > 0 && addSpaces(lastSpaces), resetLast();
  }
  function resetLast() {
    lastTabs = 0, lastSpaces = 0;
  }
}
function trim2(out) {
  let trimCount = 0, cursorCount = 0, outIndex = out.length;
  outer:
    for (; outIndex--; ) {
      const last = out[outIndex];
      if (last === CURSOR_PLACEHOLDER$1) {
        cursorCount++;
        continue;
      }
      for (let charIndex = last.length - 1; charIndex >= 0; charIndex--) {
        const char = last[charIndex];
        if (char === " " || char === "	")
          trimCount++;
        else {
          out[outIndex] = last.slice(0, charIndex + 1);
          break outer;
        }
      }
    }
  if (trimCount > 0 || cursorCount > 0)
    for (out.length = outIndex + 1; cursorCount-- > 0; )
      out.push(CURSOR_PLACEHOLDER$1);
  return trimCount;
}
function fits$1(next, restCommands, width, hasLineSuffix, groupModeMap, mustBeFlat) {
  if (width === Number.POSITIVE_INFINITY)
    return !0;
  let restIdx = restCommands.length;
  const cmds = [next], out = [];
  for (; width >= 0; ) {
    if (cmds.length === 0) {
      if (restIdx === 0)
        return !0;
      cmds.push(restCommands[--restIdx]);
      continue;
    }
    const {
      mode,
      doc: doc2
    } = cmds.pop();
    switch (get_doc_type_default$1(doc2)) {
      case DOC_TYPE_STRING$1:
        out.push(doc2), width -= get_string_width_default$1(doc2);
        break;
      case DOC_TYPE_ARRAY$1:
      case DOC_TYPE_FILL$1: {
        const parts = getDocParts$1(doc2);
        for (let i2 = parts.length - 1; i2 >= 0; i2--)
          cmds.push({
            mode,
            doc: parts[i2]
          });
        break;
      }
      case DOC_TYPE_INDENT$1:
      case DOC_TYPE_ALIGN$1:
      case DOC_TYPE_INDENT_IF_BREAK$1:
      case DOC_TYPE_LABEL$1:
        cmds.push({
          mode,
          doc: doc2.contents
        });
        break;
      case DOC_TYPE_TRIM$1:
        width += trim2(out);
        break;
      case DOC_TYPE_GROUP$1: {
        if (mustBeFlat && doc2.break)
          return !1;
        const groupMode = doc2.break ? MODE_BREAK$1 : mode, contents = doc2.expandedStates && groupMode === MODE_BREAK$1 ? at_default$1(
          /* isOptionalObject*/
          !1,
          doc2.expandedStates,
          -1
        ) : doc2.contents;
        cmds.push({
          mode: groupMode,
          doc: contents
        });
        break;
      }
      case DOC_TYPE_IF_BREAK$1: {
        const contents = (doc2.groupId ? groupModeMap[doc2.groupId] || MODE_FLAT$1 : mode) === MODE_BREAK$1 ? doc2.breakContents : doc2.flatContents;
        contents && cmds.push({
          mode,
          doc: contents
        });
        break;
      }
      case DOC_TYPE_LINE$1:
        if (mode === MODE_BREAK$1 || doc2.hard)
          return !0;
        doc2.soft || (out.push(" "), width--);
        break;
      case DOC_TYPE_LINE_SUFFIX$1:
        hasLineSuffix = !0;
        break;
      case DOC_TYPE_LINE_SUFFIX_BOUNDARY$1:
        if (hasLineSuffix)
          return !1;
        break;
    }
  }
  return !1;
}
function printDocToString$1(doc2, options8) {
  const groupModeMap = {}, width = options8.printWidth, newLine = convertEndOfLineToChars$1(options8.endOfLine);
  let pos2 = 0;
  const cmds = [{
    ind: rootIndent$1(),
    mode: MODE_BREAK$1,
    doc: doc2
  }], out = [];
  let shouldRemeasure = !1;
  const lineSuffix2 = [];
  let printedCursorCount = 0;
  for (propagateBreaks$1(doc2); cmds.length > 0; ) {
    const {
      ind,
      mode,
      doc: doc22
    } = cmds.pop();
    switch (get_doc_type_default$1(doc22)) {
      case DOC_TYPE_STRING$1: {
        const formatted = newLine !== `
` ? string_replace_all_default$1(
          /* isOptionalObject*/
          !1,
          doc22,
          `
`,
          newLine
        ) : doc22;
        out.push(formatted), cmds.length > 0 && (pos2 += get_string_width_default$1(formatted));
        break;
      }
      case DOC_TYPE_ARRAY$1:
        for (let i2 = doc22.length - 1; i2 >= 0; i2--)
          cmds.push({
            ind,
            mode,
            doc: doc22[i2]
          });
        break;
      case DOC_TYPE_CURSOR$1:
        if (printedCursorCount >= 2)
          throw new Error("There are too many 'cursor' in doc.");
        out.push(CURSOR_PLACEHOLDER$1), printedCursorCount++;
        break;
      case DOC_TYPE_INDENT$1:
        cmds.push({
          ind: makeIndent$1(ind, options8),
          mode,
          doc: doc22.contents
        });
        break;
      case DOC_TYPE_ALIGN$1:
        cmds.push({
          ind: makeAlign$1(ind, doc22.n, options8),
          mode,
          doc: doc22.contents
        });
        break;
      case DOC_TYPE_TRIM$1:
        pos2 -= trim2(out);
        break;
      case DOC_TYPE_GROUP$1:
        switch (mode) {
          case MODE_FLAT$1:
            if (!shouldRemeasure) {
              cmds.push({
                ind,
                mode: doc22.break ? MODE_BREAK$1 : MODE_FLAT$1,
                doc: doc22.contents
              });
              break;
            }
          case MODE_BREAK$1: {
            shouldRemeasure = !1;
            const next = {
              ind,
              mode: MODE_FLAT$1,
              doc: doc22.contents
            }, rem = width - pos2, hasLineSuffix = lineSuffix2.length > 0;
            if (!doc22.break && fits$1(next, cmds, rem, hasLineSuffix, groupModeMap))
              cmds.push(next);
            else if (doc22.expandedStates) {
              const mostExpanded = at_default$1(
                /* isOptionalObject*/
                !1,
                doc22.expandedStates,
                -1
              );
              if (doc22.break) {
                cmds.push({
                  ind,
                  mode: MODE_BREAK$1,
                  doc: mostExpanded
                });
                break;
              } else
                for (let i2 = 1; i2 < doc22.expandedStates.length + 1; i2++)
                  if (i2 >= doc22.expandedStates.length) {
                    cmds.push({
                      ind,
                      mode: MODE_BREAK$1,
                      doc: mostExpanded
                    });
                    break;
                  } else {
                    const state = doc22.expandedStates[i2], cmd = {
                      ind,
                      mode: MODE_FLAT$1,
                      doc: state
                    };
                    if (fits$1(cmd, cmds, rem, hasLineSuffix, groupModeMap)) {
                      cmds.push(cmd);
                      break;
                    }
                  }
            } else
              cmds.push({
                ind,
                mode: MODE_BREAK$1,
                doc: doc22.contents
              });
            break;
          }
        }
        doc22.id && (groupModeMap[doc22.id] = at_default$1(
          /* isOptionalObject*/
          !1,
          cmds,
          -1
        ).mode);
        break;
      case DOC_TYPE_FILL$1: {
        const rem = width - pos2, {
          parts
        } = doc22;
        if (parts.length === 0)
          break;
        const [content, whitespace] = parts, contentFlatCmd = {
          ind,
          mode: MODE_FLAT$1,
          doc: content
        }, contentBreakCmd = {
          ind,
          mode: MODE_BREAK$1,
          doc: content
        }, contentFits = fits$1(contentFlatCmd, [], rem, lineSuffix2.length > 0, groupModeMap, !0);
        if (parts.length === 1) {
          contentFits ? cmds.push(contentFlatCmd) : cmds.push(contentBreakCmd);
          break;
        }
        const whitespaceFlatCmd = {
          ind,
          mode: MODE_FLAT$1,
          doc: whitespace
        }, whitespaceBreakCmd = {
          ind,
          mode: MODE_BREAK$1,
          doc: whitespace
        };
        if (parts.length === 2) {
          contentFits ? cmds.push(whitespaceFlatCmd, contentFlatCmd) : cmds.push(whitespaceBreakCmd, contentBreakCmd);
          break;
        }
        parts.splice(0, 2);
        const remainingCmd = {
          ind,
          mode,
          doc: fill$1(parts)
        }, secondContent = parts[0];
        fits$1({
          ind,
          mode: MODE_FLAT$1,
          doc: [content, whitespace, secondContent]
        }, [], rem, lineSuffix2.length > 0, groupModeMap, !0) ? cmds.push(remainingCmd, whitespaceFlatCmd, contentFlatCmd) : contentFits ? cmds.push(remainingCmd, whitespaceBreakCmd, contentFlatCmd) : cmds.push(remainingCmd, whitespaceBreakCmd, contentBreakCmd);
        break;
      }
      case DOC_TYPE_IF_BREAK$1:
      case DOC_TYPE_INDENT_IF_BREAK$1: {
        const groupMode = doc22.groupId ? groupModeMap[doc22.groupId] : mode;
        if (groupMode === MODE_BREAK$1) {
          const breakContents = doc22.type === DOC_TYPE_IF_BREAK$1 ? doc22.breakContents : doc22.negate ? doc22.contents : indent$1(doc22.contents);
          breakContents && cmds.push({
            ind,
            mode,
            doc: breakContents
          });
        }
        if (groupMode === MODE_FLAT$1) {
          const flatContents = doc22.type === DOC_TYPE_IF_BREAK$1 ? doc22.flatContents : doc22.negate ? indent$1(doc22.contents) : doc22.contents;
          flatContents && cmds.push({
            ind,
            mode,
            doc: flatContents
          });
        }
        break;
      }
      case DOC_TYPE_LINE_SUFFIX$1:
        lineSuffix2.push({
          ind,
          mode,
          doc: doc22.contents
        });
        break;
      case DOC_TYPE_LINE_SUFFIX_BOUNDARY$1:
        lineSuffix2.length > 0 && cmds.push({
          ind,
          mode,
          doc: hardlineWithoutBreakParent$1
        });
        break;
      case DOC_TYPE_LINE$1:
        switch (mode) {
          case MODE_FLAT$1:
            if (doc22.hard)
              shouldRemeasure = !0;
            else {
              doc22.soft || (out.push(" "), pos2 += 1);
              break;
            }
          case MODE_BREAK$1:
            if (lineSuffix2.length > 0) {
              cmds.push({
                ind,
                mode,
                doc: doc22
              }, ...lineSuffix2.reverse()), lineSuffix2.length = 0;
              break;
            }
            doc22.literal ? ind.root ? (out.push(newLine, ind.root.value), pos2 = ind.root.length) : (out.push(newLine), pos2 = 0) : (pos2 -= trim2(out), out.push(newLine + ind.value), pos2 = ind.length);
            break;
        }
        break;
      case DOC_TYPE_LABEL$1:
        cmds.push({
          ind,
          mode,
          doc: doc22.contents
        });
        break;
      case DOC_TYPE_BREAK_PARENT$1:
        break;
      default:
        throw new invalid_doc_error_default$1(doc22);
    }
    cmds.length === 0 && lineSuffix2.length > 0 && (cmds.push(...lineSuffix2.reverse()), lineSuffix2.length = 0);
  }
  const cursorPlaceholderIndex = out.indexOf(CURSOR_PLACEHOLDER$1);
  if (cursorPlaceholderIndex !== -1) {
    const otherCursorPlaceholderIndex = out.indexOf(CURSOR_PLACEHOLDER$1, cursorPlaceholderIndex + 1), beforeCursor = out.slice(0, cursorPlaceholderIndex).join(""), aroundCursor = out.slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex).join(""), afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join("");
    return {
      formatted: beforeCursor + aroundCursor + afterCursor,
      cursorNodeStart: beforeCursor.length,
      cursorNodeText: aroundCursor
    };
  }
  return {
    formatted: out.join("")
  };
}
var builders = {
  join,
  line: line$1,
  softline,
  hardline: hardline$1,
  literalline,
  group,
  conditionalGroup,
  fill: fill$1,
  lineSuffix: lineSuffix$1,
  lineSuffixBoundary,
  cursor: cursor$1,
  breakParent: breakParent$1,
  ifBreak,
  trim: trim$1,
  indent: indent$1,
  indentIfBreak,
  align: align$1,
  addAlignmentToDoc: addAlignmentToDoc$1,
  markAsRoot,
  dedentToRoot,
  dedent,
  hardlineWithoutBreakParent: hardlineWithoutBreakParent$1,
  literallineWithoutBreakParent,
  label,
  // TODO: Remove this in v4
  concat: (parts) => parts
}, printer = { printDocToString: printDocToString$1 }, utils = {
  willBreak,
  traverseDoc: traverse_doc_default$1,
  findInDoc,
  mapDoc: mapDoc$1,
  removeLines,
  stripTrailingHardline: stripTrailingHardline$1,
  replaceEndOfLine,
  canBreak
}, public_default = public_exports$1, doc = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  builders,
  default: public_default,
  printer,
  utils
});
const require$1 = require$$1.createRequire(typeof document > "u" ? require("url").pathToFileURL(__filename).href : _documentCurrentScript && _documentCurrentScript.src || new URL("_chunks-cjs/journeyConfig.js", document.baseURI).href), __filename$1 = require$$0.fileURLToPath(typeof document > "u" ? require("url").pathToFileURL(__filename).href : _documentCurrentScript && _documentCurrentScript.src || new URL("_chunks-cjs/journeyConfig.js", document.baseURI).href);
path.dirname(__filename$1);
var __create = Object.create, __defProp = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __getOwnPropNames = Object.getOwnPropertyNames, __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty, __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key2] = value, __require = /* @__PURE__ */ ((x) => typeof require$1 < "u" ? require$1 : typeof Proxy < "u" ? new Proxy(x, {
  get: (a, b) => (typeof require$1 < "u" ? require$1 : a)[b]
}) : x)(function(x) {
  if (typeof require$1 < "u")
    return require$1.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
}), __commonJS = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
}, __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key2 of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key2) && key2 !== except && __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  return to;
}, __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __publicField = (obj, key2, value) => (__defNormalProp(obj, typeof key2 != "symbol" ? key2 + "" : key2, value), value), __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
}, __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj)), __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
}, __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value), __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method), require_array = __commonJS({
  "node_modules/fast-glob/out/utils/array.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.splitWhen = exports2.flatten = void 0;
    function flatten(items) {
      return items.reduce((collection, item) => [].concat(collection, item), []);
    }
    exports2.flatten = flatten;
    function splitWhen(items, predicate) {
      const result = [[]];
      let groupIndex = 0;
      for (const item of items)
        predicate(item) ? (groupIndex++, result[groupIndex] = []) : result[groupIndex].push(item);
      return result;
    }
    exports2.splitWhen = splitWhen;
  }
}), require_errno = __commonJS({
  "node_modules/fast-glob/out/utils/errno.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.isEnoentCodeError = void 0;
    function isEnoentCodeError(error) {
      return error.code === "ENOENT";
    }
    exports2.isEnoentCodeError = isEnoentCodeError;
  }
}), require_fs = __commonJS({
  "node_modules/fast-glob/out/utils/fs.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name, this.isBlockDevice = stats.isBlockDevice.bind(stats), this.isCharacterDevice = stats.isCharacterDevice.bind(stats), this.isDirectory = stats.isDirectory.bind(stats), this.isFIFO = stats.isFIFO.bind(stats), this.isFile = stats.isFile.bind(stats), this.isSocket = stats.isSocket.bind(stats), this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  }
}), require_path = __commonJS({
  "node_modules/fast-glob/out/utils/path.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.convertPosixPathToPattern = exports2.convertWindowsPathToPattern = exports2.convertPathToPattern = exports2.escapePosixPath = exports2.escapeWindowsPath = exports2.escape = exports2.removeLeadingDotSegment = exports2.makeAbsolute = exports2.unixify = void 0;
    var os2 = __require("os"), path13 = __require("path"), IS_WINDOWS_PLATFORM = os2.platform() === "win32", LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2, POSIX_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\()|\\(?![!()*+?@[\]{|}]))/g, WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()[\]{}]|^!|[!+@](?=\())/g, DOS_DEVICE_PATH_RE = /^\\\\([.?])/, WINDOWS_BACKSLASHES_RE = /\\(?![!()+@[\]{}])/g;
    function unixify(filepath) {
      return filepath.replace(/\\/g, "/");
    }
    exports2.unixify = unixify;
    function makeAbsolute(cwd, filepath) {
      return path13.resolve(cwd, filepath);
    }
    exports2.makeAbsolute = makeAbsolute;
    function removeLeadingDotSegment(entry) {
      if (entry.charAt(0) === ".") {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === "/" || secondCharactery === "\\")
          return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
      }
      return entry;
    }
    exports2.removeLeadingDotSegment = removeLeadingDotSegment, exports2.escape = IS_WINDOWS_PLATFORM ? escapeWindowsPath : escapePosixPath;
    function escapeWindowsPath(pattern) {
      return pattern.replace(WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports2.escapeWindowsPath = escapeWindowsPath;
    function escapePosixPath(pattern) {
      return pattern.replace(POSIX_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports2.escapePosixPath = escapePosixPath, exports2.convertPathToPattern = IS_WINDOWS_PLATFORM ? convertWindowsPathToPattern : convertPosixPathToPattern;
    function convertWindowsPathToPattern(filepath) {
      return escapeWindowsPath(filepath).replace(DOS_DEVICE_PATH_RE, "//$1").replace(WINDOWS_BACKSLASHES_RE, "/");
    }
    exports2.convertWindowsPathToPattern = convertWindowsPathToPattern;
    function convertPosixPathToPattern(filepath) {
      return escapePosixPath(filepath);
    }
    exports2.convertPosixPathToPattern = convertPosixPathToPattern;
  }
}), require_is_extglob = __commonJS({
  "node_modules/is-extglob/index.js"(exports2, module2) {
    module2.exports = function(str2) {
      if (typeof str2 != "string" || str2 === "")
        return !1;
      for (var match; match = /(\\).|([@?!+*]\(.*\))/g.exec(str2); ) {
        if (match[2])
          return !0;
        str2 = str2.slice(match.index + match[0].length);
      }
      return !1;
    };
  }
}), require_is_glob = __commonJS({
  "node_modules/is-glob/index.js"(exports2, module2) {
    var isExtglob = require_is_extglob(), chars = { "{": "}", "(": ")", "[": "]" }, strictCheck = function(str2) {
      if (str2[0] === "!")
        return !0;
      for (var index = 0, pipeIndex = -2, closeSquareIndex = -2, closeCurlyIndex = -2, closeParenIndex = -2, backSlashIndex = -2; index < str2.length; ) {
        if (str2[index] === "*" || str2[index + 1] === "?" && /[\].+)]/.test(str2[index]) || closeSquareIndex !== -1 && str2[index] === "[" && str2[index + 1] !== "]" && (closeSquareIndex < index && (closeSquareIndex = str2.indexOf("]", index)), closeSquareIndex > index && (backSlashIndex === -1 || backSlashIndex > closeSquareIndex || (backSlashIndex = str2.indexOf("\\", index), backSlashIndex === -1 || backSlashIndex > closeSquareIndex))) || closeCurlyIndex !== -1 && str2[index] === "{" && str2[index + 1] !== "}" && (closeCurlyIndex = str2.indexOf("}", index), closeCurlyIndex > index && (backSlashIndex = str2.indexOf("\\", index), backSlashIndex === -1 || backSlashIndex > closeCurlyIndex)) || closeParenIndex !== -1 && str2[index] === "(" && str2[index + 1] === "?" && /[:!=]/.test(str2[index + 2]) && str2[index + 3] !== ")" && (closeParenIndex = str2.indexOf(")", index), closeParenIndex > index && (backSlashIndex = str2.indexOf("\\", index), backSlashIndex === -1 || backSlashIndex > closeParenIndex)) || pipeIndex !== -1 && str2[index] === "(" && str2[index + 1] !== "|" && (pipeIndex < index && (pipeIndex = str2.indexOf("|", index)), pipeIndex !== -1 && str2[pipeIndex + 1] !== ")" && (closeParenIndex = str2.indexOf(")", pipeIndex), closeParenIndex > pipeIndex && (backSlashIndex = str2.indexOf("\\", pipeIndex), backSlashIndex === -1 || backSlashIndex > closeParenIndex))))
          return !0;
        if (str2[index] === "\\") {
          var open = str2[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str2.indexOf(close, index);
            n !== -1 && (index = n + 1);
          }
          if (str2[index] === "!")
            return !0;
        } else
          index++;
      }
      return !1;
    }, relaxedCheck = function(str2) {
      if (str2[0] === "!")
        return !0;
      for (var index = 0; index < str2.length; ) {
        if (/[*?{}()[\]]/.test(str2[index]))
          return !0;
        if (str2[index] === "\\") {
          var open = str2[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str2.indexOf(close, index);
            n !== -1 && (index = n + 1);
          }
          if (str2[index] === "!")
            return !0;
        } else
          index++;
      }
      return !1;
    };
    module2.exports = function(str2, options8) {
      if (typeof str2 != "string" || str2 === "")
        return !1;
      if (isExtglob(str2))
        return !0;
      var check2 = strictCheck;
      return options8 && options8.strict === !1 && (check2 = relaxedCheck), check2(str2);
    };
  }
}), require_glob_parent = __commonJS({
  "node_modules/glob-parent/index.js"(exports2, module2) {
    var isGlob = require_is_glob(), pathPosixDirname = __require("path").posix.dirname, isWin32 = __require("os").platform() === "win32", slash2 = "/", backslash = /\\/g, enclosure = /[\{\[].*[\}\]]$/, globby = /(^|[^\\])([\{\[]|\([^\)]+$)/, escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    module2.exports = function(str2, opts) {
      var options8 = Object.assign({ flipBackslashes: !0 }, opts);
      options8.flipBackslashes && isWin32 && str2.indexOf(slash2) < 0 && (str2 = str2.replace(backslash, slash2)), enclosure.test(str2) && (str2 += slash2), str2 += "a";
      do
        str2 = pathPosixDirname(str2);
      while (isGlob(str2) || globby.test(str2));
      return str2.replace(escaped, "$1");
    };
  }
}), require_utils = __commonJS({
  "node_modules/braces/lib/utils.js"(exports2) {
    exports2.isInteger = (num) => typeof num == "number" ? Number.isInteger(num) : typeof num == "string" && num.trim() !== "" ? Number.isInteger(Number(num)) : !1, exports2.find = (node, type2) => node.nodes.find((node2) => node2.type === type2), exports2.exceedsLimit = (min, max, step = 1, limit) => limit === !1 || !exports2.isInteger(min) || !exports2.isInteger(max) ? !1 : (Number(max) - Number(min)) / Number(step) >= limit, exports2.escapeNode = (block, n = 0, type2) => {
      let node = block.nodes[n];
      node && (type2 && node.type === type2 || node.type === "open" || node.type === "close") && node.escaped !== !0 && (node.value = "\\" + node.value, node.escaped = !0);
    }, exports2.encloseBrace = (node) => node.type !== "brace" || node.commas >> 0 + node.ranges >> 0 ? !1 : (node.invalid = !0, !0), exports2.isInvalidBrace = (block) => block.type !== "brace" ? !1 : block.invalid === !0 || block.dollar ? !0 : !(block.commas >> 0 + block.ranges >> 0) || block.open !== !0 || block.close !== !0 ? (block.invalid = !0, !0) : !1, exports2.isOpenOrClose = (node) => node.type === "open" || node.type === "close" ? !0 : node.open === !0 || node.close === !0, exports2.reduce = (nodes) => nodes.reduce((acc, node) => (node.type === "text" && acc.push(node.value), node.type === "range" && (node.type = "text"), acc), []), exports2.flatten = (...args) => {
      const result = [], flat = (arr) => {
        for (let i2 = 0; i2 < arr.length; i2++) {
          let ele = arr[i2];
          Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);
        }
        return result;
      };
      return flat(args), result;
    };
  }
}), require_stringify = __commonJS({
  "node_modules/braces/lib/stringify.js"(exports2, module2) {
    var utils2 = require_utils();
    module2.exports = (ast, options8 = {}) => {
      let stringify = (node, parent = {}) => {
        let invalidBlock = options8.escapeInvalid && utils2.isInvalidBrace(parent), invalidNode = node.invalid === !0 && options8.escapeInvalid === !0, output = "";
        if (node.value)
          return (invalidBlock || invalidNode) && utils2.isOpenOrClose(node) ? "\\" + node.value : node.value;
        if (node.value)
          return node.value;
        if (node.nodes)
          for (let child of node.nodes)
            output += stringify(child);
        return output;
      };
      return stringify(ast);
    };
  }
}), require_is_number = __commonJS({
  "node_modules/is-number/index.js"(exports2, module2) {
    module2.exports = function(num) {
      return typeof num == "number" ? num - num === 0 : typeof num == "string" && num.trim() !== "" ? Number.isFinite ? Number.isFinite(+num) : isFinite(+num) : !1;
    };
  }
}), require_to_regex_range = __commonJS({
  "node_modules/to-regex-range/index.js"(exports2, module2) {
    var isNumber = require_is_number(), toRegexRange = (min, max, options8) => {
      if (isNumber(min) === !1)
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      if (max === void 0 || min === max)
        return String(min);
      if (isNumber(max) === !1)
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      let opts = { relaxZeros: !0, ...options8 };
      typeof opts.strictZeros == "boolean" && (opts.relaxZeros = opts.strictZeros === !1);
      let relax = String(opts.relaxZeros), shorthand = String(opts.shorthand), capture = String(opts.capture), wrap = String(opts.wrap), cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
      if (toRegexRange.cache.hasOwnProperty(cacheKey))
        return toRegexRange.cache[cacheKey].result;
      let a = Math.min(min, max), b = Math.max(min, max);
      if (Math.abs(a - b) === 1) {
        let result = min + "|" + max;
        return opts.capture ? `(${result})` : opts.wrap === !1 ? result : `(?:${result})`;
      }
      let isPadded = hasPadding(min) || hasPadding(max), state = { min, max, a, b }, positives = [], negatives = [];
      if (isPadded && (state.isPadded = isPadded, state.maxLen = String(state.max).length), a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts), a = state.a = 0;
      }
      return b >= 0 && (positives = splitToPatterns(a, b, state, opts)), state.negatives = negatives, state.positives = positives, state.result = collatePatterns(negatives, positives), opts.capture === !0 ? state.result = `(${state.result})` : opts.wrap !== !1 && positives.length + negatives.length > 1 && (state.result = `(?:${state.result})`), toRegexRange.cache[cacheKey] = state, state.result;
    };
    function collatePatterns(neg, pos2, options8) {
      let onlyNegative = filterPatterns(neg, pos2, "-", !1) || [], onlyPositive = filterPatterns(pos2, neg, "", !1) || [], intersected = filterPatterns(neg, pos2, "-?", !0) || [];
      return onlyNegative.concat(intersected).concat(onlyPositive).join("|");
    }
    function splitToRanges(min, max) {
      let nines = 1, zeros = 1, stop = countNines(min, nines), stops = /* @__PURE__ */ new Set([max]);
      for (; min <= stop && stop <= max; )
        stops.add(stop), nines += 1, stop = countNines(min, nines);
      for (stop = countZeros(max + 1, zeros) - 1; min < stop && stop <= max; )
        stops.add(stop), zeros += 1, stop = countZeros(max + 1, zeros) - 1;
      return stops = [...stops], stops.sort(compare), stops;
    }
    function rangeToPattern(start, stop, options8) {
      if (start === stop)
        return { pattern: start, count: [], digits: 0 };
      let zipped = zip(start, stop), digits = zipped.length, pattern = "", count = 0;
      for (let i2 = 0; i2 < digits; i2++) {
        let [startDigit, stopDigit] = zipped[i2];
        startDigit === stopDigit ? pattern += startDigit : startDigit !== "0" || stopDigit !== "9" ? pattern += toCharacterClass(startDigit, stopDigit) : count++;
      }
      return count && (pattern += options8.shorthand === !0 ? "\\d" : "[0-9]"), { pattern, count: [count], digits };
    }
    function splitToPatterns(min, max, tok, options8) {
      let ranges = splitToRanges(min, max), tokens = [], start = min, prev;
      for (let i2 = 0; i2 < ranges.length; i2++) {
        let max2 = ranges[i2], obj = rangeToPattern(String(start), String(max2), options8), zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          prev.count.length > 1 && prev.count.pop(), prev.count.push(obj.count[0]), prev.string = prev.pattern + toQuantifier(prev.count), start = max2 + 1;
          continue;
        }
        tok.isPadded && (zeros = padZeros(max2, tok, options8)), obj.string = zeros + obj.pattern + toQuantifier(obj.count), tokens.push(obj), start = max2 + 1, prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options8) {
      let result = [];
      for (let ele of arr) {
        let { string } = ele;
        !intersection && !contains(comparison, "string", string) && result.push(prefix + string), intersection && contains(comparison, "string", string) && result.push(prefix + string);
      }
      return result;
    }
    function zip(a, b) {
      let arr = [];
      for (let i2 = 0; i2 < a.length; i2++)
        arr.push([a[i2], b[i2]]);
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains(arr, key2, val) {
      return arr.some((ele) => ele[key2] === val);
    }
    function countNines(min, len) {
      return Number(String(min).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      return stop || start > 1 ? `{${start + (stop ? "," + stop : "")}}` : "";
    }
    function toCharacterClass(a, b, options8) {
      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str2) {
      return /^-?(0+)\d/.test(str2);
    }
    function padZeros(value, tok, options8) {
      if (!tok.isPadded)
        return value;
      let diff = Math.abs(tok.maxLen - String(value).length), relax = options8.relaxZeros !== !1;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default:
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
      }
    }
    toRegexRange.cache = {}, toRegexRange.clearCache = () => toRegexRange.cache = {}, module2.exports = toRegexRange;
  }
}), require_fill_range = __commonJS({
  "node_modules/fill-range/index.js"(exports2, module2) {
    var util2 = __require("util"), toRegexRange = require_to_regex_range(), isObject3 = (val) => val !== null && typeof val == "object" && !Array.isArray(val), transform = (toNumber) => (value) => toNumber === !0 ? Number(value) : String(value), isValidValue = (value) => typeof value == "number" || typeof value == "string" && value !== "", isNumber = (num) => Number.isInteger(+num), zeros = (input) => {
      let value = `${input}`, index = -1;
      if (value[0] === "-" && (value = value.slice(1)), value === "0")
        return !1;
      for (; value[++index] === "0"; )
        ;
      return index > 0;
    }, stringify = (start, end, options8) => typeof start == "string" || typeof end == "string" ? !0 : options8.stringify === !0, pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        dash && (input = input.slice(1)), input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      return toNumber === !1 ? String(input) : input;
    }, toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      for (negative && (input = input.slice(1), maxLength--); input.length < maxLength; )
        input = "0" + input;
      return negative ? "-" + input : input;
    }, toSequence = (parts, options8) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0), parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix = options8.capture ? "" : "?:", positives = "", negatives = "", result;
      return parts.positives.length && (positives = parts.positives.join("|")), parts.negatives.length && (negatives = `-(${prefix}${parts.negatives.join("|")})`), positives && negatives ? result = `${positives}|${negatives}` : result = positives || negatives, options8.wrap ? `(${prefix}${result})` : result;
    }, toRange = (a, b, isNumbers, options8) => {
      if (isNumbers)
        return toRegexRange(a, b, { wrap: !1, ...options8 });
      let start = String.fromCharCode(a);
      if (a === b)
        return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    }, toRegex = (start, end, options8) => {
      if (Array.isArray(start)) {
        let wrap = options8.wrap === !0, prefix = options8.capture ? "" : "?:";
        return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options8);
    }, rangeError = (...args) => new RangeError("Invalid range arguments: " + util2.inspect(...args)), invalidRange = (start, end, options8) => {
      if (options8.strictRanges === !0)
        throw rangeError([start, end]);
      return [];
    }, invalidStep = (step, options8) => {
      if (options8.strictRanges === !0)
        throw new TypeError(`Expected step "${step}" to be a number`);
      return [];
    }, fillNumbers = (start, end, step = 1, options8 = {}) => {
      let a = Number(start), b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options8.strictRanges === !0)
          throw rangeError([start, end]);
        return [];
      }
      a === 0 && (a = 0), b === 0 && (b = 0);
      let descending = a > b, startString = String(start), endString = String(end), stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString), maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0, toNumber = padded === !1 && stringify(start, end, options8) === !1, format3 = options8.transform || transform(toNumber);
      if (options8.toRegex && step === 1)
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), !0, options8);
      let parts = { negatives: [], positives: [] }, push2 = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num)), range = [], index = 0;
      for (; descending ? a >= b : a <= b; )
        options8.toRegex === !0 && step > 1 ? push2(a) : range.push(pad(format3(a, index), maxLen, toNumber)), a = descending ? a - step : a + step, index++;
      return options8.toRegex === !0 ? step > 1 ? toSequence(parts, options8) : toRegex(range, null, { wrap: !1, ...options8 }) : range;
    }, fillLetters = (start, end, step = 1, options8 = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1)
        return invalidRange(start, end, options8);
      let format3 = options8.transform || ((val) => String.fromCharCode(val)), a = `${start}`.charCodeAt(0), b = `${end}`.charCodeAt(0), descending = a > b, min = Math.min(a, b), max = Math.max(a, b);
      if (options8.toRegex && step === 1)
        return toRange(min, max, !1, options8);
      let range = [], index = 0;
      for (; descending ? a >= b : a <= b; )
        range.push(format3(a, index)), a = descending ? a - step : a + step, index++;
      return options8.toRegex === !0 ? toRegex(range, null, { wrap: !1, options: options8 }) : range;
    }, fill2 = (start, end, step, options8 = {}) => {
      if (end == null && isValidValue(start))
        return [start];
      if (!isValidValue(start) || !isValidValue(end))
        return invalidRange(start, end, options8);
      if (typeof step == "function")
        return fill2(start, end, 1, { transform: step });
      if (isObject3(step))
        return fill2(start, end, 0, step);
      let opts = { ...options8 };
      return opts.capture === !0 && (opts.wrap = !0), step = step || opts.step || 1, isNumber(step) ? isNumber(start) && isNumber(end) ? fillNumbers(start, end, step, opts) : fillLetters(start, end, Math.max(Math.abs(step), 1), opts) : step != null && !isObject3(step) ? invalidStep(step, opts) : fill2(start, end, 1, step);
    };
    module2.exports = fill2;
  }
}), require_compile = __commonJS({
  "node_modules/braces/lib/compile.js"(exports2, module2) {
    var fill2 = require_fill_range(), utils2 = require_utils(), compile = (ast, options8 = {}) => {
      let walk = (node, parent = {}) => {
        let invalidBlock = utils2.isInvalidBrace(parent), invalidNode = node.invalid === !0 && options8.escapeInvalid === !0, invalid = invalidBlock === !0 || invalidNode === !0, prefix = options8.escapeInvalid === !0 ? "\\" : "", output = "";
        if (node.isOpen === !0 || node.isClose === !0)
          return prefix + node.value;
        if (node.type === "open")
          return invalid ? prefix + node.value : "(";
        if (node.type === "close")
          return invalid ? prefix + node.value : ")";
        if (node.type === "comma")
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        if (node.value)
          return node.value;
        if (node.nodes && node.ranges > 0) {
          let args = utils2.reduce(node.nodes), range = fill2(...args, { ...options8, wrap: !1, toRegex: !0 });
          if (range.length !== 0)
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
        }
        if (node.nodes)
          for (let child of node.nodes)
            output += walk(child, node);
        return output;
      };
      return walk(ast);
    };
    module2.exports = compile;
  }
}), require_expand = __commonJS({
  "node_modules/braces/lib/expand.js"(exports2, module2) {
    var fill2 = require_fill_range(), stringify = require_stringify(), utils2 = require_utils(), append = (queue = "", stash = "", enclose = !1) => {
      let result = [];
      if (queue = [].concat(queue), stash = [].concat(stash), !stash.length)
        return queue;
      if (!queue.length)
        return enclose ? utils2.flatten(stash).map((ele) => `{${ele}}`) : stash;
      for (let item of queue)
        if (Array.isArray(item))
          for (let value of item)
            result.push(append(value, stash, enclose));
        else
          for (let ele of stash)
            enclose === !0 && typeof ele == "string" && (ele = `{${ele}}`), result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
      return utils2.flatten(result);
    }, expand = (ast, options8 = {}) => {
      let rangeLimit = options8.rangeLimit === void 0 ? 1e3 : options8.rangeLimit, walk = (node, parent = {}) => {
        node.queue = [];
        let p = parent, q = parent.queue;
        for (; p.type !== "brace" && p.type !== "root" && p.parent; )
          p = p.parent, q = p.queue;
        if (node.invalid || node.dollar) {
          q.push(append(q.pop(), stringify(node, options8)));
          return;
        }
        if (node.type === "brace" && node.invalid !== !0 && node.nodes.length === 2) {
          q.push(append(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils2.reduce(node.nodes);
          if (utils2.exceedsLimit(...args, options8.step, rangeLimit))
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          let range = fill2(...args, options8);
          range.length === 0 && (range = stringify(node, options8)), q.push(append(q.pop(), range)), node.nodes = [];
          return;
        }
        let enclose = utils2.encloseBrace(node), queue = node.queue, block = node;
        for (; block.type !== "brace" && block.type !== "root" && block.parent; )
          block = block.parent, queue = block.queue;
        for (let i2 = 0; i2 < node.nodes.length; i2++) {
          let child = node.nodes[i2];
          if (child.type === "comma" && node.type === "brace") {
            i2 === 1 && queue.push(""), queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append(q.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          child.nodes && walk(child, node);
        }
        return queue;
      };
      return utils2.flatten(walk(ast));
    };
    module2.exports = expand;
  }
}), require_constants = __commonJS({
  "node_modules/braces/lib/constants.js"(exports2, module2) {
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      // Digits
      CHAR_0: "0",
      /* 0 */
      CHAR_9: "9",
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: "A",
      /* A */
      CHAR_LOWERCASE_A: "a",
      /* a */
      CHAR_UPPERCASE_Z: "Z",
      /* Z */
      CHAR_LOWERCASE_Z: "z",
      /* z */
      CHAR_LEFT_PARENTHESES: "(",
      /* ( */
      CHAR_RIGHT_PARENTHESES: ")",
      /* ) */
      CHAR_ASTERISK: "*",
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: "&",
      /* & */
      CHAR_AT: "@",
      /* @ */
      CHAR_BACKSLASH: "\\",
      /* \ */
      CHAR_BACKTICK: "`",
      /* ` */
      CHAR_CARRIAGE_RETURN: "\r",
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: "^",
      /* ^ */
      CHAR_COLON: ":",
      /* : */
      CHAR_COMMA: ",",
      /* , */
      CHAR_DOLLAR: "$",
      /* . */
      CHAR_DOT: ".",
      /* . */
      CHAR_DOUBLE_QUOTE: '"',
      /* " */
      CHAR_EQUAL: "=",
      /* = */
      CHAR_EXCLAMATION_MARK: "!",
      /* ! */
      CHAR_FORM_FEED: "\f",
      /* \f */
      CHAR_FORWARD_SLASH: "/",
      /* / */
      CHAR_HASH: "#",
      /* # */
      CHAR_HYPHEN_MINUS: "-",
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: "<",
      /* < */
      CHAR_LEFT_CURLY_BRACE: "{",
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: "[",
      /* [ */
      CHAR_LINE_FEED: `
`,
      /* \n */
      CHAR_NO_BREAK_SPACE: "\xA0",
      /* \u00A0 */
      CHAR_PERCENT: "%",
      /* % */
      CHAR_PLUS: "+",
      /* + */
      CHAR_QUESTION_MARK: "?",
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      /* > */
      CHAR_RIGHT_CURLY_BRACE: "}",
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      /* ] */
      CHAR_SEMICOLON: ";",
      /* ; */
      CHAR_SINGLE_QUOTE: "'",
      /* ' */
      CHAR_SPACE: " ",
      /*   */
      CHAR_TAB: "	",
      /* \t */
      CHAR_UNDERSCORE: "_",
      /* _ */
      CHAR_VERTICAL_LINE: "|",
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
      /* \uFEFF */
    };
  }
}), require_parse = __commonJS({
  "node_modules/braces/lib/parse.js"(exports2, module2) {
    var stringify = require_stringify(), {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      /* \ */
      CHAR_BACKTICK,
      /* ` */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_RIGHT_SQUARE_BRACKET,
      /* ] */
      CHAR_DOUBLE_QUOTE,
      /* " */
      CHAR_SINGLE_QUOTE,
      /* ' */
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants(), parse6 = (input, options8 = {}) => {
      if (typeof input != "string")
        throw new TypeError("Expected a string");
      let opts = options8 || {}, max = typeof opts.maxLength == "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max)
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      let ast = { type: "root", input, nodes: [] }, stack2 = [ast], block = ast, prev = ast, brackets = 0, length = input.length, index = 0, depth = 0, value;
      const advance = () => input[index++], push2 = (node) => {
        if (node.type === "text" && prev.type === "dot" && (prev.type = "text"), prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        return block.nodes.push(node), node.parent = block, node.prev = prev, prev = node, node;
      };
      for (push2({ type: "bos" }); index < length; )
        if (block = stack2[stack2.length - 1], value = advance(), !(value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE)) {
          if (value === CHAR_BACKSLASH) {
            push2({ type: "text", value: (options8.keepEscaping ? value : "") + advance() });
            continue;
          }
          if (value === CHAR_RIGHT_SQUARE_BRACKET) {
            push2({ type: "text", value: "\\" + value });
            continue;
          }
          if (value === CHAR_LEFT_SQUARE_BRACKET) {
            brackets++;
            let next;
            for (; index < length && (next = advance()); ) {
              if (value += next, next === CHAR_LEFT_SQUARE_BRACKET) {
                brackets++;
                continue;
              }
              if (next === CHAR_BACKSLASH) {
                value += advance();
                continue;
              }
              if (next === CHAR_RIGHT_SQUARE_BRACKET && (brackets--, brackets === 0))
                break;
            }
            push2({ type: "text", value });
            continue;
          }
          if (value === CHAR_LEFT_PARENTHESES) {
            block = push2({ type: "paren", nodes: [] }), stack2.push(block), push2({ type: "text", value });
            continue;
          }
          if (value === CHAR_RIGHT_PARENTHESES) {
            if (block.type !== "paren") {
              push2({ type: "text", value });
              continue;
            }
            block = stack2.pop(), push2({ type: "text", value }), block = stack2[stack2.length - 1];
            continue;
          }
          if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
            let open = value, next;
            for (options8.keepQuotes !== !0 && (value = ""); index < length && (next = advance()); ) {
              if (next === CHAR_BACKSLASH) {
                value += next + advance();
                continue;
              }
              if (next === open) {
                options8.keepQuotes === !0 && (value += next);
                break;
              }
              value += next;
            }
            push2({ type: "text", value });
            continue;
          }
          if (value === CHAR_LEFT_CURLY_BRACE) {
            depth++;
            let brace = {
              type: "brace",
              open: !0,
              close: !1,
              dollar: prev.value && prev.value.slice(-1) === "$" || block.dollar === !0,
              depth,
              commas: 0,
              ranges: 0,
              nodes: []
            };
            block = push2(brace), stack2.push(block), push2({ type: "open", value });
            continue;
          }
          if (value === CHAR_RIGHT_CURLY_BRACE) {
            if (block.type !== "brace") {
              push2({ type: "text", value });
              continue;
            }
            let type2 = "close";
            block = stack2.pop(), block.close = !0, push2({ type: type2, value }), depth--, block = stack2[stack2.length - 1];
            continue;
          }
          if (value === CHAR_COMMA && depth > 0) {
            if (block.ranges > 0) {
              block.ranges = 0;
              let open = block.nodes.shift();
              block.nodes = [open, { type: "text", value: stringify(block) }];
            }
            push2({ type: "comma", value }), block.commas++;
            continue;
          }
          if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
            let siblings = block.nodes;
            if (depth === 0 || siblings.length === 0) {
              push2({ type: "text", value });
              continue;
            }
            if (prev.type === "dot") {
              if (block.range = [], prev.value += value, prev.type = "range", block.nodes.length !== 3 && block.nodes.length !== 5) {
                block.invalid = !0, block.ranges = 0, prev.type = "text";
                continue;
              }
              block.ranges++, block.args = [];
              continue;
            }
            if (prev.type === "range") {
              siblings.pop();
              let before = siblings[siblings.length - 1];
              before.value += prev.value + value, prev = before, block.ranges--;
              continue;
            }
            push2({ type: "dot", value });
            continue;
          }
          push2({ type: "text", value });
        }
      do
        if (block = stack2.pop(), block.type !== "root") {
          block.nodes.forEach((node) => {
            node.nodes || (node.type === "open" && (node.isOpen = !0), node.type === "close" && (node.isClose = !0), node.nodes || (node.type = "text"), node.invalid = !0);
          });
          let parent = stack2[stack2.length - 1], index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      while (stack2.length > 0);
      return push2({ type: "eos" }), ast;
    };
    module2.exports = parse6;
  }
}), require_braces = __commonJS({
  "node_modules/braces/index.js"(exports2, module2) {
    var stringify = require_stringify(), compile = require_compile(), expand = require_expand(), parse6 = require_parse(), braces = (input, options8 = {}) => {
      let output = [];
      if (Array.isArray(input))
        for (let pattern of input) {
          let result = braces.create(pattern, options8);
          Array.isArray(result) ? output.push(...result) : output.push(result);
        }
      else
        output = [].concat(braces.create(input, options8));
      return options8 && options8.expand === !0 && options8.nodupes === !0 && (output = [...new Set(output)]), output;
    };
    braces.parse = (input, options8 = {}) => parse6(input, options8), braces.stringify = (input, options8 = {}) => stringify(typeof input == "string" ? braces.parse(input, options8) : input, options8), braces.compile = (input, options8 = {}) => (typeof input == "string" && (input = braces.parse(input, options8)), compile(input, options8)), braces.expand = (input, options8 = {}) => {
      typeof input == "string" && (input = braces.parse(input, options8));
      let result = expand(input, options8);
      return options8.noempty === !0 && (result = result.filter(Boolean)), options8.nodupes === !0 && (result = [...new Set(result)]), result;
    }, braces.create = (input, options8 = {}) => input === "" || input.length < 3 ? [input] : options8.expand !== !0 ? braces.compile(input, options8) : braces.expand(input, options8), module2.exports = braces;
  }
}), require_constants2 = __commonJS({
  "node_modules/picomatch/lib/constants.js"(exports2, module2) {
    var path13 = __require("path"), WIN_SLASH = "\\\\/", WIN_NO_SLASH = `[^${WIN_SLASH}]`, DOT_LITERAL = "\\.", PLUS_LITERAL = "\\+", QMARK_LITERAL = "\\?", SLASH_LITERAL = "\\/", ONE_CHAR = "(?=.)", QMARK = "[^/]", END_ANCHOR = `(?:${SLASH_LITERAL}|$)`, START_ANCHOR = `(?:^|${SLASH_LITERAL})`, DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`, NO_DOT = `(?!${DOT_LITERAL})`, NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`, NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`, NO_DOTS_SLASH = `(?!${DOTS_SLASH})`, QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`, STAR = `${QMARK}*?`, POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    }, WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    }, POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path13.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win32) {
        return win32 === !0 ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
}), require_utils2 = __commonJS({
  "node_modules/picomatch/lib/utils.js"(exports2) {
    var path13 = __require("path"), win32 = process.platform === "win32", {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants2();
    exports2.isObject = (val) => val !== null && typeof val == "object" && !Array.isArray(val), exports2.hasRegexChars = (str2) => REGEX_SPECIAL_CHARS.test(str2), exports2.isRegexChar = (str2) => str2.length === 1 && exports2.hasRegexChars(str2), exports2.escapeRegex = (str2) => str2.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1"), exports2.toPosixSlashes = (str2) => str2.replace(REGEX_BACKSLASH, "/"), exports2.removeBackslashes = (str2) => str2.replace(REGEX_REMOVE_BACKSLASH, (match) => match === "\\" ? "" : match), exports2.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      return segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10;
    }, exports2.isWindows = (options8) => options8 && typeof options8.windows == "boolean" ? options8.windows : win32 === !0 || path13.sep === "\\", exports2.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      return idx === -1 ? input : input[idx - 1] === "\\" ? exports2.escapeLast(input, char, idx - 1) : `${input.slice(0, idx)}\\${input.slice(idx)}`;
    }, exports2.removePrefix = (input, state = {}) => {
      let output = input;
      return output.startsWith("./") && (output = output.slice(2), state.prefix = "./"), output;
    }, exports2.wrapOutput = (input, state = {}, options8 = {}) => {
      const prepend = options8.contains ? "" : "^", append = options8.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      return state.negated === !0 && (output = `(?:^(?!${output}).*$)`), output;
    };
  }
}), require_scan = __commonJS({
  "node_modules/picomatch/lib/scan.js"(exports2, module2) {
    var utils2 = require_utils2(), {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants2(), isPathSeparator = (code) => code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH, depth = (token2) => {
      token2.isPrefix !== !0 && (token2.depth = token2.isGlobstar ? 1 / 0 : 1);
    }, scan = (input, options8) => {
      const opts = options8 || {}, length = input.length - 1, scanToEnd = opts.parts === !0 || opts.scanToEnd === !0, slashes = [], tokens = [], parts = [];
      let str2 = input, index = -1, start = 0, lastIndex = 0, isBrace = !1, isBracket = !1, isGlob = !1, isExtglob = !1, isGlobstar = !1, braceEscaped = !1, backslashes = !1, negated = !1, negatedExtglob = !1, finished = !1, braces = 0, prev, code, token2 = { value: "", depth: 0, isGlob: !1 };
      const eos = () => index >= length, peek2 = () => str2.charCodeAt(index + 1), advance = () => (prev = code, str2.charCodeAt(++index));
      for (; index < length; ) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token2.backslashes = !0, code = advance(), code === CHAR_LEFT_CURLY_BRACE && (braceEscaped = !0);
          continue;
        }
        if (braceEscaped === !0 || code === CHAR_LEFT_CURLY_BRACE) {
          for (braces++; eos() !== !0 && (code = advance()); ) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token2.backslashes = !0, advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== !0 && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              if (isBrace = token2.isBrace = !0, isGlob = token2.isGlob = !0, finished = !0, scanToEnd === !0)
                continue;
              break;
            }
            if (braceEscaped !== !0 && code === CHAR_COMMA) {
              if (isBrace = token2.isBrace = !0, isGlob = token2.isGlob = !0, finished = !0, scanToEnd === !0)
                continue;
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE && (braces--, braces === 0)) {
              braceEscaped = !1, isBrace = token2.isBrace = !0, finished = !0;
              break;
            }
          }
          if (scanToEnd === !0)
            continue;
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          if (slashes.push(index), tokens.push(token2), token2 = { value: "", depth: 0, isGlob: !1 }, finished === !0)
            continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== !0 && (code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK) === !0 && peek2() === CHAR_LEFT_PARENTHESES) {
          if (isGlob = token2.isGlob = !0, isExtglob = token2.isExtglob = !0, finished = !0, code === CHAR_EXCLAMATION_MARK && index === start && (negatedExtglob = !0), scanToEnd === !0) {
            for (; eos() !== !0 && (code = advance()); ) {
              if (code === CHAR_BACKWARD_SLASH) {
                backslashes = token2.backslashes = !0, code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                isGlob = token2.isGlob = !0, finished = !0;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK && (isGlobstar = token2.isGlobstar = !0), isGlob = token2.isGlob = !0, finished = !0, scanToEnd === !0)
            continue;
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          if (isGlob = token2.isGlob = !0, finished = !0, scanToEnd === !0)
            continue;
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          for (; eos() !== !0 && (next = advance()); ) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token2.backslashes = !0, advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token2.isBracket = !0, isGlob = token2.isGlob = !0, finished = !0;
              break;
            }
          }
          if (scanToEnd === !0)
            continue;
          break;
        }
        if (opts.nonegate !== !0 && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token2.negated = !0, start++;
          continue;
        }
        if (opts.noparen !== !0 && code === CHAR_LEFT_PARENTHESES) {
          if (isGlob = token2.isGlob = !0, scanToEnd === !0) {
            for (; eos() !== !0 && (code = advance()); ) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token2.backslashes = !0, code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = !0;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === !0) {
          if (finished = !0, scanToEnd === !0)
            continue;
          break;
        }
      }
      opts.noext === !0 && (isExtglob = !1, isGlob = !1);
      let base = str2, prefix = "", glob = "";
      start > 0 && (prefix = str2.slice(0, start), str2 = str2.slice(start), lastIndex -= start), base && isGlob === !0 && lastIndex > 0 ? (base = str2.slice(0, lastIndex), glob = str2.slice(lastIndex)) : isGlob === !0 ? (base = "", glob = str2) : base = str2, base && base !== "" && base !== "/" && base !== str2 && isPathSeparator(base.charCodeAt(base.length - 1)) && (base = base.slice(0, -1)), opts.unescape === !0 && (glob && (glob = utils2.removeBackslashes(glob)), base && backslashes === !0 && (base = utils2.removeBackslashes(base)));
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === !0 && (state.maxDepth = 0, isPathSeparator(code) || tokens.push(token2), state.tokens = tokens), opts.parts === !0 || opts.tokens === !0) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start, i2 = slashes[idx], value = input.slice(n, i2);
          opts.tokens && (idx === 0 && start !== 0 ? (tokens[idx].isPrefix = !0, tokens[idx].value = prefix) : tokens[idx].value = value, depth(tokens[idx]), state.maxDepth += tokens[idx].depth), (idx !== 0 || value !== "") && parts.push(value), prevIndex = i2;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value), opts.tokens && (tokens[tokens.length - 1].value = value, depth(tokens[tokens.length - 1]), state.maxDepth += tokens[tokens.length - 1].depth);
        }
        state.slashes = slashes, state.parts = parts;
      }
      return state;
    };
    module2.exports = scan;
  }
}), require_parse2 = __commonJS({
  "node_modules/picomatch/lib/parse.js"(exports2, module2) {
    var constants = require_constants2(), utils2 = require_utils2(), {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants, expandRange = (args, options8) => {
      if (typeof options8.expandRange == "function")
        return options8.expandRange(...args, options8);
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch {
        return args.map((v) => utils2.escapeRegex(v)).join("..");
      }
      return value;
    }, syntaxError2 = (type2, char) => `Missing ${type2}: "${char}" - use "\\\\${char}" to match literal characters`, parse6 = (input, options8) => {
      if (typeof input != "string")
        throw new TypeError("Expected a string");
      input = REPLACEMENTS[input] || input;
      const opts = { ...options8 }, max = typeof opts.maxLength == "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max)
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      const bos = { type: "bos", value: "", output: opts.prepend || "" }, tokens = [bos], capture = opts.capture ? "" : "?:", win32 = utils2.isWindows(options8), PLATFORM_CHARS = constants.globChars(win32), EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS), {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS, globstar = (opts2) => `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`, nodot = opts.dot ? "" : NO_DOT, qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === !0 ? globstar(opts) : STAR;
      opts.capture && (star = `(${star})`), typeof opts.noext == "boolean" && (opts.noextglob = opts.noext);
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === !0,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: !1,
        negated: !1,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: !1,
        tokens
      };
      input = utils2.removePrefix(input, state), len = input.length;
      const extglobs = [], braces = [], stack2 = [];
      let prev = bos, value;
      const eos = () => state.index === len - 1, peek2 = state.peek = (n = 1) => input[state.index + n], advance = state.advance = () => input[++state.index] || "", remaining = () => input.slice(state.index + 1), consume = (value2 = "", num = 0) => {
        state.consumed += value2, state.index += num;
      }, append = (token2) => {
        state.output += token2.output != null ? token2.output : token2.value, consume(token2.value);
      }, negate = () => {
        let count = 1;
        for (; peek2() === "!" && (peek2(2) !== "(" || peek2(3) === "?"); )
          advance(), state.start++, count++;
        return count % 2 === 0 ? !1 : (state.negated = !0, state.start++, !0);
      }, increment = (type2) => {
        state[type2]++, stack2.push(type2);
      }, decrement = (type2) => {
        state[type2]--, stack2.pop();
      }, push2 = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace"), isExtglob = tok.extglob === !0 || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob && (state.output = state.output.slice(0, -prev.output.length), prev.type = "star", prev.value = "*", prev.output = star, state.output += prev.output);
        }
        if (extglobs.length && tok.type !== "paren" && (extglobs[extglobs.length - 1].inner += tok.value), (tok.value || tok.output) && append(tok), prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value, prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev, tokens.push(tok), prev = tok;
      }, extglobOpen = (type2, value2) => {
        const token2 = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token2.prev = prev, token2.parens = state.parens, token2.output = state.output;
        const output = (opts.capture ? "(" : "") + token2.open;
        increment("parens"), push2({ type: type2, value: value2, output: state.output ? "" : ONE_CHAR }), push2({ type: "paren", extglob: !0, value: advance(), output }), extglobs.push(token2);
      }, extglobClose = (token2) => {
        let output = token2.close + (opts.capture ? ")" : ""), rest;
        if (token2.type === "negate") {
          let extglobStar = star;
          if (token2.inner && token2.inner.length > 1 && token2.inner.includes("/") && (extglobStar = globstar(opts)), (extglobStar !== star || eos() || /^\)+$/.test(remaining())) && (output = token2.close = `)$))${extglobStar}`), token2.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse6(rest, { ...options8, fastpaths: !1 }).output;
            output = token2.close = `)${expression})${extglobStar})`;
          }
          token2.prev.type === "bos" && (state.negatedExtglob = !0);
        }
        push2({ type: "paren", extglob: !0, value, output }), decrement("parens");
      };
      if (opts.fastpaths !== !1 && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = !1, output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => first === "\\" ? (backslashes = !0, m) : first === "?" ? esc ? esc + first + (rest ? QMARK.repeat(rest.length) : "") : index === 0 ? qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "") : QMARK.repeat(chars.length) : first === "." ? DOT_LITERAL.repeat(chars.length) : first === "*" ? esc ? esc + first + (rest ? star : "") : star : esc ? m : `\\${m}`);
        return backslashes === !0 && (opts.unescape === !0 ? output = output.replace(/\\/g, "") : output = output.replace(/\\+/g, (m) => m.length % 2 === 0 ? "\\\\" : m ? "\\" : "")), output === input && opts.contains === !0 ? (state.output = input, state) : (state.output = utils2.wrapOutput(output, state, options8), state);
      }
      for (; !eos(); ) {
        if (value = advance(), value === "\0")
          continue;
        if (value === "\\") {
          const next = peek2();
          if (next === "/" && opts.bash !== !0 || next === "." || next === ";")
            continue;
          if (!next) {
            value += "\\", push2({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2 && (slashes = match[0].length, state.index += slashes, slashes % 2 !== 0 && (value += "\\")), opts.unescape === !0 ? value = advance() : value += advance(), state.brackets === 0) {
            push2({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== !1 && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[") && (prev.posix = !0, inner.includes(":"))) {
              const idx = prev.value.lastIndexOf("["), pre = prev.value.slice(0, idx), rest2 = prev.value.slice(idx + 2), posix = POSIX_REGEX_SOURCE[rest2];
              if (posix) {
                prev.value = pre + posix, state.backtrack = !0, advance(), !bos.output && tokens.indexOf(prev) === 1 && (bos.output = ONE_CHAR);
                continue;
              }
            }
          }
          (value === "[" && peek2() !== ":" || value === "-" && peek2() === "]") && (value = `\\${value}`), value === "]" && (prev.value === "[" || prev.value === "[^") && (value = `\\${value}`), opts.posix === !0 && value === "!" && prev.value === "[" && (value = "^"), prev.value += value, append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils2.escapeRegex(value), prev.value += value, append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1, opts.keepQuotes === !0 && push2({ type: "text", value });
          continue;
        }
        if (value === "(") {
          increment("parens"), push2({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === !0)
            throw new SyntaxError(syntaxError2("opening", "("));
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push2({ type: "paren", value, output: state.parens ? ")" : "\\)" }), decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === !0 || !remaining().includes("]")) {
            if (opts.nobracket !== !0 && opts.strictBrackets === !0)
              throw new SyntaxError(syntaxError2("closing", "]"));
            value = `\\${value}`;
          } else
            increment("brackets");
          push2({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === !0 || prev && prev.type === "bracket" && prev.value.length === 1) {
            push2({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === !0)
              throw new SyntaxError(syntaxError2("opening", "["));
            push2({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== !0 && prevValue[0] === "^" && !prevValue.includes("/") && (value = `/${value}`), prev.value += value, append({ value }), opts.literalBrackets === !1 || utils2.hasRegexChars(prevValue))
            continue;
          const escaped = utils2.escapeRegex(prev.value);
          if (state.output = state.output.slice(0, -prev.value.length), opts.literalBrackets === !0) {
            state.output += escaped, prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`, state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== !0) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open), push2(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === !0 || !brace) {
            push2({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === !0) {
            const arr = tokens.slice(), range = [];
            for (let i2 = arr.length - 1; i2 >= 0 && (tokens.pop(), arr[i2].type !== "brace"); i2--)
              arr[i2].type !== "dots" && range.unshift(arr[i2].value);
            output = expandRange(range, opts), state.backtrack = !0;
          }
          if (brace.comma !== !0 && brace.dots !== !0) {
            const out = state.output.slice(0, brace.outputIndex), toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{", value = output = "\\}", state.output = out;
            for (const t of toks)
              state.output += t.output || t.value;
          }
          push2({ type: "brace", value, output }), decrement("braces"), braces.pop();
          continue;
        }
        if (value === "|") {
          extglobs.length > 0 && extglobs[extglobs.length - 1].conditions++, push2({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          brace && stack2[stack2.length - 1] === "braces" && (brace.comma = !0, output = "|"), push2({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1, state.consumed = "", state.output = "", tokens.pop(), prev = bos;
            continue;
          }
          push2({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            prev.value === "." && (prev.output = DOT_LITERAL);
            const brace = braces[braces.length - 1];
            prev.type = "dots", prev.output += value, prev.value += value, brace.dots = !0;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push2({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push2({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          if (!(prev && prev.value === "(") && opts.noextglob !== !0 && peek2() === "(" && peek2(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek2();
            let output = value;
            if (next === "<" && !utils2.supportsLookbehinds())
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) && (output = `\\${value}`), push2({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== !0 && (prev.type === "slash" || prev.type === "bos")) {
            push2({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push2({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== !0 && peek2() === "(" && (peek2(2) !== "?" || !/[!=<:]/.test(peek2(3)))) {
            extglobOpen("negate", value);
            continue;
          }
          if (opts.nonegate !== !0 && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== !0 && peek2() === "(" && peek2(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === !1) {
            push2({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push2({ type: "plus", value });
            continue;
          }
          push2({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== !0 && peek2() === "(" && peek2(2) !== "?") {
            push2({ type: "at", extglob: !0, value, output: "" });
            continue;
          }
          push2({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          (value === "$" || value === "^") && (value = `\\${value}`);
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          match && (value += match[0], state.index += match[0].length), push2({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === !0)) {
          prev.type = "star", prev.star = !0, prev.value += value, prev.output = star, state.backtrack = !0, state.globstar = !0, consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== !0 && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === !0) {
            consume(value);
            continue;
          }
          const prior = prev.prev, before = prior.prev, isStart = prior.type === "slash" || prior.type === "bos", afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === !0 && (!isStart || rest[0] && rest[0] !== "/")) {
            push2({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace"), isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push2({ type: "star", value, output: "" });
            continue;
          }
          for (; rest.slice(0, 3) === "/**"; ) {
            const after = input[state.index + 4];
            if (after && after !== "/")
              break;
            rest = rest.slice(3), consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar", prev.value += value, prev.output = globstar(opts), state.output = prev.output, state.globstar = !0, consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length), prior.output = `(?:${prior.output}`, prev.type = "globstar", prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)"), prev.value += value, state.globstar = !0, state.output += prior.output + prev.output, consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length), prior.output = `(?:${prior.output}`, prev.type = "globstar", prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`, prev.value += value, state.output += prior.output + prev.output, state.globstar = !0, consume(value + advance()), push2({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar", prev.value += value, prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`, state.output = prev.output, state.globstar = !0, consume(value + advance()), push2({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length), prev.type = "globstar", prev.output = globstar(opts), prev.value += value, state.output += prev.output, state.globstar = !0, consume(value);
          continue;
        }
        const token2 = { type: "star", value, output: star };
        if (opts.bash === !0) {
          token2.output = ".*?", (prev.type === "bos" || prev.type === "slash") && (token2.output = nodot + token2.output), push2(token2);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === !0) {
          token2.output = value, push2(token2);
          continue;
        }
        (state.index === state.start || prev.type === "slash" || prev.type === "dot") && (prev.type === "dot" ? (state.output += NO_DOT_SLASH, prev.output += NO_DOT_SLASH) : opts.dot === !0 ? (state.output += NO_DOTS_SLASH, prev.output += NO_DOTS_SLASH) : (state.output += nodot, prev.output += nodot), peek2() !== "*" && (state.output += ONE_CHAR, prev.output += ONE_CHAR)), push2(token2);
      }
      for (; state.brackets > 0; ) {
        if (opts.strictBrackets === !0)
          throw new SyntaxError(syntaxError2("closing", "]"));
        state.output = utils2.escapeLast(state.output, "["), decrement("brackets");
      }
      for (; state.parens > 0; ) {
        if (opts.strictBrackets === !0)
          throw new SyntaxError(syntaxError2("closing", ")"));
        state.output = utils2.escapeLast(state.output, "("), decrement("parens");
      }
      for (; state.braces > 0; ) {
        if (opts.strictBrackets === !0)
          throw new SyntaxError(syntaxError2("closing", "}"));
        state.output = utils2.escapeLast(state.output, "{"), decrement("braces");
      }
      if (opts.strictSlashes !== !0 && (prev.type === "star" || prev.type === "bracket") && push2({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` }), state.backtrack === !0) {
        state.output = "";
        for (const token2 of state.tokens)
          state.output += token2.output != null ? token2.output : token2.value, token2.suffix && (state.output += token2.suffix);
      }
      return state;
    };
    parse6.fastpaths = (input, options8) => {
      const opts = { ...options8 }, max = typeof opts.maxLength == "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH, len = input.length;
      if (len > max)
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      input = REPLACEMENTS[input] || input;
      const win32 = utils2.isWindows(options8), {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32), nodot = opts.dot ? NO_DOTS : NO_DOT, slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT, capture = opts.capture ? "" : "?:", state = { negated: !1, prefix: "" };
      let star = opts.bash === !0 ? ".*?" : STAR;
      opts.capture && (star = `(${star})`);
      const globstar = (opts2) => opts2.noglobstar === !0 ? star : `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`, create = (str2) => {
        switch (str2) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str2);
            if (!match)
              return;
            const source3 = create(match[1]);
            return source3 ? source3 + DOT_LITERAL + match[2] : void 0;
          }
        }
      }, output = utils2.removePrefix(input, state);
      let source2 = create(output);
      return source2 && opts.strictSlashes !== !0 && (source2 += `${SLASH_LITERAL}?`), source2;
    }, module2.exports = parse6;
  }
}), require_picomatch = __commonJS({
  "node_modules/picomatch/lib/picomatch.js"(exports2, module2) {
    var path13 = __require("path"), scan = require_scan(), parse6 = require_parse2(), utils2 = require_utils2(), constants = require_constants2(), isObject3 = (val) => val && typeof val == "object" && !Array.isArray(val), picomatch = (glob, options8, returnState = !1) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options8, returnState));
        return (str2) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str2);
            if (state2)
              return state2;
          }
          return !1;
        };
      }
      const isState = isObject3(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob != "string" && !isState)
        throw new TypeError("Expected pattern to be a non-empty string");
      const opts = options8 || {}, posix = utils2.isWindows(options8), regex = isState ? picomatch.compileRe(glob, options8) : picomatch.makeRe(glob, options8, !1, !0), state = regex.state;
      delete regex.state;
      let isIgnored2 = () => !1;
      if (opts.ignore) {
        const ignoreOpts = { ...options8, ignore: null, onMatch: null, onResult: null };
        isIgnored2 = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = !1) => {
        const { isMatch, match, output } = picomatch.test(input, regex, options8, { glob, posix }), result = { glob, state, regex, posix, input, output, match, isMatch };
        return typeof opts.onResult == "function" && opts.onResult(result), isMatch === !1 ? (result.isMatch = !1, returnObject ? result : !1) : isIgnored2(input) ? (typeof opts.onIgnore == "function" && opts.onIgnore(result), result.isMatch = !1, returnObject ? result : !1) : (typeof opts.onMatch == "function" && opts.onMatch(result), returnObject ? result : !0);
      };
      return returnState && (matcher.state = state), matcher;
    };
    picomatch.test = (input, regex, options8, { glob, posix } = {}) => {
      if (typeof input != "string")
        throw new TypeError("Expected input to be a string");
      if (input === "")
        return { isMatch: !1, output: "" };
      const opts = options8 || {}, format3 = opts.format || (posix ? utils2.toPosixSlashes : null);
      let match = input === glob, output = match && format3 ? format3(input) : input;
      return match === !1 && (output = format3 ? format3(input) : input, match = output === glob), (match === !1 || opts.capture === !0) && (opts.matchBase === !0 || opts.basename === !0 ? match = picomatch.matchBase(input, regex, options8, posix) : match = regex.exec(output)), { isMatch: !!match, match, output };
    }, picomatch.matchBase = (input, glob, options8, posix = utils2.isWindows(options8)) => (glob instanceof RegExp ? glob : picomatch.makeRe(glob, options8)).test(path13.basename(input)), picomatch.isMatch = (str2, patterns, options8) => picomatch(patterns, options8)(str2), picomatch.parse = (pattern, options8) => Array.isArray(pattern) ? pattern.map((p) => picomatch.parse(p, options8)) : parse6(pattern, { ...options8, fastpaths: !1 }), picomatch.scan = (input, options8) => scan(input, options8), picomatch.compileRe = (state, options8, returnOutput = !1, returnState = !1) => {
      if (returnOutput === !0)
        return state.output;
      const opts = options8 || {}, prepend = opts.contains ? "" : "^", append = opts.contains ? "" : "$";
      let source2 = `${prepend}(?:${state.output})${append}`;
      state && state.negated === !0 && (source2 = `^(?!${source2}).*$`);
      const regex = picomatch.toRegex(source2, options8);
      return returnState === !0 && (regex.state = state), regex;
    }, picomatch.makeRe = (input, options8 = {}, returnOutput = !1, returnState = !1) => {
      if (!input || typeof input != "string")
        throw new TypeError("Expected a non-empty string");
      let parsed = { negated: !1, fastpaths: !0 };
      return options8.fastpaths !== !1 && (input[0] === "." || input[0] === "*") && (parsed.output = parse6.fastpaths(input, options8)), parsed.output || (parsed = parse6(input, options8)), picomatch.compileRe(parsed, options8, returnOutput, returnState);
    }, picomatch.toRegex = (source2, options8) => {
      try {
        const opts = options8 || {};
        return new RegExp(source2, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options8 && options8.debug === !0)
          throw err;
        return /$^/;
      }
    }, picomatch.constants = constants, module2.exports = picomatch;
  }
}), require_picomatch2 = __commonJS({
  "node_modules/picomatch/index.js"(exports2, module2) {
    module2.exports = require_picomatch();
  }
}), require_micromatch = __commonJS({
  "node_modules/micromatch/index.js"(exports2, module2) {
    var util2 = __require("util"), braces = require_braces(), picomatch = require_picomatch2(), utils2 = require_utils2(), isEmptyString = (val) => val === "" || val === "./", micromatch2 = (list, patterns, options8) => {
      patterns = [].concat(patterns), list = [].concat(list);
      let omit2 = /* @__PURE__ */ new Set(), keep = /* @__PURE__ */ new Set(), items = /* @__PURE__ */ new Set(), negatives = 0, onResult = (state) => {
        items.add(state.output), options8 && options8.onResult && options8.onResult(state);
      };
      for (let i2 = 0; i2 < patterns.length; i2++) {
        let isMatch = picomatch(String(patterns[i2]), { ...options8, onResult }, !0), negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        negated && negatives++;
        for (let item of list) {
          let matched = isMatch(item, !0);
          (negated ? !matched.isMatch : matched.isMatch) && (negated ? omit2.add(matched.output) : (omit2.delete(matched.output), keep.add(matched.output)));
        }
      }
      let matches = (negatives === patterns.length ? [...items] : [...keep]).filter((item) => !omit2.has(item));
      if (options8 && matches.length === 0) {
        if (options8.failglob === !0)
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        if (options8.nonull === !0 || options8.nullglob === !0)
          return options8.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
      }
      return matches;
    };
    micromatch2.match = micromatch2, micromatch2.matcher = (pattern, options8) => picomatch(pattern, options8), micromatch2.isMatch = (str2, patterns, options8) => picomatch(patterns, options8)(str2), micromatch2.any = micromatch2.isMatch, micromatch2.not = (list, patterns, options8 = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = /* @__PURE__ */ new Set(), items = [], onResult = (state) => {
        options8.onResult && options8.onResult(state), items.push(state.output);
      }, matches = new Set(micromatch2(list, patterns, { ...options8, onResult }));
      for (let item of items)
        matches.has(item) || result.add(item);
      return [...result];
    }, micromatch2.contains = (str2, pattern, options8) => {
      if (typeof str2 != "string")
        throw new TypeError(`Expected a string: "${util2.inspect(str2)}"`);
      if (Array.isArray(pattern))
        return pattern.some((p) => micromatch2.contains(str2, p, options8));
      if (typeof pattern == "string") {
        if (isEmptyString(str2) || isEmptyString(pattern))
          return !1;
        if (str2.includes(pattern) || str2.startsWith("./") && str2.slice(2).includes(pattern))
          return !0;
      }
      return micromatch2.isMatch(str2, pattern, { ...options8, contains: !0 });
    }, micromatch2.matchKeys = (obj, patterns, options8) => {
      if (!utils2.isObject(obj))
        throw new TypeError("Expected the first argument to be an object");
      let keys = micromatch2(Object.keys(obj), patterns, options8), res = {};
      for (let key2 of keys)
        res[key2] = obj[key2];
      return res;
    }, micromatch2.some = (list, patterns, options8) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options8);
        if (items.some((item) => isMatch(item)))
          return !0;
      }
      return !1;
    }, micromatch2.every = (list, patterns, options8) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options8);
        if (!items.every((item) => isMatch(item)))
          return !1;
      }
      return !0;
    }, micromatch2.all = (str2, patterns, options8) => {
      if (typeof str2 != "string")
        throw new TypeError(`Expected a string: "${util2.inspect(str2)}"`);
      return [].concat(patterns).every((p) => picomatch(p, options8)(str2));
    }, micromatch2.capture = (glob, input, options8) => {
      let posix = utils2.isWindows(options8), match = picomatch.makeRe(String(glob), { ...options8, capture: !0 }).exec(posix ? utils2.toPosixSlashes(input) : input);
      if (match)
        return match.slice(1).map((v) => v === void 0 ? "" : v);
    }, micromatch2.makeRe = (...args) => picomatch.makeRe(...args), micromatch2.scan = (...args) => picomatch.scan(...args), micromatch2.parse = (patterns, options8) => {
      let res = [];
      for (let pattern of [].concat(patterns || []))
        for (let str2 of braces(String(pattern), options8))
          res.push(picomatch.parse(str2, options8));
      return res;
    }, micromatch2.braces = (pattern, options8) => {
      if (typeof pattern != "string")
        throw new TypeError("Expected a string");
      return options8 && options8.nobrace === !0 || !/\{.*\}/.test(pattern) ? [pattern] : braces(pattern, options8);
    }, micromatch2.braceExpand = (pattern, options8) => {
      if (typeof pattern != "string")
        throw new TypeError("Expected a string");
      return micromatch2.braces(pattern, { ...options8, expand: !0 });
    }, module2.exports = micromatch2;
  }
}), require_pattern = __commonJS({
  "node_modules/fast-glob/out/utils/pattern.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.removeDuplicateSlashes = exports2.matchAny = exports2.convertPatternsToRe = exports2.makeRe = exports2.getPatternParts = exports2.expandBraceExpansion = exports2.expandPatternsWithBraceExpansion = exports2.isAffectDepthOfReadingPattern = exports2.endsWithSlashGlobStar = exports2.hasGlobStar = exports2.getBaseDirectory = exports2.isPatternRelatedToParentDirectory = exports2.getPatternsOutsideCurrentDirectory = exports2.getPatternsInsideCurrentDirectory = exports2.getPositivePatterns = exports2.getNegativePatterns = exports2.isPositivePattern = exports2.isNegativePattern = exports2.convertToNegativePattern = exports2.convertToPositivePattern = exports2.isDynamicPattern = exports2.isStaticPattern = void 0;
    var path13 = __require("path"), globParent = require_glob_parent(), micromatch2 = require_micromatch(), GLOBSTAR = "**", ESCAPE_SYMBOL = "\\", COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/, REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/, REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/, GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/, BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./, DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;
    function isStaticPattern(pattern, options8 = {}) {
      return !isDynamicPattern(pattern, options8);
    }
    exports2.isStaticPattern = isStaticPattern;
    function isDynamicPattern(pattern, options8 = {}) {
      return pattern === "" ? !1 : !!(options8.caseSensitiveMatch === !1 || pattern.includes(ESCAPE_SYMBOL) || COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern) || options8.extglob !== !1 && GLOB_EXTENSION_SYMBOLS_RE.test(pattern) || options8.braceExpansion !== !1 && hasBraceExpansion(pattern));
    }
    exports2.isDynamicPattern = isDynamicPattern;
    function hasBraceExpansion(pattern) {
      const openingBraceIndex = pattern.indexOf("{");
      if (openingBraceIndex === -1)
        return !1;
      const closingBraceIndex = pattern.indexOf("}", openingBraceIndex + 1);
      if (closingBraceIndex === -1)
        return !1;
      const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
      return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
    }
    function convertToPositivePattern(pattern) {
      return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
    }
    exports2.convertToPositivePattern = convertToPositivePattern;
    function convertToNegativePattern(pattern) {
      return "!" + pattern;
    }
    exports2.convertToNegativePattern = convertToNegativePattern;
    function isNegativePattern(pattern) {
      return pattern.startsWith("!") && pattern[1] !== "(";
    }
    exports2.isNegativePattern = isNegativePattern;
    function isPositivePattern(pattern) {
      return !isNegativePattern(pattern);
    }
    exports2.isPositivePattern = isPositivePattern;
    function getNegativePatterns(patterns) {
      return patterns.filter(isNegativePattern);
    }
    exports2.getNegativePatterns = getNegativePatterns;
    function getPositivePatterns(patterns) {
      return patterns.filter(isPositivePattern);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getPatternsInsideCurrentDirectory(patterns) {
      return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));
    }
    exports2.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
    function getPatternsOutsideCurrentDirectory(patterns) {
      return patterns.filter(isPatternRelatedToParentDirectory);
    }
    exports2.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
    function isPatternRelatedToParentDirectory(pattern) {
      return pattern.startsWith("..") || pattern.startsWith("./..");
    }
    exports2.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
    function getBaseDirectory(pattern) {
      return globParent(pattern, { flipBackslashes: !1 });
    }
    exports2.getBaseDirectory = getBaseDirectory;
    function hasGlobStar(pattern) {
      return pattern.includes(GLOBSTAR);
    }
    exports2.hasGlobStar = hasGlobStar;
    function endsWithSlashGlobStar(pattern) {
      return pattern.endsWith("/" + GLOBSTAR);
    }
    exports2.endsWithSlashGlobStar = endsWithSlashGlobStar;
    function isAffectDepthOfReadingPattern(pattern) {
      const basename = path13.basename(pattern);
      return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
    }
    exports2.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
    function expandPatternsWithBraceExpansion(patterns) {
      return patterns.reduce((collection, pattern) => collection.concat(expandBraceExpansion(pattern)), []);
    }
    exports2.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
    function expandBraceExpansion(pattern) {
      const patterns = micromatch2.braces(pattern, { expand: !0, nodupes: !0, keepEscaping: !0 });
      return patterns.sort((a, b) => a.length - b.length), patterns.filter((pattern2) => pattern2 !== "");
    }
    exports2.expandBraceExpansion = expandBraceExpansion;
    function getPatternParts(pattern, options8) {
      let { parts } = micromatch2.scan(pattern, Object.assign(Object.assign({}, options8), { parts: !0 }));
      return parts.length === 0 && (parts = [pattern]), parts[0].startsWith("/") && (parts[0] = parts[0].slice(1), parts.unshift("")), parts;
    }
    exports2.getPatternParts = getPatternParts;
    function makeRe(pattern, options8) {
      return micromatch2.makeRe(pattern, options8);
    }
    exports2.makeRe = makeRe;
    function convertPatternsToRe(patterns, options8) {
      return patterns.map((pattern) => makeRe(pattern, options8));
    }
    exports2.convertPatternsToRe = convertPatternsToRe;
    function matchAny(entry, patternsRe) {
      return patternsRe.some((patternRe) => patternRe.test(entry));
    }
    exports2.matchAny = matchAny;
    function removeDuplicateSlashes(pattern) {
      return pattern.replace(DOUBLE_SLASH_RE, "/");
    }
    exports2.removeDuplicateSlashes = removeDuplicateSlashes;
  }
}), require_merge2 = __commonJS({
  "node_modules/merge2/index.js"(exports2, module2) {
    var Stream = __require("stream"), PassThrough = Stream.PassThrough, slice = Array.prototype.slice;
    module2.exports = merge2;
    function merge2() {
      const streamsQueue = [], args = slice.call(arguments);
      let merging = !1, options8 = args[args.length - 1];
      options8 && !Array.isArray(options8) && options8.pipe == null ? args.pop() : options8 = {};
      const doEnd = options8.end !== !1, doPipeError = options8.pipeError === !0;
      options8.objectMode == null && (options8.objectMode = !0), options8.highWaterMark == null && (options8.highWaterMark = 64 * 1024);
      const mergedStream = PassThrough(options8);
      function addStream() {
        for (let i2 = 0, len = arguments.length; i2 < len; i2++)
          streamsQueue.push(pauseStreams(arguments[i2], options8));
        return mergeStream(), this;
      }
      function mergeStream() {
        if (merging)
          return;
        merging = !0;
        let streams = streamsQueue.shift();
        if (!streams) {
          process.nextTick(endStream);
          return;
        }
        Array.isArray(streams) || (streams = [streams]);
        let pipesCount = streams.length + 1;
        function next() {
          --pipesCount > 0 || (merging = !1, mergeStream());
        }
        function pipe(stream) {
          function onend() {
            stream.removeListener("merge2UnpipeEnd", onend), stream.removeListener("end", onend), doPipeError && stream.removeListener("error", onerror), next();
          }
          function onerror(err) {
            mergedStream.emit("error", err);
          }
          if (stream._readableState.endEmitted)
            return next();
          stream.on("merge2UnpipeEnd", onend), stream.on("end", onend), doPipeError && stream.on("error", onerror), stream.pipe(mergedStream, { end: !1 }), stream.resume();
        }
        for (let i2 = 0; i2 < streams.length; i2++)
          pipe(streams[i2]);
        next();
      }
      function endStream() {
        merging = !1, mergedStream.emit("queueDrain"), doEnd && mergedStream.end();
      }
      return mergedStream.setMaxListeners(0), mergedStream.add = addStream, mergedStream.on("unpipe", function(stream) {
        stream.emit("merge2UnpipeEnd");
      }), args.length && addStream.apply(null, args), mergedStream;
    }
    function pauseStreams(streams, options8) {
      if (Array.isArray(streams))
        for (let i2 = 0, len = streams.length; i2 < len; i2++)
          streams[i2] = pauseStreams(streams[i2], options8);
      else {
        if (!streams._readableState && streams.pipe && (streams = streams.pipe(PassThrough(options8))), !streams._readableState || !streams.pause || !streams.pipe)
          throw new Error("Only readable stream can be merged.");
        streams.pause();
      }
      return streams;
    }
  }
}), require_stream = __commonJS({
  "node_modules/fast-glob/out/utils/stream.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.merge = void 0;
    var merge2 = require_merge2();
    function merge3(streams) {
      const mergedStream = merge2(streams);
      return streams.forEach((stream) => {
        stream.once("error", (error) => mergedStream.emit("error", error));
      }), mergedStream.once("close", () => propagateCloseEventToSources(streams)), mergedStream.once("end", () => propagateCloseEventToSources(streams)), mergedStream;
    }
    exports2.merge = merge3;
    function propagateCloseEventToSources(streams) {
      streams.forEach((stream) => stream.emit("close"));
    }
  }
}), require_string = __commonJS({
  "node_modules/fast-glob/out/utils/string.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.isEmpty = exports2.isString = void 0;
    function isString(input) {
      return typeof input == "string";
    }
    exports2.isString = isString;
    function isEmpty(input) {
      return input === "";
    }
    exports2.isEmpty = isEmpty;
  }
}), require_utils3 = __commonJS({
  "node_modules/fast-glob/out/utils/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.string = exports2.stream = exports2.pattern = exports2.path = exports2.fs = exports2.errno = exports2.array = void 0;
    var array2 = require_array();
    exports2.array = array2;
    var errno = require_errno();
    exports2.errno = errno;
    var fs7 = require_fs();
    exports2.fs = fs7;
    var path13 = require_path();
    exports2.path = path13;
    var pattern = require_pattern();
    exports2.pattern = pattern;
    var stream = require_stream();
    exports2.stream = stream;
    var string = require_string();
    exports2.string = string;
  }
}), require_tasks = __commonJS({
  "node_modules/fast-glob/out/managers/tasks.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.convertPatternGroupToTask = exports2.convertPatternGroupsToTasks = exports2.groupPatternsByBaseDirectory = exports2.getNegativePatternsAsPositive = exports2.getPositivePatterns = exports2.convertPatternsToTasks = exports2.generate = void 0;
    var utils2 = require_utils3();
    function generate(input, settings) {
      const patterns = processPatterns(input, settings), ignore = processPatterns(settings.ignore, settings), positivePatterns = getPositivePatterns(patterns), negativePatterns = getNegativePatternsAsPositive(patterns, ignore), staticPatterns = positivePatterns.filter((pattern) => utils2.pattern.isStaticPattern(pattern, settings)), dynamicPatterns = positivePatterns.filter((pattern) => utils2.pattern.isDynamicPattern(pattern, settings)), staticTasks = convertPatternsToTasks(
        staticPatterns,
        negativePatterns,
        /* dynamic */
        !1
      ), dynamicTasks = convertPatternsToTasks(
        dynamicPatterns,
        negativePatterns,
        /* dynamic */
        !0
      );
      return staticTasks.concat(dynamicTasks);
    }
    exports2.generate = generate;
    function processPatterns(input, settings) {
      let patterns = input;
      return settings.braceExpansion && (patterns = utils2.pattern.expandPatternsWithBraceExpansion(patterns)), settings.baseNameMatch && (patterns = patterns.map((pattern) => pattern.includes("/") ? pattern : `**/${pattern}`)), patterns.map((pattern) => utils2.pattern.removeDuplicateSlashes(pattern));
    }
    function convertPatternsToTasks(positive, negative, dynamic) {
      const tasks = [], patternsOutsideCurrentDirectory = utils2.pattern.getPatternsOutsideCurrentDirectory(positive), patternsInsideCurrentDirectory = utils2.pattern.getPatternsInsideCurrentDirectory(positive), outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory), insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
      return tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic)), "." in insideCurrentDirectoryGroup ? tasks.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic)) : tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic)), tasks;
    }
    exports2.convertPatternsToTasks = convertPatternsToTasks;
    function getPositivePatterns(patterns) {
      return utils2.pattern.getPositivePatterns(patterns);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getNegativePatternsAsPositive(patterns, ignore) {
      return utils2.pattern.getNegativePatterns(patterns).concat(ignore).map(utils2.pattern.convertToPositivePattern);
    }
    exports2.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
    function groupPatternsByBaseDirectory(patterns) {
      const group2 = {};
      return patterns.reduce((collection, pattern) => {
        const base = utils2.pattern.getBaseDirectory(pattern);
        return base in collection ? collection[base].push(pattern) : collection[base] = [pattern], collection;
      }, group2);
    }
    exports2.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
    function convertPatternGroupsToTasks(positive, negative, dynamic) {
      return Object.keys(positive).map((base) => convertPatternGroupToTask(base, positive[base], negative, dynamic));
    }
    exports2.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
    function convertPatternGroupToTask(base, positive, negative, dynamic) {
      return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils2.pattern.convertToNegativePattern))
      };
    }
    exports2.convertPatternGroupToTask = convertPatternGroupToTask;
  }
}), require_async = __commonJS({
  "node_modules/@nodelib/fs.stat/out/providers/async.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.read = void 0;
    function read3(path13, settings, callback) {
      settings.fs.lstat(path13, (lstatError, lstat) => {
        if (lstatError !== null) {
          callFailureCallback(callback, lstatError);
          return;
        }
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
          callSuccessCallback(callback, lstat);
          return;
        }
        settings.fs.stat(path13, (statError, stat) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              callFailureCallback(callback, statError);
              return;
            }
            callSuccessCallback(callback, lstat);
            return;
          }
          settings.markSymbolicLink && (stat.isSymbolicLink = () => !0), callSuccessCallback(callback, stat);
        });
      });
    }
    exports2.read = read3;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
}), require_sync = __commonJS({
  "node_modules/@nodelib/fs.stat/out/providers/sync.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.read = void 0;
    function read3(path13, settings) {
      const lstat = settings.fs.lstatSync(path13);
      if (!lstat.isSymbolicLink() || !settings.followSymbolicLink)
        return lstat;
      try {
        const stat = settings.fs.statSync(path13);
        return settings.markSymbolicLink && (stat.isSymbolicLink = () => !0), stat;
      } catch (error) {
        if (!settings.throwErrorOnBrokenSymbolicLink)
          return lstat;
        throw error;
      }
    }
    exports2.read = read3;
  }
}), require_fs2 = __commonJS({
  "node_modules/@nodelib/fs.stat/out/adapters/fs.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
    var fs7 = __require("fs");
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs7.lstat,
      stat: fs7.stat,
      lstatSync: fs7.lstatSync,
      statSync: fs7.statSync
    };
    function createFileSystemAdapter(fsMethods) {
      return fsMethods === void 0 ? exports2.FILE_SYSTEM_ADAPTER : Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  }
}), require_settings = __commonJS({
  "node_modules/@nodelib/fs.stat/out/settings.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var fs7 = require_fs2(), Settings = class {
      constructor(_options = {}) {
        this._options = _options, this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, !0), this.fs = fs7.createFileSystemAdapter(this._options.fs), this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, !1), this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, !0);
      }
      _getValue(option, value) {
        return option ?? value;
      }
    };
    exports2.default = Settings;
  }
}), require_out = __commonJS({
  "node_modules/@nodelib/fs.stat/out/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.statSync = exports2.stat = exports2.Settings = void 0;
    var async = require_async(), sync = require_sync(), settings_1 = require_settings();
    exports2.Settings = settings_1.default;
    function stat(path13, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback == "function") {
        async.read(path13, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path13, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.stat = stat;
    function statSync2(path13, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path13, settings);
    }
    exports2.statSync = statSync2;
    function getSettings(settingsOrOptions = {}) {
      return settingsOrOptions instanceof settings_1.default ? settingsOrOptions : new settings_1.default(settingsOrOptions);
    }
  }
}), require_queue_microtask = __commonJS({
  "node_modules/queue-microtask/index.js"(exports2, module2) {
    var promise;
    module2.exports = typeof queueMicrotask == "function" ? queueMicrotask.bind(typeof window < "u" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
  }
}), require_run_parallel = __commonJS({
  "node_modules/run-parallel/index.js"(exports2, module2) {
    module2.exports = runParallel;
    var queueMicrotask2 = require_queue_microtask();
    function runParallel(tasks, cb) {
      let results, pending, keys, isSync = !0;
      Array.isArray(tasks) ? (results = [], pending = tasks.length) : (keys = Object.keys(tasks), results = {}, pending = keys.length);
      function done(err) {
        function end() {
          cb && cb(err, results), cb = null;
        }
        isSync ? queueMicrotask2(end) : end();
      }
      function each(i2, err, result) {
        results[i2] = result, (--pending === 0 || err) && done(err);
      }
      pending ? keys ? keys.forEach(function(key2) {
        tasks[key2](function(err, result) {
          each(key2, err, result);
        });
      }) : tasks.forEach(function(task, i2) {
        task(function(err, result) {
          each(i2, err, result);
        });
      }) : done(null), isSync = !1;
    }
  }
}), require_constants3 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/constants.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
    if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0)
      throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
    var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10), MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10), SUPPORTED_MAJOR_VERSION = 10, SUPPORTED_MINOR_VERSION = 10, IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION, IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
  }
}), require_fs3 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/utils/fs.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name, this.isBlockDevice = stats.isBlockDevice.bind(stats), this.isCharacterDevice = stats.isCharacterDevice.bind(stats), this.isDirectory = stats.isDirectory.bind(stats), this.isFIFO = stats.isFIFO.bind(stats), this.isFile = stats.isFile.bind(stats), this.isSocket = stats.isSocket.bind(stats), this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  }
}), require_utils4 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/utils/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.fs = void 0;
    var fs7 = require_fs3();
    exports2.fs = fs7;
  }
}), require_common = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/providers/common.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.joinPathSegments = void 0;
    function joinPathSegments(a, b, separator) {
      return a.endsWith(separator) ? a + b : a + separator + b;
    }
    exports2.joinPathSegments = joinPathSegments;
  }
}), require_async2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/providers/async.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
    var fsStat = require_out(), rpl = require_run_parallel(), constants_1 = require_constants3(), utils2 = require_utils4(), common2 = require_common();
    function read3(directory, settings, callback) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        readdirWithFileTypes(directory, settings, callback);
        return;
      }
      readdir(directory, settings, callback);
    }
    exports2.read = read3;
    function readdirWithFileTypes(directory, settings, callback) {
      settings.fs.readdir(directory, { withFileTypes: !0 }, (readdirError, dirents) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const entries = dirents.map((dirent) => ({
          dirent,
          name: dirent.name,
          path: common2.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        }));
        if (!settings.followSymbolicLinks) {
          callSuccessCallback(callback, entries);
          return;
        }
        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, rplEntries);
        });
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function makeRplTaskEntry(entry, settings) {
      return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
          done(null, entry);
          return;
        }
        settings.fs.stat(entry.path, (statError, stats) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              done(statError);
              return;
            }
            done(null, entry);
            return;
          }
          entry.dirent = utils2.fs.createDirentFromStats(entry.name, stats), done(null, entry);
        });
      };
    }
    function readdir(directory, settings, callback) {
      settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const tasks = names.map((name) => {
          const path13 = common2.joinPathSegments(directory, name, settings.pathSegmentSeparator);
          return (done) => {
            fsStat.stat(path13, settings.fsStatSettings, (error, stats) => {
              if (error !== null) {
                done(error);
                return;
              }
              const entry = {
                name,
                path: path13,
                dirent: utils2.fs.createDirentFromStats(name, stats)
              };
              settings.stats && (entry.stats = stats), done(null, entry);
            });
          };
        });
        rpl(tasks, (rplError, entries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, entries);
        });
      });
    }
    exports2.readdir = readdir;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
}), require_sync2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/providers/sync.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
    var fsStat = require_out(), constants_1 = require_constants3(), utils2 = require_utils4(), common2 = require_common();
    function read3(directory, settings) {
      return !settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES ? readdirWithFileTypes(directory, settings) : readdir(directory, settings);
    }
    exports2.read = read3;
    function readdirWithFileTypes(directory, settings) {
      return settings.fs.readdirSync(directory, { withFileTypes: !0 }).map((dirent) => {
        const entry = {
          dirent,
          name: dirent.name,
          path: common2.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks)
          try {
            const stats = settings.fs.statSync(entry.path);
            entry.dirent = utils2.fs.createDirentFromStats(entry.name, stats);
          } catch (error) {
            if (settings.throwErrorOnBrokenSymbolicLink)
              throw error;
          }
        return entry;
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function readdir(directory, settings) {
      return settings.fs.readdirSync(directory).map((name) => {
        const entryPath = common2.joinPathSegments(directory, name, settings.pathSegmentSeparator), stats = fsStat.statSync(entryPath, settings.fsStatSettings), entry = {
          name,
          path: entryPath,
          dirent: utils2.fs.createDirentFromStats(name, stats)
        };
        return settings.stats && (entry.stats = stats), entry;
      });
    }
    exports2.readdir = readdir;
  }
}), require_fs4 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/adapters/fs.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
    var fs7 = __require("fs");
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs7.lstat,
      stat: fs7.stat,
      lstatSync: fs7.lstatSync,
      statSync: fs7.statSync,
      readdir: fs7.readdir,
      readdirSync: fs7.readdirSync
    };
    function createFileSystemAdapter(fsMethods) {
      return fsMethods === void 0 ? exports2.FILE_SYSTEM_ADAPTER : Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  }
}), require_settings2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/settings.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var path13 = __require("path"), fsStat = require_out(), fs7 = require_fs4(), Settings = class {
      constructor(_options = {}) {
        this._options = _options, this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, !1), this.fs = fs7.createFileSystemAdapter(this._options.fs), this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path13.sep), this.stats = this._getValue(this._options.stats, !1), this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, !0), this.fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option ?? value;
      }
    };
    exports2.default = Settings;
  }
}), require_out2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.Settings = exports2.scandirSync = exports2.scandir = void 0;
    var async = require_async2(), sync = require_sync2(), settings_1 = require_settings2();
    exports2.Settings = settings_1.default;
    function scandir(path13, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback == "function") {
        async.read(path13, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path13, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.scandir = scandir;
    function scandirSync(path13, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path13, settings);
    }
    exports2.scandirSync = scandirSync;
    function getSettings(settingsOrOptions = {}) {
      return settingsOrOptions instanceof settings_1.default ? settingsOrOptions : new settings_1.default(settingsOrOptions);
    }
  }
}), require_reusify = __commonJS({
  "node_modules/reusify/reusify.js"(exports2, module2) {
    function reusify(Constructor) {
      var head = new Constructor(), tail = head;
      function get() {
        var current = head;
        return current.next ? head = current.next : (head = new Constructor(), tail = head), current.next = null, current;
      }
      function release(obj) {
        tail.next = obj, tail = obj;
      }
      return {
        get,
        release
      };
    }
    module2.exports = reusify;
  }
}), require_queue = __commonJS({
  "node_modules/fastq/queue.js"(exports2, module2) {
    var reusify = require_reusify();
    function fastqueue(context, worker, concurrency) {
      if (typeof context == "function" && (concurrency = worker, worker = context, context = null), concurrency < 1)
        throw new Error("fastqueue concurrency must be greater than 1");
      var cache3 = reusify(Task), queueHead = null, queueTail = null, _running = 0, errorHandler = null, self = {
        push: push2,
        drain: noop2,
        saturated: noop2,
        pause,
        paused: !1,
        concurrency,
        running,
        resume,
        idle,
        length,
        getQueue,
        unshift,
        empty: noop2,
        kill,
        killAndDrain,
        error
      };
      return self;
      function running() {
        return _running;
      }
      function pause() {
        self.paused = !0;
      }
      function length() {
        for (var current = queueHead, counter = 0; current; )
          current = current.next, counter++;
        return counter;
      }
      function getQueue() {
        for (var current = queueHead, tasks = []; current; )
          tasks.push(current.value), current = current.next;
        return tasks;
      }
      function resume() {
        if (self.paused) {
          self.paused = !1;
          for (var i2 = 0; i2 < self.concurrency; i2++)
            _running++, release();
        }
      }
      function idle() {
        return _running === 0 && self.length() === 0;
      }
      function push2(value, done) {
        var current = cache3.get();
        current.context = context, current.release = release, current.value = value, current.callback = done || noop2, current.errorHandler = errorHandler, _running === self.concurrency || self.paused ? queueTail ? (queueTail.next = current, queueTail = current) : (queueHead = current, queueTail = current, self.saturated()) : (_running++, worker.call(context, current.value, current.worked));
      }
      function unshift(value, done) {
        var current = cache3.get();
        current.context = context, current.release = release, current.value = value, current.callback = done || noop2, _running === self.concurrency || self.paused ? queueHead ? (current.next = queueHead, queueHead = current) : (queueHead = current, queueTail = current, self.saturated()) : (_running++, worker.call(context, current.value, current.worked));
      }
      function release(holder) {
        holder && cache3.release(holder);
        var next = queueHead;
        next ? self.paused ? _running-- : (queueTail === queueHead && (queueTail = null), queueHead = next.next, next.next = null, worker.call(context, next.value, next.worked), queueTail === null && self.empty()) : --_running === 0 && self.drain();
      }
      function kill() {
        queueHead = null, queueTail = null, self.drain = noop2;
      }
      function killAndDrain() {
        queueHead = null, queueTail = null, self.drain(), self.drain = noop2;
      }
      function error(handler) {
        errorHandler = handler;
      }
    }
    function noop2() {
    }
    function Task() {
      this.value = null, this.callback = noop2, this.next = null, this.release = noop2, this.context = null, this.errorHandler = null;
      var self = this;
      this.worked = function(err, result) {
        var callback = self.callback, errorHandler = self.errorHandler, val = self.value;
        self.value = null, self.callback = noop2, self.errorHandler && errorHandler(err, val), callback.call(self.context, err, result), self.release(self);
      };
    }
    function queueAsPromised(context, worker, concurrency) {
      typeof context == "function" && (concurrency = worker, worker = context, context = null);
      function asyncWrapper(arg, cb) {
        worker.call(this, arg).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue = fastqueue(context, asyncWrapper, concurrency), pushCb = queue.push, unshiftCb = queue.unshift;
      return queue.push = push2, queue.unshift = unshift, queue.drained = drained, queue;
      function push2(value) {
        var p = new Promise(function(resolve3, reject) {
          pushCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve3(result);
          });
        });
        return p.catch(noop2), p;
      }
      function unshift(value) {
        var p = new Promise(function(resolve3, reject) {
          unshiftCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve3(result);
          });
        });
        return p.catch(noop2), p;
      }
      function drained() {
        if (queue.idle())
          return new Promise(function(resolve3) {
            resolve3();
          });
        var previousDrain = queue.drain, p = new Promise(function(resolve3) {
          queue.drain = function() {
            previousDrain(), resolve3();
          };
        });
        return p;
      }
    }
    module2.exports = fastqueue, module2.exports.promise = queueAsPromised;
  }
}), require_common2 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/common.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.joinPathSegments = exports2.replacePathSegmentSeparator = exports2.isAppliedFilter = exports2.isFatalError = void 0;
    function isFatalError(settings, error) {
      return settings.errorFilter === null ? !0 : !settings.errorFilter(error);
    }
    exports2.isFatalError = isFatalError;
    function isAppliedFilter(filter2, value) {
      return filter2 === null || filter2(value);
    }
    exports2.isAppliedFilter = isAppliedFilter;
    function replacePathSegmentSeparator(filepath, separator) {
      return filepath.split(/[/\\]/).join(separator);
    }
    exports2.replacePathSegmentSeparator = replacePathSegmentSeparator;
    function joinPathSegments(a, b, separator) {
      return a === "" ? b : a.endsWith(separator) ? a + b : a + separator + b;
    }
    exports2.joinPathSegments = joinPathSegments;
  }
}), require_reader = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/reader.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var common2 = require_common2(), Reader = class {
      constructor(_root, _settings) {
        this._root = _root, this._settings = _settings, this._root = common2.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
      }
    };
    exports2.default = Reader;
  }
}), require_async3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/async.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var events_1 = __require("events"), fsScandir = require_out2(), fastq = require_queue(), common2 = require_common2(), reader_1 = require_reader(), AsyncReader = class extends reader_1.default {
      constructor(_root, _settings) {
        super(_root, _settings), this._settings = _settings, this._scandir = fsScandir.scandir, this._emitter = new events_1.EventEmitter(), this._queue = fastq(this._worker.bind(this), this._settings.concurrency), this._isFatalError = !1, this._isDestroyed = !1, this._queue.drain = () => {
          this._isFatalError || this._emitter.emit("end");
        };
      }
      read() {
        return this._isFatalError = !1, this._isDestroyed = !1, setImmediate(() => {
          this._pushToQueue(this._root, this._settings.basePath);
        }), this._emitter;
      }
      get isDestroyed() {
        return this._isDestroyed;
      }
      destroy() {
        if (this._isDestroyed)
          throw new Error("The reader is already destroyed");
        this._isDestroyed = !0, this._queue.killAndDrain();
      }
      onEntry(callback) {
        this._emitter.on("entry", callback);
      }
      onError(callback) {
        this._emitter.once("error", callback);
      }
      onEnd(callback) {
        this._emitter.once("end", callback);
      }
      _pushToQueue(directory, base) {
        const queueItem = { directory, base };
        this._queue.push(queueItem, (error) => {
          error !== null && this._handleError(error);
        });
      }
      _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
          if (error !== null) {
            done(error, void 0);
            return;
          }
          for (const entry of entries)
            this._handleEntry(entry, item.base);
          done(null, void 0);
        });
      }
      _handleError(error) {
        this._isDestroyed || !common2.isFatalError(this._settings, error) || (this._isFatalError = !0, this._isDestroyed = !0, this._emitter.emit("error", error));
      }
      _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError)
          return;
        const fullpath = entry.path;
        base !== void 0 && (entry.path = common2.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator)), common2.isAppliedFilter(this._settings.entryFilter, entry) && this._emitEntry(entry), entry.dirent.isDirectory() && common2.isAppliedFilter(this._settings.deepFilter, entry) && this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
      }
      _emitEntry(entry) {
        this._emitter.emit("entry", entry);
      }
    };
    exports2.default = AsyncReader;
  }
}), require_async4 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/providers/async.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var async_1 = require_async3(), AsyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root, this._settings = _settings, this._reader = new async_1.default(this._root, this._settings), this._storage = [];
      }
      read(callback) {
        this._reader.onError((error) => {
          callFailureCallback(callback, error);
        }), this._reader.onEntry((entry) => {
          this._storage.push(entry);
        }), this._reader.onEnd(() => {
          callSuccessCallback(callback, this._storage);
        }), this._reader.read();
      }
    };
    exports2.default = AsyncProvider;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, entries) {
      callback(null, entries);
    }
  }
}), require_stream2 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/providers/stream.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var stream_1 = __require("stream"), async_1 = require_async3(), StreamProvider = class {
      constructor(_root, _settings) {
        this._root = _root, this._settings = _settings, this._reader = new async_1.default(this._root, this._settings), this._stream = new stream_1.Readable({
          objectMode: !0,
          read: () => {
          },
          destroy: () => {
            this._reader.isDestroyed || this._reader.destroy();
          }
        });
      }
      read() {
        return this._reader.onError((error) => {
          this._stream.emit("error", error);
        }), this._reader.onEntry((entry) => {
          this._stream.push(entry);
        }), this._reader.onEnd(() => {
          this._stream.push(null);
        }), this._reader.read(), this._stream;
      }
    };
    exports2.default = StreamProvider;
  }
}), require_sync3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/sync.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var fsScandir = require_out2(), common2 = require_common2(), reader_1 = require_reader(), SyncReader = class extends reader_1.default {
      constructor() {
        super(...arguments), this._scandir = fsScandir.scandirSync, this._storage = [], this._queue = /* @__PURE__ */ new Set();
      }
      read() {
        return this._pushToQueue(this._root, this._settings.basePath), this._handleQueue(), this._storage;
      }
      _pushToQueue(directory, base) {
        this._queue.add({ directory, base });
      }
      _handleQueue() {
        for (const item of this._queue.values())
          this._handleDirectory(item.directory, item.base);
      }
      _handleDirectory(directory, base) {
        try {
          const entries = this._scandir(directory, this._settings.fsScandirSettings);
          for (const entry of entries)
            this._handleEntry(entry, base);
        } catch (error) {
          this._handleError(error);
        }
      }
      _handleError(error) {
        if (common2.isFatalError(this._settings, error))
          throw error;
      }
      _handleEntry(entry, base) {
        const fullpath = entry.path;
        base !== void 0 && (entry.path = common2.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator)), common2.isAppliedFilter(this._settings.entryFilter, entry) && this._pushToStorage(entry), entry.dirent.isDirectory() && common2.isAppliedFilter(this._settings.deepFilter, entry) && this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
      }
      _pushToStorage(entry) {
        this._storage.push(entry);
      }
    };
    exports2.default = SyncReader;
  }
}), require_sync4 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/providers/sync.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var sync_1 = require_sync3(), SyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root, this._settings = _settings, this._reader = new sync_1.default(this._root, this._settings);
      }
      read() {
        return this._reader.read();
      }
    };
    exports2.default = SyncProvider;
  }
}), require_settings3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/settings.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var path13 = __require("path"), fsScandir = require_out2(), Settings = class {
      constructor(_options = {}) {
        this._options = _options, this.basePath = this._getValue(this._options.basePath, void 0), this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY), this.deepFilter = this._getValue(this._options.deepFilter, null), this.entryFilter = this._getValue(this._options.entryFilter, null), this.errorFilter = this._getValue(this._options.errorFilter, null), this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path13.sep), this.fsScandirSettings = new fsScandir.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option ?? value;
      }
    };
    exports2.default = Settings;
  }
}), require_out3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.Settings = exports2.walkStream = exports2.walkSync = exports2.walk = void 0;
    var async_1 = require_async4(), stream_1 = require_stream2(), sync_1 = require_sync4(), settings_1 = require_settings3();
    exports2.Settings = settings_1.default;
    function walk(directory, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback == "function") {
        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
        return;
      }
      new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
    }
    exports2.walk = walk;
    function walkSync(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return new sync_1.default(directory, settings).read();
    }
    exports2.walkSync = walkSync;
    function walkStream(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return new stream_1.default(directory, settings).read();
    }
    exports2.walkStream = walkStream;
    function getSettings(settingsOrOptions = {}) {
      return settingsOrOptions instanceof settings_1.default ? settingsOrOptions : new settings_1.default(settingsOrOptions);
    }
  }
}), require_reader2 = __commonJS({
  "node_modules/fast-glob/out/readers/reader.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var path13 = __require("path"), fsStat = require_out(), utils2 = require_utils3(), Reader = class {
      constructor(_settings) {
        this._settings = _settings, this._fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
      }
      _getFullEntryPath(filepath) {
        return path13.resolve(this._settings.cwd, filepath);
      }
      _makeEntry(stats, pattern) {
        const entry = {
          name: pattern,
          path: pattern,
          dirent: utils2.fs.createDirentFromStats(pattern, stats)
        };
        return this._settings.stats && (entry.stats = stats), entry;
      }
      _isFatalError(error) {
        return !utils2.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
      }
    };
    exports2.default = Reader;
  }
}), require_stream3 = __commonJS({
  "node_modules/fast-glob/out/readers/stream.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var stream_1 = __require("stream"), fsStat = require_out(), fsWalk = require_out3(), reader_1 = require_reader2(), ReaderStream = class extends reader_1.default {
      constructor() {
        super(...arguments), this._walkStream = fsWalk.walkStream, this._stat = fsStat.stat;
      }
      dynamic(root2, options8) {
        return this._walkStream(root2, options8);
      }
      static(patterns, options8) {
        const filepaths = patterns.map(this._getFullEntryPath, this), stream = new stream_1.PassThrough({ objectMode: !0 });
        stream._write = (index, _enc, done) => this._getEntry(filepaths[index], patterns[index], options8).then((entry) => {
          entry !== null && options8.entryFilter(entry) && stream.push(entry), index === filepaths.length - 1 && stream.end(), done();
        }).catch(done);
        for (let i2 = 0; i2 < filepaths.length; i2++)
          stream.write(i2);
        return stream;
      }
      _getEntry(filepath, pattern, options8) {
        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error) => {
          if (options8.errorFilter(error))
            return null;
          throw error;
        });
      }
      _getStat(filepath) {
        return new Promise((resolve3, reject) => {
          this._stat(filepath, this._fsStatSettings, (error, stats) => error === null ? resolve3(stats) : reject(error));
        });
      }
    };
    exports2.default = ReaderStream;
  }
}), require_async5 = __commonJS({
  "node_modules/fast-glob/out/readers/async.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var fsWalk = require_out3(), reader_1 = require_reader2(), stream_1 = require_stream3(), ReaderAsync = class extends reader_1.default {
      constructor() {
        super(...arguments), this._walkAsync = fsWalk.walk, this._readerStream = new stream_1.default(this._settings);
      }
      dynamic(root2, options8) {
        return new Promise((resolve3, reject) => {
          this._walkAsync(root2, options8, (error, entries) => {
            error === null ? resolve3(entries) : reject(error);
          });
        });
      }
      async static(patterns, options8) {
        const entries = [], stream = this._readerStream.static(patterns, options8);
        return new Promise((resolve3, reject) => {
          stream.once("error", reject), stream.on("data", (entry) => entries.push(entry)), stream.once("end", () => resolve3(entries));
        });
      }
    };
    exports2.default = ReaderAsync;
  }
}), require_matcher = __commonJS({
  "node_modules/fast-glob/out/providers/matchers/matcher.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var utils2 = require_utils3(), Matcher = class {
      constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns, this._settings = _settings, this._micromatchOptions = _micromatchOptions, this._storage = [], this._fillStorage();
      }
      _fillStorage() {
        for (const pattern of this._patterns) {
          const segments = this._getPatternSegments(pattern), sections = this._splitSegmentsIntoSections(segments);
          this._storage.push({
            complete: sections.length <= 1,
            pattern,
            segments,
            sections
          });
        }
      }
      _getPatternSegments(pattern) {
        return utils2.pattern.getPatternParts(pattern, this._micromatchOptions).map((part) => utils2.pattern.isDynamicPattern(part, this._settings) ? {
          dynamic: !0,
          pattern: part,
          patternRe: utils2.pattern.makeRe(part, this._micromatchOptions)
        } : {
          dynamic: !1,
          pattern: part
        });
      }
      _splitSegmentsIntoSections(segments) {
        return utils2.array.splitWhen(segments, (segment) => segment.dynamic && utils2.pattern.hasGlobStar(segment.pattern));
      }
    };
    exports2.default = Matcher;
  }
}), require_partial = __commonJS({
  "node_modules/fast-glob/out/providers/matchers/partial.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var matcher_1 = require_matcher(), PartialMatcher = class extends matcher_1.default {
      match(filepath) {
        const parts = filepath.split("/"), levels = parts.length, patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern of patterns) {
          const section = pattern.sections[0];
          if (!pattern.complete && levels > section.length || parts.every((part, index) => {
            const segment = pattern.segments[index];
            return !!(segment.dynamic && segment.patternRe.test(part) || !segment.dynamic && segment.pattern === part);
          }))
            return !0;
        }
        return !1;
      }
    };
    exports2.default = PartialMatcher;
  }
}), require_deep = __commonJS({
  "node_modules/fast-glob/out/providers/filters/deep.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var utils2 = require_utils3(), partial_1 = require_partial(), DeepFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings, this._micromatchOptions = _micromatchOptions;
      }
      getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive), negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
      }
      _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
      }
      _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils2.pattern.isAffectDepthOfReadingPattern);
        return utils2.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
      }
      _filter(basePath, entry, matcher, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry.path) || this._isSkippedSymbolicLink(entry))
          return !1;
        const filepath = utils2.path.removeLeadingDotSegment(entry.path);
        return this._isSkippedByPositivePatterns(filepath, matcher) ? !1 : this._isSkippedByNegativePatterns(filepath, negativeRe);
      }
      _isSkippedByDeep(basePath, entryPath) {
        return this._settings.deep === 1 / 0 ? !1 : this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
      }
      _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split("/").length;
        if (basePath === "")
          return entryPathDepth;
        const basePathDepth = basePath.split("/").length;
        return entryPathDepth - basePathDepth;
      }
      _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
      }
      _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
      }
      _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils2.pattern.matchAny(entryPath, patternsRe);
      }
    };
    exports2.default = DeepFilter;
  }
}), require_entry = __commonJS({
  "node_modules/fast-glob/out/providers/filters/entry.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var utils2 = require_utils3(), EntryFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings, this._micromatchOptions = _micromatchOptions, this.index = /* @__PURE__ */ new Map();
      }
      getFilter(positive, negative) {
        const positiveRe = utils2.pattern.convertPatternsToRe(positive, this._micromatchOptions), negativeRe = utils2.pattern.convertPatternsToRe(negative, Object.assign(Object.assign({}, this._micromatchOptions), { dot: !0 }));
        return (entry) => this._filter(entry, positiveRe, negativeRe);
      }
      _filter(entry, positiveRe, negativeRe) {
        const filepath = utils2.path.removeLeadingDotSegment(entry.path);
        if (this._settings.unique && this._isDuplicateEntry(filepath) || this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry) || this._isSkippedByAbsoluteNegativePatterns(filepath, negativeRe))
          return !1;
        const isDirectory2 = entry.dirent.isDirectory(), isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory2) && !this._isMatchToPatterns(filepath, negativeRe, isDirectory2);
        return this._settings.unique && isMatched && this._createIndexRecord(filepath), isMatched;
      }
      _isDuplicateEntry(filepath) {
        return this.index.has(filepath);
      }
      _createIndexRecord(filepath) {
        this.index.set(filepath, void 0);
      }
      _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
      }
      _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
      }
      _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute)
          return !1;
        const fullpath = utils2.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils2.pattern.matchAny(fullpath, patternsRe);
      }
      _isMatchToPatterns(filepath, patternsRe, isDirectory2) {
        const isMatched = utils2.pattern.matchAny(filepath, patternsRe);
        return !isMatched && isDirectory2 ? utils2.pattern.matchAny(filepath + "/", patternsRe) : isMatched;
      }
    };
    exports2.default = EntryFilter;
  }
}), require_error = __commonJS({
  "node_modules/fast-glob/out/providers/filters/error.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var utils2 = require_utils3(), ErrorFilter = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getFilter() {
        return (error) => this._isNonFatalError(error);
      }
      _isNonFatalError(error) {
        return utils2.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
      }
    };
    exports2.default = ErrorFilter;
  }
}), require_entry2 = __commonJS({
  "node_modules/fast-glob/out/providers/transformers/entry.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var utils2 = require_utils3(), EntryTransformer = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getTransformer() {
        return (entry) => this._transform(entry);
      }
      _transform(entry) {
        let filepath = entry.path;
        return this._settings.absolute && (filepath = utils2.path.makeAbsolute(this._settings.cwd, filepath), filepath = utils2.path.unixify(filepath)), this._settings.markDirectories && entry.dirent.isDirectory() && (filepath += "/"), this._settings.objectMode ? Object.assign(Object.assign({}, entry), { path: filepath }) : filepath;
      }
    };
    exports2.default = EntryTransformer;
  }
}), require_provider = __commonJS({
  "node_modules/fast-glob/out/providers/provider.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var path13 = __require("path"), deep_1 = require_deep(), entry_1 = require_entry(), error_1 = require_error(), entry_2 = require_entry2(), Provider = class {
      constructor(_settings) {
        this._settings = _settings, this.errorFilter = new error_1.default(this._settings), this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions()), this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions()), this.entryTransformer = new entry_2.default(this._settings);
      }
      _getRootDirectory(task) {
        return path13.resolve(this._settings.cwd, task.base);
      }
      _getReaderOptions(task) {
        const basePath = task.base === "." ? "" : task.base;
        return {
          basePath,
          pathSegmentSeparator: "/",
          concurrency: this._settings.concurrency,
          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
          errorFilter: this.errorFilter.getFilter(),
          followSymbolicLinks: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          stats: this._settings.stats,
          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
          transform: this.entryTransformer.getTransformer()
        };
      }
      _getMicromatchOptions() {
        return {
          dot: this._settings.dot,
          matchBase: this._settings.baseNameMatch,
          nobrace: !this._settings.braceExpansion,
          nocase: !this._settings.caseSensitiveMatch,
          noext: !this._settings.extglob,
          noglobstar: !this._settings.globstar,
          posix: !0,
          strictSlashes: !1
        };
      }
    };
    exports2.default = Provider;
  }
}), require_async6 = __commonJS({
  "node_modules/fast-glob/out/providers/async.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var async_1 = require_async5(), provider_1 = require_provider(), ProviderAsync = class extends provider_1.default {
      constructor() {
        super(...arguments), this._reader = new async_1.default(this._settings);
      }
      async read(task) {
        const root2 = this._getRootDirectory(task), options8 = this._getReaderOptions(task);
        return (await this.api(root2, task, options8)).map((entry) => options8.transform(entry));
      }
      api(root2, task, options8) {
        return task.dynamic ? this._reader.dynamic(root2, options8) : this._reader.static(task.patterns, options8);
      }
    };
    exports2.default = ProviderAsync;
  }
}), require_stream4 = __commonJS({
  "node_modules/fast-glob/out/providers/stream.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var stream_1 = __require("stream"), stream_2 = require_stream3(), provider_1 = require_provider(), ProviderStream = class extends provider_1.default {
      constructor() {
        super(...arguments), this._reader = new stream_2.default(this._settings);
      }
      read(task) {
        const root2 = this._getRootDirectory(task), options8 = this._getReaderOptions(task), source2 = this.api(root2, task, options8), destination = new stream_1.Readable({ objectMode: !0, read: () => {
        } });
        return source2.once("error", (error) => destination.emit("error", error)).on("data", (entry) => destination.emit("data", options8.transform(entry))).once("end", () => destination.emit("end")), destination.once("close", () => source2.destroy()), destination;
      }
      api(root2, task, options8) {
        return task.dynamic ? this._reader.dynamic(root2, options8) : this._reader.static(task.patterns, options8);
      }
    };
    exports2.default = ProviderStream;
  }
}), require_sync5 = __commonJS({
  "node_modules/fast-glob/out/readers/sync.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var fsStat = require_out(), fsWalk = require_out3(), reader_1 = require_reader2(), ReaderSync = class extends reader_1.default {
      constructor() {
        super(...arguments), this._walkSync = fsWalk.walkSync, this._statSync = fsStat.statSync;
      }
      dynamic(root2, options8) {
        return this._walkSync(root2, options8);
      }
      static(patterns, options8) {
        const entries = [];
        for (const pattern of patterns) {
          const filepath = this._getFullEntryPath(pattern), entry = this._getEntry(filepath, pattern, options8);
          entry === null || !options8.entryFilter(entry) || entries.push(entry);
        }
        return entries;
      }
      _getEntry(filepath, pattern, options8) {
        try {
          const stats = this._getStat(filepath);
          return this._makeEntry(stats, pattern);
        } catch (error) {
          if (options8.errorFilter(error))
            return null;
          throw error;
        }
      }
      _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
      }
    };
    exports2.default = ReaderSync;
  }
}), require_sync6 = __commonJS({
  "node_modules/fast-glob/out/providers/sync.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var sync_1 = require_sync5(), provider_1 = require_provider(), ProviderSync = class extends provider_1.default {
      constructor() {
        super(...arguments), this._reader = new sync_1.default(this._settings);
      }
      read(task) {
        const root2 = this._getRootDirectory(task), options8 = this._getReaderOptions(task);
        return this.api(root2, task, options8).map(options8.transform);
      }
      api(root2, task, options8) {
        return task.dynamic ? this._reader.dynamic(root2, options8) : this._reader.static(task.patterns, options8);
      }
    };
    exports2.default = ProviderSync;
  }
}), require_settings4 = __commonJS({
  "node_modules/fast-glob/out/settings.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: !0 }), exports2.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
    var fs7 = __require("fs"), os2 = __require("os"), CPU_COUNT = Math.max(os2.cpus().length, 1);
    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = {
      lstat: fs7.lstat,
      lstatSync: fs7.lstatSync,
      stat: fs7.stat,
      statSync: fs7.statSync,
      readdir: fs7.readdir,
      readdirSync: fs7.readdirSync
    };
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options, this.absolute = this._getValue(this._options.absolute, !1), this.baseNameMatch = this._getValue(this._options.baseNameMatch, !1), this.braceExpansion = this._getValue(this._options.braceExpansion, !0), this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, !0), this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT), this.cwd = this._getValue(this._options.cwd, process.cwd()), this.deep = this._getValue(this._options.deep, 1 / 0), this.dot = this._getValue(this._options.dot, !1), this.extglob = this._getValue(this._options.extglob, !0), this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, !0), this.fs = this._getFileSystemMethods(this._options.fs), this.globstar = this._getValue(this._options.globstar, !0), this.ignore = this._getValue(this._options.ignore, []), this.markDirectories = this._getValue(this._options.markDirectories, !1), this.objectMode = this._getValue(this._options.objectMode, !1), this.onlyDirectories = this._getValue(this._options.onlyDirectories, !1), this.onlyFiles = this._getValue(this._options.onlyFiles, !0), this.stats = this._getValue(this._options.stats, !1), this.suppressErrors = this._getValue(this._options.suppressErrors, !1), this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, !1), this.unique = this._getValue(this._options.unique, !0), this.onlyDirectories && (this.onlyFiles = !1), this.stats && (this.objectMode = !0), this.ignore = [].concat(this.ignore);
      }
      _getValue(option, value) {
        return option === void 0 ? value : option;
      }
      _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports2.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
      }
    };
    exports2.default = Settings;
  }
}), require_out4 = __commonJS({
  "node_modules/fast-glob/out/index.js"(exports2, module2) {
    var taskManager = require_tasks(), async_1 = require_async6(), stream_1 = require_stream4(), sync_1 = require_sync6(), settings_1 = require_settings4(), utils2 = require_utils3();
    async function FastGlob(source2, options8) {
      assertPatternsInput(source2);
      const works = getWorks(source2, async_1.default, options8), result = await Promise.all(works);
      return utils2.array.flatten(result);
    }
    (function(FastGlob2) {
      FastGlob2.glob = FastGlob2, FastGlob2.globSync = sync, FastGlob2.globStream = stream, FastGlob2.async = FastGlob2;
      function sync(source2, options8) {
        assertPatternsInput(source2);
        const works = getWorks(source2, sync_1.default, options8);
        return utils2.array.flatten(works);
      }
      FastGlob2.sync = sync;
      function stream(source2, options8) {
        assertPatternsInput(source2);
        const works = getWorks(source2, stream_1.default, options8);
        return utils2.stream.merge(works);
      }
      FastGlob2.stream = stream;
      function generateTasks(source2, options8) {
        assertPatternsInput(source2);
        const patterns = [].concat(source2), settings = new settings_1.default(options8);
        return taskManager.generate(patterns, settings);
      }
      FastGlob2.generateTasks = generateTasks;
      function isDynamicPattern(source2, options8) {
        assertPatternsInput(source2);
        const settings = new settings_1.default(options8);
        return utils2.pattern.isDynamicPattern(source2, settings);
      }
      FastGlob2.isDynamicPattern = isDynamicPattern;
      function escapePath(source2) {
        return assertPatternsInput(source2), utils2.path.escape(source2);
      }
      FastGlob2.escapePath = escapePath;
      function convertPathToPattern(source2) {
        return assertPatternsInput(source2), utils2.path.convertPathToPattern(source2);
      }
      FastGlob2.convertPathToPattern = convertPathToPattern, function(posix2) {
        function escapePath2(source2) {
          return assertPatternsInput(source2), utils2.path.escapePosixPath(source2);
        }
        posix2.escapePath = escapePath2;
        function convertPathToPattern2(source2) {
          return assertPatternsInput(source2), utils2.path.convertPosixPathToPattern(source2);
        }
        posix2.convertPathToPattern = convertPathToPattern2;
      }(FastGlob2.posix || (FastGlob2.posix = {})), function(win322) {
        function escapePath2(source2) {
          return assertPatternsInput(source2), utils2.path.escapeWindowsPath(source2);
        }
        win322.escapePath = escapePath2;
        function convertPathToPattern2(source2) {
          return assertPatternsInput(source2), utils2.path.convertWindowsPathToPattern(source2);
        }
        win322.convertPathToPattern = convertPathToPattern2;
      }(FastGlob2.win32 || (FastGlob2.win32 = {}));
    })(FastGlob || (FastGlob = {}));
    function getWorks(source2, _Provider, options8) {
      const patterns = [].concat(source2), settings = new settings_1.default(options8), tasks = taskManager.generate(patterns, settings), provider = new _Provider(settings);
      return tasks.map(provider.read, provider);
    }
    function assertPatternsInput(input) {
      if (![].concat(input).every((item) => utils2.string.isString(item) && !utils2.string.isEmpty(item)))
        throw new TypeError("Patterns must be a string (non empty) or an array of strings");
    }
    module2.exports = FastGlob;
  }
}), require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports2, module2) {
    var debug = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
}), require_constants4 = __commonJS({
  "node_modules/semver/internal/constants.js"(exports2, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0", MAX_LENGTH = 256, MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991, MAX_SAFE_COMPONENT_LENGTH = 16, MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6, RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
}), require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports2, module2) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants4(), debug = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [], safeRe = exports2.safeRe = [], src = exports2.src = [], t = exports2.t = {}, R = 0, LETTERDASHNUMBER = "[a-zA-Z0-9-]", safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ], makeSafeRegex = (value) => {
      for (const [token2, max] of safeRegexReplacements)
        value = value.split(`${token2}*`).join(`${token2}{0,${max}}`).split(`${token2}+`).join(`${token2}{1,${max}}`);
      return value;
    }, createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value), index = R++;
      debug(name, index, value), t[name] = index, src[index] = value, re[index] = new RegExp(value, isGlobal ? "g" : void 0), safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*"), createToken("NUMERICIDENTIFIERLOOSE", "\\d+"), createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`), createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`), createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`), createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`), createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`), createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`), createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`), createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`), createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`), createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`), createToken("FULL", `^${src[t.FULLPLAIN]}$`), createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`), createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`), createToken("GTLT", "((?:<|>)?=?)"), createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`), createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`), createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`), createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`), createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`), createToken("COERCE", `(^|[^\\d])(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`), createToken("COERCERTL", src[t.COERCE], !0), createToken("LONETILDE", "(?:~>?)"), createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, !0), exports2.tildeTrimReplace = "$1~", createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`), createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`), createToken("LONECARET", "(?:\\^)"), createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, !0), exports2.caretTrimReplace = "$1^", createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`), createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`), createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`), createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`), createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, !0), exports2.comparatorTrimReplace = "$1$2$3", createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`), createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`), createToken("STAR", "(<|>)?=?\\s*\\*"), createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
}), require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports2, module2) {
    var looseOption = Object.freeze({ loose: !0 }), emptyOpts = Object.freeze({}), parseOptions = (options8) => options8 ? typeof options8 != "object" ? looseOption : options8 : emptyOpts;
    module2.exports = parseOptions;
  }
}), require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports2, module2) {
    var numeric = /^[0-9]+$/, compareIdentifiers = (a, b) => {
      const anum = numeric.test(a), bnum = numeric.test(b);
      return anum && bnum && (a = +a, b = +b), a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }, rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
}), require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports2, module2) {
    var debug = require_debug(), { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants4(), { safeRe: re, t } = require_re(), parseOptions = require_parse_options(), { compareIdentifiers } = require_identifiers(), SemVer = class _SemVer {
      constructor(version, options8) {
        if (options8 = parseOptions(options8), version instanceof _SemVer) {
          if (version.loose === !!options8.loose && version.includePrerelease === !!options8.includePrerelease)
            return version;
          version = version.version;
        } else if (typeof version != "string")
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        if (version.length > MAX_LENGTH)
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        debug("SemVer", version, options8), this.options = options8, this.loose = !!options8.loose, this.includePrerelease = !!options8.includePrerelease;
        const m = version.trim().match(options8.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m)
          throw new TypeError(`Invalid Version: ${version}`);
        if (this.raw = version, this.major = +m[1], this.minor = +m[2], this.patch = +m[3], this.major > MAX_SAFE_INTEGER || this.major < 0)
          throw new TypeError("Invalid major version");
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
          throw new TypeError("Invalid minor version");
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
          throw new TypeError("Invalid patch version");
        m[4] ? this.prerelease = m[4].split(".").map((id) => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER)
              return num;
          }
          return id;
        }) : this.prerelease = [], this.build = m[5] ? m[5].split(".") : [], this.format();
      }
      format() {
        return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        if (debug("SemVer.compare", this.version, this.options, other), !(other instanceof _SemVer)) {
          if (typeof other == "string" && other === this.version)
            return 0;
          other = new _SemVer(other, this.options);
        }
        return other.version === this.version ? 0 : this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        return other instanceof _SemVer || (other = new _SemVer(other, this.options)), compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (other instanceof _SemVer || (other = new _SemVer(other, this.options)), this.prerelease.length && !other.prerelease.length)
          return -1;
        if (!this.prerelease.length && other.prerelease.length)
          return 1;
        if (!this.prerelease.length && !other.prerelease.length)
          return 0;
        let i2 = 0;
        do {
          const a = this.prerelease[i2], b = other.prerelease[i2];
          if (debug("prerelease compare", i2, a, b), a === void 0 && b === void 0)
            return 0;
          if (b === void 0)
            return 1;
          if (a === void 0)
            return -1;
          if (a === b)
            continue;
          return compareIdentifiers(a, b);
        } while (++i2);
      }
      compareBuild(other) {
        other instanceof _SemVer || (other = new _SemVer(other, this.options));
        let i2 = 0;
        do {
          const a = this.build[i2], b = other.build[i2];
          if (debug("prerelease compare", i2, a, b), a === void 0 && b === void 0)
            return 0;
          if (b === void 0)
            return 1;
          if (a === void 0)
            return -1;
          if (a === b)
            continue;
          return compareIdentifiers(a, b);
        } while (++i2);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0, this.inc("patch", identifier, identifierBase), this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            this.prerelease.length === 0 && this.inc("patch", identifier, identifierBase), this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
            break;
          case "minor":
            (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
            break;
          case "patch":
            this.prerelease.length === 0 && this.patch++, this.prerelease = [];
            break;
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === !1)
              throw new Error("invalid increment argument: identifier is empty");
            if (this.prerelease.length === 0)
              this.prerelease = [base];
            else {
              let i2 = this.prerelease.length;
              for (; --i2 >= 0; )
                typeof this.prerelease[i2] == "number" && (this.prerelease[i2]++, i2 = -2);
              if (i2 === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === !1)
                  throw new Error("invalid increment argument: identifier already exists");
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              identifierBase === !1 && (prerelease = [identifier]), compareIdentifiers(this.prerelease[0], identifier) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = prerelease) : this.prerelease = prerelease;
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
      }
    };
    module2.exports = SemVer;
  }
}), require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports2, module2) {
    var SemVer = require_semver(), compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
}), require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports2, module2) {
    var compare = require_compare(), gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
}), require_pseudomap = __commonJS({
  "node_modules/pseudomap/pseudomap.js"(exports2, module2) {
    var hasOwnProperty3 = Object.prototype.hasOwnProperty;
    module2.exports = PseudoMap;
    function PseudoMap(set3) {
      if (!(this instanceof PseudoMap))
        throw new TypeError("Constructor PseudoMap requires 'new'");
      if (this.clear(), set3)
        if (set3 instanceof PseudoMap || typeof Map == "function" && set3 instanceof Map)
          set3.forEach(function(value, key2) {
            this.set(key2, value);
          }, this);
        else if (Array.isArray(set3))
          set3.forEach(function(kv) {
            this.set(kv[0], kv[1]);
          }, this);
        else
          throw new TypeError("invalid argument");
    }
    PseudoMap.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this, Object.keys(this._data).forEach(function(k) {
        k !== "size" && fn.call(thisp, this._data[k].value, this._data[k].key);
      }, this);
    }, PseudoMap.prototype.has = function(k) {
      return !!find(this._data, k);
    }, PseudoMap.prototype.get = function(k) {
      var res = find(this._data, k);
      return res && res.value;
    }, PseudoMap.prototype.set = function(k, v) {
      set2(this._data, k, v);
    }, PseudoMap.prototype.delete = function(k) {
      var res = find(this._data, k);
      res && (delete this._data[res._index], this._data.size--);
    }, PseudoMap.prototype.clear = function() {
      var data = /* @__PURE__ */ Object.create(null);
      data.size = 0, Object.defineProperty(this, "_data", {
        value: data,
        enumerable: !1,
        configurable: !0,
        writable: !1
      });
    }, Object.defineProperty(PseudoMap.prototype, "size", {
      get: function() {
        return this._data.size;
      },
      set: function(n) {
      },
      enumerable: !0,
      configurable: !0
    }), PseudoMap.prototype.values = PseudoMap.prototype.keys = PseudoMap.prototype.entries = function() {
      throw new Error("iterators are not implemented in this version");
    };
    function same(a, b) {
      return a === b || a !== a && b !== b;
    }
    function Entry(k, v, i2) {
      this.key = k, this.value = v, this._index = i2;
    }
    function find(data, k) {
      for (var i2 = 0, s = "_" + k, key2 = s; hasOwnProperty3.call(data, key2); key2 = s + i2++)
        if (same(data[key2].key, k))
          return data[key2];
    }
    function set2(data, k, v) {
      for (var i2 = 0, s = "_" + k, key2 = s; hasOwnProperty3.call(data, key2); key2 = s + i2++)
        if (same(data[key2].key, k)) {
          data[key2].value = v;
          return;
        }
      data.size++, data[key2] = new Entry(k, v, key2);
    }
  }
}), require_map = __commonJS({
  "node_modules/pseudomap/map.js"(exports2, module2) {
    process.env.npm_package_name === "pseudomap" && process.env.npm_lifecycle_script === "test" && (process.env.TEST_PSEUDOMAP = "true"), typeof Map == "function" && !process.env.TEST_PSEUDOMAP ? module2.exports = Map : module2.exports = require_pseudomap();
  }
}), require_yallist = __commonJS({
  "node_modules/editorconfig/node_modules/yallist/yallist.js"(exports2, module2) {
    module2.exports = Yallist, Yallist.Node = Node, Yallist.create = Yallist;
    function Yallist(list) {
      var self = this;
      if (self instanceof Yallist || (self = new Yallist()), self.tail = null, self.head = null, self.length = 0, list && typeof list.forEach == "function")
        list.forEach(function(item) {
          self.push(item);
        });
      else if (arguments.length > 0)
        for (var i2 = 0, l = arguments.length; i2 < l; i2++)
          self.push(arguments[i2]);
      return self;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this)
        throw new Error("removing node which does not belong to this list");
      var next = node.next, prev = node.prev;
      next && (next.prev = prev), prev && (prev.next = next), node === this.head && (this.head = next), node === this.tail && (this.tail = prev), node.list.length--, node.next = null, node.prev = null, node.list = null;
    }, Yallist.prototype.unshiftNode = function(node) {
      if (node !== this.head) {
        node.list && node.list.removeNode(node);
        var head = this.head;
        node.list = this, node.next = head, head && (head.prev = node), this.head = node, this.tail || (this.tail = node), this.length++;
      }
    }, Yallist.prototype.pushNode = function(node) {
      if (node !== this.tail) {
        node.list && node.list.removeNode(node);
        var tail = this.tail;
        node.list = this, node.prev = tail, tail && (tail.next = node), this.tail = node, this.head || (this.head = node), this.length++;
      }
    }, Yallist.prototype.push = function() {
      for (var i2 = 0, l = arguments.length; i2 < l; i2++)
        push2(this, arguments[i2]);
      return this.length;
    }, Yallist.prototype.unshift = function() {
      for (var i2 = 0, l = arguments.length; i2 < l; i2++)
        unshift(this, arguments[i2]);
      return this.length;
    }, Yallist.prototype.pop = function() {
      if (this.tail) {
        var res = this.tail.value;
        return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, res;
      }
    }, Yallist.prototype.shift = function() {
      if (this.head) {
        var res = this.head.value;
        return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, res;
      }
    }, Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i2 = 0; walker !== null; i2++)
        fn.call(thisp, walker.value, i2, this), walker = walker.next;
    }, Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i2 = this.length - 1; walker !== null; i2--)
        fn.call(thisp, walker.value, i2, this), walker = walker.prev;
    }, Yallist.prototype.get = function(n) {
      for (var i2 = 0, walker = this.head; walker !== null && i2 < n; i2++)
        walker = walker.next;
      if (i2 === n && walker !== null)
        return walker.value;
    }, Yallist.prototype.getReverse = function(n) {
      for (var i2 = 0, walker = this.tail; walker !== null && i2 < n; i2++)
        walker = walker.prev;
      if (i2 === n && walker !== null)
        return walker.value;
    }, Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      for (var res = new Yallist(), walker = this.head; walker !== null; )
        res.push(fn.call(thisp, walker.value, this)), walker = walker.next;
      return res;
    }, Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var res = new Yallist(), walker = this.tail; walker !== null; )
        res.push(fn.call(thisp, walker.value, this)), walker = walker.prev;
      return res;
    }, Yallist.prototype.reduce = function(fn, initial) {
      var acc, walker = this.head;
      if (arguments.length > 1)
        acc = initial;
      else if (this.head)
        walker = this.head.next, acc = this.head.value;
      else
        throw new TypeError("Reduce of empty list with no initial value");
      for (var i2 = 0; walker !== null; i2++)
        acc = fn(acc, walker.value, i2), walker = walker.next;
      return acc;
    }, Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc, walker = this.tail;
      if (arguments.length > 1)
        acc = initial;
      else if (this.tail)
        walker = this.tail.prev, acc = this.tail.value;
      else
        throw new TypeError("Reduce of empty list with no initial value");
      for (var i2 = this.length - 1; walker !== null; i2--)
        acc = fn(acc, walker.value, i2), walker = walker.prev;
      return acc;
    }, Yallist.prototype.toArray = function() {
      for (var arr = new Array(this.length), i2 = 0, walker = this.head; walker !== null; i2++)
        arr[i2] = walker.value, walker = walker.next;
      return arr;
    }, Yallist.prototype.toArrayReverse = function() {
      for (var arr = new Array(this.length), i2 = 0, walker = this.tail; walker !== null; i2++)
        arr[i2] = walker.value, walker = walker.prev;
      return arr;
    }, Yallist.prototype.slice = function(from, to) {
      to = to || this.length, to < 0 && (to += this.length), from = from || 0, from < 0 && (from += this.length);
      var ret = new Yallist();
      if (to < from || to < 0)
        return ret;
      from < 0 && (from = 0), to > this.length && (to = this.length);
      for (var i2 = 0, walker = this.head; walker !== null && i2 < from; i2++)
        walker = walker.next;
      for (; walker !== null && i2 < to; i2++, walker = walker.next)
        ret.push(walker.value);
      return ret;
    }, Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length, to < 0 && (to += this.length), from = from || 0, from < 0 && (from += this.length);
      var ret = new Yallist();
      if (to < from || to < 0)
        return ret;
      from < 0 && (from = 0), to > this.length && (to = this.length);
      for (var i2 = this.length, walker = this.tail; walker !== null && i2 > to; i2--)
        walker = walker.prev;
      for (; walker !== null && i2 > from; i2--, walker = walker.prev)
        ret.push(walker.value);
      return ret;
    }, Yallist.prototype.reverse = function() {
      for (var head = this.head, tail = this.tail, walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next, walker.next = p;
      }
      return this.head = tail, this.tail = head, this;
    };
    function push2(self, item) {
      self.tail = new Node(item, self.tail, null, self), self.head || (self.head = self.tail), self.length++;
    }
    function unshift(self, item) {
      self.head = new Node(item, null, self.head, self), self.tail || (self.tail = self.head), self.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node))
        return new Node(value, prev, next, list);
      this.list = list, this.value = value, prev ? (prev.next = this, this.prev = prev) : this.prev = null, next ? (next.prev = this, this.next = next) : this.next = null;
    }
  }
}), require_lru_cache = __commonJS({
  "node_modules/editorconfig/node_modules/lru-cache/index.js"(exports2, module2) {
    module2.exports = LRUCache;
    var Map2 = require_map(), util2 = __require("util"), Yallist = require_yallist(), hasSymbol = typeof Symbol == "function" && process.env._nodeLRUCacheForceNoSymbol !== "1", makeSymbol;
    hasSymbol ? makeSymbol = function(key2) {
      return Symbol(key2);
    } : makeSymbol = function(key2) {
      return "_" + key2;
    };
    var MAX = makeSymbol("max"), LENGTH = makeSymbol("length"), LENGTH_CALCULATOR = makeSymbol("lengthCalculator"), ALLOW_STALE = makeSymbol("allowStale"), MAX_AGE = makeSymbol("maxAge"), DISPOSE = makeSymbol("dispose"), NO_DISPOSE_ON_SET = makeSymbol("noDisposeOnSet"), LRU_LIST = makeSymbol("lruList"), CACHE = makeSymbol("cache");
    function naiveLength() {
      return 1;
    }
    function LRUCache(options8) {
      if (!(this instanceof LRUCache))
        return new LRUCache(options8);
      typeof options8 == "number" && (options8 = { max: options8 }), options8 || (options8 = {});
      var max = this[MAX] = options8.max;
      (!max || typeof max != "number" || max <= 0) && (this[MAX] = 1 / 0);
      var lc = options8.length || naiveLength;
      typeof lc != "function" && (lc = naiveLength), this[LENGTH_CALCULATOR] = lc, this[ALLOW_STALE] = options8.stale || !1, this[MAX_AGE] = options8.maxAge || 0, this[DISPOSE] = options8.dispose, this[NO_DISPOSE_ON_SET] = options8.noDisposeOnSet || !1, this.reset();
    }
    Object.defineProperty(LRUCache.prototype, "max", {
      set: function(mL) {
        (!mL || typeof mL != "number" || mL <= 0) && (mL = 1 / 0), this[MAX] = mL, trim22(this);
      },
      get: function() {
        return this[MAX];
      },
      enumerable: !0
    }), Object.defineProperty(LRUCache.prototype, "allowStale", {
      set: function(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      },
      get: function() {
        return this[ALLOW_STALE];
      },
      enumerable: !0
    }), Object.defineProperty(LRUCache.prototype, "maxAge", {
      set: function(mA) {
        (!mA || typeof mA != "number" || mA < 0) && (mA = 0), this[MAX_AGE] = mA, trim22(this);
      },
      get: function() {
        return this[MAX_AGE];
      },
      enumerable: !0
    }), Object.defineProperty(LRUCache.prototype, "lengthCalculator", {
      set: function(lC) {
        typeof lC != "function" && (lC = naiveLength), lC !== this[LENGTH_CALCULATOR] && (this[LENGTH_CALCULATOR] = lC, this[LENGTH] = 0, this[LRU_LIST].forEach(function(hit) {
          hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key), this[LENGTH] += hit.length;
        }, this)), trim22(this);
      },
      get: function() {
        return this[LENGTH_CALCULATOR];
      },
      enumerable: !0
    }), Object.defineProperty(LRUCache.prototype, "length", {
      get: function() {
        return this[LENGTH];
      },
      enumerable: !0
    }), Object.defineProperty(LRUCache.prototype, "itemCount", {
      get: function() {
        return this[LRU_LIST].length;
      },
      enumerable: !0
    }), LRUCache.prototype.rforEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this[LRU_LIST].tail; walker !== null; ) {
        var prev = walker.prev;
        forEachStep(this, fn, walker, thisp), walker = prev;
      }
    };
    function forEachStep(self, fn, node, thisp) {
      var hit = node.value;
      isStale(self, hit) && (del(self, node), self[ALLOW_STALE] || (hit = void 0)), hit && fn.call(thisp, hit.value, hit.key, self);
    }
    LRUCache.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this[LRU_LIST].head; walker !== null; ) {
        var next = walker.next;
        forEachStep(this, fn, walker, thisp), walker = next;
      }
    }, LRUCache.prototype.keys = function() {
      return this[LRU_LIST].toArray().map(function(k) {
        return k.key;
      }, this);
    }, LRUCache.prototype.values = function() {
      return this[LRU_LIST].toArray().map(function(k) {
        return k.value;
      }, this);
    }, LRUCache.prototype.reset = function() {
      this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length && this[LRU_LIST].forEach(function(hit) {
        this[DISPOSE](hit.key, hit.value);
      }, this), this[CACHE] = new Map2(), this[LRU_LIST] = new Yallist(), this[LENGTH] = 0;
    }, LRUCache.prototype.dump = function() {
      return this[LRU_LIST].map(function(hit) {
        if (!isStale(this, hit))
          return {
            k: hit.key,
            v: hit.value,
            e: hit.now + (hit.maxAge || 0)
          };
      }, this).toArray().filter(function(h) {
        return h;
      });
    }, LRUCache.prototype.dumpLru = function() {
      return this[LRU_LIST];
    }, LRUCache.prototype.inspect = function(n, opts) {
      var str2 = "LRUCache {", extras = !1, as = this[ALLOW_STALE];
      as && (str2 += `
  allowStale: true`, extras = !0);
      var max = this[MAX];
      max && max !== 1 / 0 && (extras && (str2 += ","), str2 += `
  max: ` + util2.inspect(max, opts), extras = !0);
      var maxAge = this[MAX_AGE];
      maxAge && (extras && (str2 += ","), str2 += `
  maxAge: ` + util2.inspect(maxAge, opts), extras = !0);
      var lc = this[LENGTH_CALCULATOR];
      lc && lc !== naiveLength && (extras && (str2 += ","), str2 += `
  length: ` + util2.inspect(this[LENGTH], opts), extras = !0);
      var didFirst = !1;
      return this[LRU_LIST].forEach(function(item) {
        didFirst ? str2 += `,
  ` : (extras && (str2 += `,
`), didFirst = !0, str2 += `
  `);
        var key2 = util2.inspect(item.key).split(`
`).join(`
  `), val = { value: item.value };
        item.maxAge !== maxAge && (val.maxAge = item.maxAge), lc !== naiveLength && (val.length = item.length), isStale(this, item) && (val.stale = !0), val = util2.inspect(val, opts).split(`
`).join(`
  `), str2 += key2 + " => " + val;
      }), (didFirst || extras) && (str2 += `
`), str2 += "}", str2;
    }, LRUCache.prototype.set = function(key2, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      var now = maxAge ? Date.now() : 0, len = this[LENGTH_CALCULATOR](value, key2);
      if (this[CACHE].has(key2)) {
        if (len > this[MAX])
          return del(this, this[CACHE].get(key2)), !1;
        var node = this[CACHE].get(key2), item = node.value;
        return this[DISPOSE] && (this[NO_DISPOSE_ON_SET] || this[DISPOSE](key2, item.value)), item.now = now, item.maxAge = maxAge, item.value = value, this[LENGTH] += len - item.length, item.length = len, this.get(key2), trim22(this), !0;
      }
      var hit = new Entry(key2, value, len, now, maxAge);
      return hit.length > this[MAX] ? (this[DISPOSE] && this[DISPOSE](key2, value), !1) : (this[LENGTH] += hit.length, this[LRU_LIST].unshift(hit), this[CACHE].set(key2, this[LRU_LIST].head), trim22(this), !0);
    }, LRUCache.prototype.has = function(key2) {
      if (!this[CACHE].has(key2))
        return !1;
      var hit = this[CACHE].get(key2).value;
      return !isStale(this, hit);
    }, LRUCache.prototype.get = function(key2) {
      return get(this, key2, !0);
    }, LRUCache.prototype.peek = function(key2) {
      return get(this, key2, !1);
    }, LRUCache.prototype.pop = function() {
      var node = this[LRU_LIST].tail;
      return node ? (del(this, node), node.value) : null;
    }, LRUCache.prototype.del = function(key2) {
      del(this, this[CACHE].get(key2));
    }, LRUCache.prototype.load = function(arr) {
      this.reset();
      for (var now = Date.now(), l = arr.length - 1; l >= 0; l--) {
        var hit = arr[l], expiresAt = hit.e || 0;
        if (expiresAt === 0)
          this.set(hit.k, hit.v);
        else {
          var maxAge = expiresAt - now;
          maxAge > 0 && this.set(hit.k, hit.v, maxAge);
        }
      }
    }, LRUCache.prototype.prune = function() {
      var self = this;
      this[CACHE].forEach(function(value, key2) {
        get(self, key2, !1);
      });
    };
    function get(self, key2, doUse) {
      var node = self[CACHE].get(key2);
      if (node) {
        var hit = node.value;
        isStale(self, hit) ? (del(self, node), self[ALLOW_STALE] || (hit = void 0)) : doUse && self[LRU_LIST].unshiftNode(node), hit && (hit = hit.value);
      }
      return hit;
    }
    function isStale(self, hit) {
      if (!hit || !hit.maxAge && !self[MAX_AGE])
        return !1;
      var stale = !1, diff = Date.now() - hit.now;
      return hit.maxAge ? stale = diff > hit.maxAge : stale = self[MAX_AGE] && diff > self[MAX_AGE], stale;
    }
    function trim22(self) {
      if (self[LENGTH] > self[MAX])
        for (var walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null; ) {
          var prev = walker.prev;
          del(self, walker), walker = prev;
        }
    }
    function del(self, node) {
      if (node) {
        var hit = node.value;
        self[DISPOSE] && self[DISPOSE](hit.key, hit.value), self[LENGTH] -= hit.length, self[CACHE].delete(hit.key), self[LRU_LIST].removeNode(node);
      }
    }
    function Entry(key2, value, length, now, maxAge) {
      this.key = key2, this.value = value, this.length = length, this.now = now, this.maxAge = maxAge || 0;
    }
  }
}), require_sigmund = __commonJS({
  "node_modules/sigmund/sigmund.js"(exports2, module2) {
    module2.exports = sigmund;
    function sigmund(subject, maxSessions) {
      maxSessions = maxSessions || 10;
      var notes = [], analysis = "", RE = RegExp;
      function psychoAnalyze(subject2, session) {
        if (!(session > maxSessions) && !(typeof subject2 == "function" || typeof subject2 > "u")) {
          if (typeof subject2 != "object" || !subject2 || subject2 instanceof RE) {
            analysis += subject2;
            return;
          }
          notes.indexOf(subject2) !== -1 || session === maxSessions || (notes.push(subject2), analysis += "{", Object.keys(subject2).forEach(function(issue, _, __) {
            if (issue.charAt(0) !== "_") {
              var to = typeof subject2[issue];
              to === "function" || to === "undefined" || (analysis += issue, psychoAnalyze(subject2[issue], session + 1));
            }
          }));
        }
      }
      return psychoAnalyze(subject, 0), analysis;
    }
  }
}), require_fnmatch = __commonJS({
  "node_modules/editorconfig/src/lib/fnmatch.js"(exports2, module2) {
    var platform = typeof process == "object" ? process.platform : "win32";
    module2 ? module2.exports = minimatch : exports2.minimatch = minimatch, minimatch.Minimatch = Minimatch;
    var LRU = require_lru_cache();
    minimatch.cache = new LRU({ max: 100 });
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}, sigmund = require_sigmund(), path13 = __require("path"), qmark = "[^/]", star = qmark + "*?", twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?", reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set2, c2) {
        return set2[c2] = !0, set2;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.monkeyPatch = monkeyPatch;
    function monkeyPatch() {
      var desc = Object.getOwnPropertyDescriptor(String.prototype, "match"), orig = desc.value;
      desc.value = function(p) {
        return p instanceof Minimatch ? p.match(this) : orig.call(this, p);
      }, Object.defineProperty(String.prototype, desc);
    }
    minimatch.filter = filter2;
    function filter2(pattern, options8) {
      return options8 = options8 || {}, function(p, i2, list) {
        return minimatch(p, pattern, options8);
      };
    }
    function ext(a, b) {
      a = a || {}, b = b || {};
      var t = {};
      return Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      }), Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      }), t;
    }
    minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return minimatch;
      var orig = minimatch, m = function(p, pattern, options8) {
        return orig.minimatch(p, pattern, ext(def, options8));
      };
      return m.Minimatch = function(pattern, options8) {
        return new orig.Minimatch(pattern, ext(def, options8));
      }, m;
    }, Minimatch.defaults = function(def) {
      return !def || !Object.keys(def).length ? Minimatch : minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options8) {
      if (typeof pattern != "string")
        throw new TypeError("glob pattern string required");
      return options8 || (options8 = {}), !options8.nocomment && pattern.charAt(0) === "#" ? !1 : pattern.trim() === "" ? p === "" : new Minimatch(pattern, options8).match(p);
    }
    function Minimatch(pattern, options8) {
      if (!(this instanceof Minimatch))
        return new Minimatch(pattern, options8);
      if (typeof pattern != "string")
        throw new TypeError("glob pattern string required");
      options8 || (options8 = {}), platform === "win32" && (pattern = pattern.split("\\").join("/"));
      var cacheKey = pattern + `
` + sigmund(options8), cached = minimatch.cache.get(cacheKey);
      if (cached)
        return cached;
      minimatch.cache.set(cacheKey, this), this.options = options8, this.set = [], this.pattern = pattern, this.regexp = null, this.negate = !1, this.comment = !1, this.empty = !1, this.make();
    }
    Minimatch.prototype.make = make;
    function make() {
      if (!this._made) {
        var pattern = this.pattern, options8 = this.options;
        if (!options8.nocomment && pattern.charAt(0) === "#") {
          this.comment = !0;
          return;
        }
        if (!pattern) {
          this.empty = !0;
          return;
        }
        this.parseNegate();
        var set2 = this.globSet = this.braceExpand();
        options8.debug && console.error(this.pattern, set2), set2 = this.globParts = set2.map(function(s) {
          return s.split(slashSplit);
        }), options8.debug && console.error(this.pattern, set2), set2 = set2.map(function(s, si, set3) {
          return s.map(this.parse, this);
        }, this), options8.debug && console.error(this.pattern, set2), set2 = set2.filter(function(s) {
          return s.indexOf(!1) === -1;
        }), options8.debug && console.error(this.pattern, set2), this.set = set2;
      }
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern, negate = !1, options8 = this.options, negateOffset = 0;
      if (!options8.nonegate) {
        for (var i2 = 0, l = pattern.length; i2 < l && pattern.charAt(i2) === "!"; i2++)
          negate = !negate, negateOffset++;
        negateOffset && (this.pattern = pattern.substr(negateOffset)), this.negate = negate;
      }
    }
    minimatch.braceExpand = function(pattern, options8) {
      return new Minimatch(pattern, options8).braceExpand();
    }, Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options8) {
      if (options8 = options8 || this.options, pattern = typeof pattern > "u" ? this.pattern : pattern, typeof pattern > "u")
        throw new Error("undefined pattern");
      if (options8.nobrace || !pattern.match(/\{.*\}/))
        return [pattern];
      var escaping = !1;
      if (pattern.charAt(0) !== "{") {
        for (var prefix = null, i2 = 0, l = pattern.length; i2 < l; i2++) {
          var c2 = pattern.charAt(i2);
          if (c2 === "\\")
            escaping = !escaping;
          else if (c2 === "{" && !escaping) {
            prefix = pattern.substr(0, i2);
            break;
          }
        }
        if (prefix === null)
          return [pattern];
        var tail = braceExpand(pattern.substr(i2), options8);
        return tail.map(function(t) {
          return prefix + t;
        });
      }
      var numset = pattern.match(/^\{(-?[0-9]+)\.\.(-?[0-9]+)\}/);
      if (numset) {
        for (var suf = braceExpand(pattern.substr(numset[0].length), options8), start = +numset[1], end = +numset[2], inc = start > end ? -1 : 1, set2 = [], i2 = start; i2 != end + inc; i2 += inc)
          for (var ii = 0, ll = suf.length; ii < ll; ii++)
            set2.push(i2 + suf[ii]);
        return set2;
      }
      var i2 = 1, depth = 1, set2 = [], member = "", escaping = !1;
      function addMember() {
        set2.push(member), member = "";
      }
      FOR:
        for (i2 = 1, l = pattern.length; i2 < l; i2++) {
          var c2 = pattern.charAt(i2);
          if (escaping)
            escaping = !1, member += "\\" + c2;
          else
            switch (c2) {
              case "\\":
                escaping = !0;
                continue;
              case "{":
                depth++, member += "{";
                continue;
              case "}":
                if (depth--, depth === 0) {
                  addMember(), i2++;
                  break FOR;
                } else {
                  member += c2;
                  continue;
                }
              case ",":
                depth === 1 ? addMember() : member += c2;
                continue;
              default:
                member += c2;
                continue;
            }
        }
      if (depth !== 0)
        return braceExpand("\\" + pattern, options8);
      var suf = braceExpand(pattern.substr(i2), options8), addBraces = set2.length === 1;
      set2 = set2.map(function(p) {
        return braceExpand(p, options8);
      }), set2 = set2.reduce(function(l2, r) {
        return l2.concat(r);
      }), addBraces && (set2 = set2.map(function(s) {
        return "{" + s + "}";
      }));
      for (var ret = [], i2 = 0, l = set2.length; i2 < l; i2++)
        for (var ii = 0, ll = suf.length; ii < ll; ii++)
          ret.push(set2[i2] + suf[ii]);
      return ret;
    }
    Minimatch.prototype.parse = parse6;
    var SUBPARSE = {};
    function parse6(pattern, isSub) {
      var options8 = this.options;
      if (!options8.noglobstar && pattern === "**")
        return GLOBSTAR;
      if (pattern === "")
        return "";
      var re = "", hasMagic = !!options8.nocase, escaping = !1, patternListStack = [], plType, stateChar, inClass = !1, reClassStart = -1, classStart = -1, patternStart = pattern.charAt(0) === "." ? "" : options8.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star, hasMagic = !0;
              break;
            case "?":
              re += qmark, hasMagic = !0;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          stateChar = !1;
        }
      }
      for (var i2 = 0, len = pattern.length, c2; i2 < len && (c2 = pattern.charAt(i2)); i2++) {
        if (options8.debug && console.error("%s	%s %s %j", pattern, i2, re, c2), escaping && reSpecials[c2]) {
          re += "\\" + c2, escaping = !1;
          continue;
        }
        switch (c2) {
          case "/":
            return !1;
          case "\\":
            clearStateChar(), escaping = !0;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            if (options8.debug && console.error("%s	%s %s %j <-- stateChar", pattern, i2, re, c2), inClass) {
              c2 === "!" && i2 === classStart + 1 && (c2 = "^"), re += c2;
              continue;
            }
            clearStateChar(), stateChar = c2, options8.noext && clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            plType = stateChar, patternListStack.push({
              type: plType,
              start: i2 - 1,
              reStart: re.length
            }), re += stateChar === "!" ? "(?:(?!" : "(?:", stateChar = !1;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            switch (hasMagic = !0, re += ")", plType = patternListStack.pop().type, plType) {
              case "!":
                re += "[^/]*?)";
                break;
              case "?":
              case "+":
              case "*":
                re += plType;
            }
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|", escaping = !1;
              continue;
            }
            re += "|";
            continue;
          case "[":
            if (clearStateChar(), inClass) {
              re += "\\" + c2;
              continue;
            }
            inClass = !0, classStart = i2, reClassStart = re.length, re += c2;
            continue;
          case "]":
            if (i2 === classStart + 1 || !inClass) {
              re += "\\" + c2, escaping = !1;
              continue;
            }
            hasMagic = !0, inClass = !1, re += c2;
            continue;
          default:
            clearStateChar(), escaping ? escaping = !1 : reSpecials[c2] && !(c2 === "^" && inClass) && (re += "\\"), re += c2;
        }
      }
      if (inClass) {
        var cs = pattern.substr(classStart + 1), sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0], hasMagic = hasMagic || sp[1];
      }
      for (var pl; pl = patternListStack.pop(); ) {
        var tail = re.slice(pl.reStart + 3);
        tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function(_, $1, $2) {
          return $2 || ($2 = "\\"), $1 + $1 + $2 + "|";
        });
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = !0, re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar(), escaping && (re += "\\\\");
      var addPatternStart = !1;
      switch (re.charAt(0)) {
        case ".":
        case "[":
        case "(":
          addPatternStart = !0;
      }
      if (re !== "" && hasMagic && (re = "(?=.)" + re), addPatternStart && (re = patternStart + re), isSub === SUBPARSE)
        return [re, hasMagic];
      if (!hasMagic)
        return globUnescape(pattern);
      var flags = options8.nocase ? "i" : "", regExp = new RegExp("^" + re + "$", flags);
      return regExp._glob = pattern, regExp._src = re, regExp;
    }
    minimatch.makeRe = function(pattern, options8) {
      return new Minimatch(pattern, options8 || {}).makeRe();
    }, Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === !1)
        return this.regexp;
      var set2 = this.set;
      if (!set2.length)
        return this.regexp = !1;
      var options8 = this.options, twoStar = options8.noglobstar ? star : options8.dot ? twoStarDot : twoStarNoDot, flags = options8.nocase ? "i" : "", re = set2.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p == "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$", this.negate && (re = "^(?!" + re + ").*$");
      try {
        return this.regexp = new RegExp(re, flags);
      } catch {
        return this.regexp = !1;
      }
    }
    minimatch.match = function(list, pattern, options8) {
      var mm = new Minimatch(pattern, options8);
      return list = list.filter(function(f) {
        return mm.match(f);
      }), options8.nonull && !list.length && list.push(pattern), list;
    }, Minimatch.prototype.match = match;
    function match(f, partial) {
      if (this.comment)
        return !1;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return !0;
      var options8 = this.options;
      platform === "win32" && (f = f.split("\\").join("/")), f = f.split(slashSplit), options8.debug && console.error(this.pattern, "split", f);
      for (var set2 = this.set, i2 = 0, l = set2.length; i2 < l; i2++) {
        var pattern = set2[i2], hit = this.matchOne(f, pattern, partial);
        if (hit)
          return options8.flipNegate ? !0 : !this.negate;
      }
      return options8.flipNegate ? !1 : this.negate;
    }
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options8 = this.options;
      options8.debug && console.error(
        "matchOne",
        {
          this: this,
          file,
          pattern
        }
      ), options8.matchBase && pattern.length === 1 && (file = path13.basename(file.join("/")).split("/")), options8.debug && console.error("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        options8.debug && console.error("matchOne loop");
        var p = pattern[pi], f = file[fi];
        if (options8.debug && console.error(pattern, p, f), p === !1)
          return !1;
        if (p === GLOBSTAR) {
          options8.debug && console.error("GLOBSTAR", [pattern, p, f]);
          var fr = fi, pr = pi + 1;
          if (pr === pl) {
            for (options8.debug && console.error("** at the end"); fi < fl; fi++)
              if (file[fi] === "." || file[fi] === ".." || !options8.dot && file[fi].charAt(0) === ".")
                return !1;
            return !0;
          }
          WHILE:
            for (; fr < fl; ) {
              var swallowee = file[fr];
              if (options8.debug && console.error(
                `
globstar while`,
                file,
                fr,
                pattern,
                pr,
                swallowee
              ), this.matchOne(file.slice(fr), pattern.slice(pr), partial))
                return options8.debug && console.error("globstar found match!", fr, fl, swallowee), !0;
              if (swallowee === "." || swallowee === ".." || !options8.dot && swallowee.charAt(0) === ".") {
                options8.debug && console.error("dot detected!", file, fr, pattern, pr);
                break WHILE;
              }
              options8.debug && console.error("globstar swallow a segment, and continue"), fr++;
            }
          return !!(partial && fr === fl);
        }
        var hit;
        if (typeof p == "string" ? (options8.nocase ? hit = f.toLowerCase() === p.toLowerCase() : hit = f === p, options8.debug && console.error("string match", p, f, hit)) : (hit = f.match(p), options8.debug && console.error("pattern match", p, f, hit)), !hit)
          return !1;
      }
      if (fi === fl && pi === pl)
        return !0;
      if (fi === fl)
        return partial;
      if (pi === pl) {
        var emptyFileEnd = fi === fl - 1 && file[fi] === "";
        return emptyFileEnd;
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
}), require_ini = __commonJS({
  "node_modules/editorconfig/src/lib/ini.js"(exports2) {
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve3, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve3(result.value) : new P(function(resolve4) {
            resolve4(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [op[0] & 2, t.value]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, { value: op[1], done: !1 };
              case 5:
                _.label++, y = op[1], op = [0];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: !0 };
      }
    }, __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null)
        for (var k in mod)
          Object.hasOwnProperty.call(mod, k) && (result[k] = mod[k]);
      return result.default = mod, result;
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var fs7 = __importStar(__require("fs")), regex = {
      section: /^\s*\[(([^#;]|\\#|\\;)+)\]\s*([#;].*)?$/,
      param: /^\s*([\w\.\-\_]+)\s*[=:]\s*(.*?)\s*([#;].*)?$/,
      comment: /^\s*[#;].*$/
    };
    function parse6(file) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          return [2, new Promise(function(resolve3, reject) {
            fs7.readFile(file, "utf8", function(err, data) {
              if (err) {
                reject(err);
                return;
              }
              resolve3(parseString(data));
            });
          })];
        });
      });
    }
    exports2.parse = parse6;
    function parseSync(file) {
      return parseString(fs7.readFileSync(file, "utf8"));
    }
    exports2.parseSync = parseSync;
    function parseString(data) {
      var sectionBody = {}, sectionName = null, value = [[sectionName, sectionBody]], lines = data.split(/\r\n|\r|\n/);
      return lines.forEach(function(line3) {
        var match;
        regex.comment.test(line3) || (regex.param.test(line3) ? (match = line3.match(regex.param), sectionBody[match[1]] = match[2]) : regex.section.test(line3) && (match = line3.match(regex.section), sectionName = match[1], sectionBody = {}, value.push([sectionName, sectionBody])));
      }), value;
    }
    exports2.parseString = parseString;
  }
}), require_package = __commonJS({
  "node_modules/editorconfig/package.json"(exports2, module2) {
    module2.exports = {
      name: "editorconfig",
      version: "0.15.3",
      description: "EditorConfig File Locator and Interpreter for Node.js",
      keywords: [
        "editorconfig",
        "core"
      ],
      main: "src/index.js",
      contributors: [
        "Hong Xu (topbug.net)",
        "Jed Mao (https://github.com/jedmao/)",
        "Trey Hunner (http://treyhunner.com)"
      ],
      directories: {
        bin: "./bin",
        lib: "./lib"
      },
      scripts: {
        clean: "rimraf dist",
        prebuild: "npm run clean",
        build: "tsc",
        pretest: "npm run lint && npm run build && npm run copy && cmake .",
        test: "ctest .",
        "pretest:ci": "npm run pretest",
        "test:ci": "ctest -VV --output-on-failure .",
        lint: "npm run eclint && npm run tslint",
        eclint: 'eclint check --indent_size ignore "src/**"',
        tslint: "tslint --project tsconfig.json --exclude package.json",
        copy: "cpy .npmignore LICENSE README.md CHANGELOG.md dist && cpy bin/* dist/bin && cpy src/lib/fnmatch*.* dist/src/lib",
        prepub: "npm run lint && npm run build && npm run copy",
        pub: "npm publish ./dist"
      },
      repository: {
        type: "git",
        url: "git://github.com/editorconfig/editorconfig-core-js.git"
      },
      bugs: "https://github.com/editorconfig/editorconfig-core-js/issues",
      author: "EditorConfig Team",
      license: "MIT",
      dependencies: {
        commander: "^2.19.0",
        "lru-cache": "^4.1.5",
        semver: "^5.6.0",
        sigmund: "^1.0.1"
      },
      devDependencies: {
        "@types/mocha": "^5.2.6",
        "@types/node": "^10.12.29",
        "@types/semver": "^5.5.0",
        "cpy-cli": "^2.0.0",
        eclint: "^2.8.1",
        mocha: "^5.2.0",
        rimraf: "^2.6.3",
        should: "^13.2.3",
        tslint: "^5.13.1",
        typescript: "^3.3.3333"
      }
    };
  }
}), require_src = __commonJS({
  "node_modules/editorconfig/src/index.js"(exports2) {
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve3, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve3(result.value) : new P(function(resolve4) {
            resolve4(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        for (; _; )
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            switch (y = 0, t && (op = [op[0] & 2, t.value]), op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _.label++, { value: op[1], done: !1 };
              case 5:
                _.label++, y = op[1], op = [0];
                continue;
              case 7:
                op = _.ops.pop(), _.trys.pop();
                continue;
              default:
                if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1], t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2], _.ops.push(op);
                  break;
                }
                t[2] && _.ops.pop(), _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: !0 };
      }
    }, __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null)
        for (var k in mod)
          Object.hasOwnProperty.call(mod, k) && (result[k] = mod[k]);
      return result.default = mod, result;
    }, __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var fs7 = __importStar(__require("fs")), path13 = __importStar(__require("path")), semver = {
      gte: require_gte()
    }, fnmatch_1 = __importDefault(require_fnmatch()), ini_1 = require_ini();
    exports2.parseString = ini_1.parseString;
    var package_json_1 = __importDefault(require_package()), knownProps = {
      end_of_line: !0,
      indent_style: !0,
      indent_size: !0,
      insert_final_newline: !0,
      trim_trailing_whitespace: !0,
      charset: !0
    };
    function fnmatch(filepath, glob) {
      var matchOptions = { matchBase: !0, dot: !0, noext: !0 };
      return glob = glob.replace(/\*\*/g, "{*,**/**/**}"), fnmatch_1.default(filepath, glob, matchOptions);
    }
    function getConfigFileNames(filepath, options8) {
      var paths = [];
      do
        filepath = path13.dirname(filepath), paths.push(path13.join(filepath, options8.config));
      while (filepath !== options8.root);
      return paths;
    }
    function processMatches(matches, version) {
      return "indent_style" in matches && matches.indent_style === "tab" && !("indent_size" in matches) && semver.gte(version, "0.10.0") && (matches.indent_size = "tab"), "indent_size" in matches && !("tab_width" in matches) && matches.indent_size !== "tab" && (matches.tab_width = matches.indent_size), "indent_size" in matches && "tab_width" in matches && matches.indent_size === "tab" && (matches.indent_size = matches.tab_width), matches;
    }
    function processOptions(options8, filepath) {
      return options8 === void 0 && (options8 = {}), {
        config: options8.config || ".editorconfig",
        version: options8.version || package_json_1.default.version,
        root: path13.resolve(options8.root || path13.parse(filepath).root)
      };
    }
    function buildFullGlob(pathPrefix, glob) {
      switch (glob.indexOf("/")) {
        case -1:
          glob = "**/" + glob;
          break;
        case 0:
          glob = glob.substring(1);
          break;
      }
      return path13.join(pathPrefix, glob);
    }
    function extendProps(props, options8) {
      props === void 0 && (props = {}), options8 === void 0 && (options8 = {});
      for (var key2 in options8)
        if (options8.hasOwnProperty(key2)) {
          var value = options8[key2], key22 = key2.toLowerCase(), value2 = value;
          knownProps[key22] && (value2 = value.toLowerCase());
          try {
            value2 = JSON.parse(value);
          } catch {
          }
          (typeof value > "u" || value === null) && (value2 = String(value)), props[key22] = value2;
        }
      return props;
    }
    function parseFromConfigs(configs, filepath, options8) {
      return processMatches(configs.reverse().reduce(function(matches, file) {
        var pathPrefix = path13.dirname(file.name);
        return file.contents.forEach(function(section) {
          var glob = section[0], options22 = section[1];
          if (glob) {
            var fullGlob = buildFullGlob(pathPrefix, glob);
            fnmatch(filepath, fullGlob) && (matches = extendProps(matches, options22));
          }
        }), matches;
      }, {}), options8.version);
    }
    function getConfigsForFiles(files) {
      var configs = [];
      for (var i2 in files)
        if (files.hasOwnProperty(i2)) {
          var file = files[i2], contents = ini_1.parseString(file.contents);
          if (configs.push({
            name: file.name,
            contents
          }), (contents[0][1].root || "").toLowerCase() === "true")
            break;
        }
      return configs;
    }
    function readConfigFiles(filepaths) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          return [2, Promise.all(filepaths.map(function(name) {
            return new Promise(function(resolve3) {
              fs7.readFile(name, "utf8", function(err, data) {
                resolve3({
                  name,
                  contents: err ? "" : data
                });
              });
            });
          }))];
        });
      });
    }
    function readConfigFilesSync(filepaths) {
      var files = [], file;
      return filepaths.forEach(function(filepath) {
        try {
          file = fs7.readFileSync(filepath, "utf8");
        } catch {
          file = "";
        }
        files.push({
          name: filepath,
          contents: file
        });
      }), files;
    }
    function opts(filepath, options8) {
      options8 === void 0 && (options8 = {});
      var resolvedFilePath = path13.resolve(filepath);
      return [
        resolvedFilePath,
        processOptions(options8, resolvedFilePath)
      ];
    }
    function parseFromFiles(filepath, files, options8) {
      return options8 === void 0 && (options8 = {}), __awaiter(this, void 0, void 0, function() {
        var _a, resolvedFilePath, processedOptions;
        return __generator(this, function(_b) {
          return _a = opts(filepath, options8), resolvedFilePath = _a[0], processedOptions = _a[1], [2, files.then(getConfigsForFiles).then(function(configs) {
            return parseFromConfigs(configs, resolvedFilePath, processedOptions);
          })];
        });
      });
    }
    exports2.parseFromFiles = parseFromFiles;
    function parseFromFilesSync(filepath, files, options8) {
      options8 === void 0 && (options8 = {});
      var _a = opts(filepath, options8), resolvedFilePath = _a[0], processedOptions = _a[1];
      return parseFromConfigs(getConfigsForFiles(files), resolvedFilePath, processedOptions);
    }
    exports2.parseFromFilesSync = parseFromFilesSync;
    function parse6(_filepath, _options) {
      return _options === void 0 && (_options = {}), __awaiter(this, void 0, void 0, function() {
        var _a, resolvedFilePath, processedOptions, filepaths;
        return __generator(this, function(_b) {
          return _a = opts(_filepath, _options), resolvedFilePath = _a[0], processedOptions = _a[1], filepaths = getConfigFileNames(resolvedFilePath, processedOptions), [2, readConfigFiles(filepaths).then(getConfigsForFiles).then(function(configs) {
            return parseFromConfigs(configs, resolvedFilePath, processedOptions);
          })];
        });
      });
    }
    exports2.parse = parse6;
    function parseSync(_filepath, _options) {
      _options === void 0 && (_options = {});
      var _a = opts(_filepath, _options), resolvedFilePath = _a[0], processedOptions = _a[1], filepaths = getConfigFileNames(resolvedFilePath, processedOptions), files = readConfigFilesSync(filepaths);
      return parseFromConfigs(getConfigsForFiles(files), resolvedFilePath, processedOptions);
    }
    exports2.parseSync = parseSync;
  }
}), require_vendors = __commonJS({
  "node_modules/ci-info/vendors.json"(exports2, module2) {
    module2.exports = [
      {
        name: "Agola CI",
        constant: "AGOLA",
        env: "AGOLA_GIT_REF",
        pr: "AGOLA_PULL_REQUEST_ID"
      },
      {
        name: "Appcircle",
        constant: "APPCIRCLE",
        env: "AC_APPCIRCLE"
      },
      {
        name: "AppVeyor",
        constant: "APPVEYOR",
        env: "APPVEYOR",
        pr: "APPVEYOR_PULL_REQUEST_NUMBER"
      },
      {
        name: "AWS CodeBuild",
        constant: "CODEBUILD",
        env: "CODEBUILD_BUILD_ARN"
      },
      {
        name: "Azure Pipelines",
        constant: "AZURE_PIPELINES",
        env: "TF_BUILD",
        pr: {
          BUILD_REASON: "PullRequest"
        }
      },
      {
        name: "Bamboo",
        constant: "BAMBOO",
        env: "bamboo_planKey"
      },
      {
        name: "Bitbucket Pipelines",
        constant: "BITBUCKET",
        env: "BITBUCKET_COMMIT",
        pr: "BITBUCKET_PR_ID"
      },
      {
        name: "Bitrise",
        constant: "BITRISE",
        env: "BITRISE_IO",
        pr: "BITRISE_PULL_REQUEST"
      },
      {
        name: "Buddy",
        constant: "BUDDY",
        env: "BUDDY_WORKSPACE_ID",
        pr: "BUDDY_EXECUTION_PULL_REQUEST_ID"
      },
      {
        name: "Buildkite",
        constant: "BUILDKITE",
        env: "BUILDKITE",
        pr: {
          env: "BUILDKITE_PULL_REQUEST",
          ne: "false"
        }
      },
      {
        name: "CircleCI",
        constant: "CIRCLE",
        env: "CIRCLECI",
        pr: "CIRCLE_PULL_REQUEST"
      },
      {
        name: "Cirrus CI",
        constant: "CIRRUS",
        env: "CIRRUS_CI",
        pr: "CIRRUS_PR"
      },
      {
        name: "Codefresh",
        constant: "CODEFRESH",
        env: "CF_BUILD_ID",
        pr: {
          any: [
            "CF_PULL_REQUEST_NUMBER",
            "CF_PULL_REQUEST_ID"
          ]
        }
      },
      {
        name: "Codemagic",
        constant: "CODEMAGIC",
        env: "CM_BUILD_ID",
        pr: "CM_PULL_REQUEST"
      },
      {
        name: "Codeship",
        constant: "CODESHIP",
        env: {
          CI_NAME: "codeship"
        }
      },
      {
        name: "Drone",
        constant: "DRONE",
        env: "DRONE",
        pr: {
          DRONE_BUILD_EVENT: "pull_request"
        }
      },
      {
        name: "dsari",
        constant: "DSARI",
        env: "DSARI"
      },
      {
        name: "Earthly",
        constant: "EARTHLY",
        env: "EARTHLY_CI"
      },
      {
        name: "Expo Application Services",
        constant: "EAS",
        env: "EAS_BUILD"
      },
      {
        name: "Gerrit",
        constant: "GERRIT",
        env: "GERRIT_PROJECT"
      },
      {
        name: "Gitea Actions",
        constant: "GITEA_ACTIONS",
        env: "GITEA_ACTIONS"
      },
      {
        name: "GitHub Actions",
        constant: "GITHUB_ACTIONS",
        env: "GITHUB_ACTIONS",
        pr: {
          GITHUB_EVENT_NAME: "pull_request"
        }
      },
      {
        name: "GitLab CI",
        constant: "GITLAB",
        env: "GITLAB_CI",
        pr: "CI_MERGE_REQUEST_ID"
      },
      {
        name: "GoCD",
        constant: "GOCD",
        env: "GO_PIPELINE_LABEL"
      },
      {
        name: "Google Cloud Build",
        constant: "GOOGLE_CLOUD_BUILD",
        env: "BUILDER_OUTPUT"
      },
      {
        name: "Harness CI",
        constant: "HARNESS",
        env: "HARNESS_BUILD_ID"
      },
      {
        name: "Heroku",
        constant: "HEROKU",
        env: {
          env: "NODE",
          includes: "/app/.heroku/node/bin/node"
        }
      },
      {
        name: "Hudson",
        constant: "HUDSON",
        env: "HUDSON_URL"
      },
      {
        name: "Jenkins",
        constant: "JENKINS",
        env: [
          "JENKINS_URL",
          "BUILD_ID"
        ],
        pr: {
          any: [
            "ghprbPullId",
            "CHANGE_ID"
          ]
        }
      },
      {
        name: "LayerCI",
        constant: "LAYERCI",
        env: "LAYERCI",
        pr: "LAYERCI_PULL_REQUEST"
      },
      {
        name: "Magnum CI",
        constant: "MAGNUM",
        env: "MAGNUM"
      },
      {
        name: "Netlify CI",
        constant: "NETLIFY",
        env: "NETLIFY",
        pr: {
          env: "PULL_REQUEST",
          ne: "false"
        }
      },
      {
        name: "Nevercode",
        constant: "NEVERCODE",
        env: "NEVERCODE",
        pr: {
          env: "NEVERCODE_PULL_REQUEST",
          ne: "false"
        }
      },
      {
        name: "Prow",
        constant: "PROW",
        env: "PROW_JOB_ID"
      },
      {
        name: "ReleaseHub",
        constant: "RELEASEHUB",
        env: "RELEASE_BUILD_ID"
      },
      {
        name: "Render",
        constant: "RENDER",
        env: "RENDER",
        pr: {
          IS_PULL_REQUEST: "true"
        }
      },
      {
        name: "Sail CI",
        constant: "SAIL",
        env: "SAILCI",
        pr: "SAIL_PULL_REQUEST_NUMBER"
      },
      {
        name: "Screwdriver",
        constant: "SCREWDRIVER",
        env: "SCREWDRIVER",
        pr: {
          env: "SD_PULL_REQUEST",
          ne: "false"
        }
      },
      {
        name: "Semaphore",
        constant: "SEMAPHORE",
        env: "SEMAPHORE",
        pr: "PULL_REQUEST_NUMBER"
      },
      {
        name: "Sourcehut",
        constant: "SOURCEHUT",
        env: {
          CI_NAME: "sourcehut"
        }
      },
      {
        name: "Strider CD",
        constant: "STRIDER",
        env: "STRIDER"
      },
      {
        name: "TaskCluster",
        constant: "TASKCLUSTER",
        env: [
          "TASK_ID",
          "RUN_ID"
        ]
      },
      {
        name: "TeamCity",
        constant: "TEAMCITY",
        env: "TEAMCITY_VERSION"
      },
      {
        name: "Travis CI",
        constant: "TRAVIS",
        env: "TRAVIS",
        pr: {
          env: "TRAVIS_PULL_REQUEST",
          ne: "false"
        }
      },
      {
        name: "Vela",
        constant: "VELA",
        env: "VELA",
        pr: {
          VELA_PULL_REQUEST: "1"
        }
      },
      {
        name: "Vercel",
        constant: "VERCEL",
        env: {
          any: [
            "NOW_BUILDER",
            "VERCEL"
          ]
        },
        pr: "VERCEL_GIT_PULL_REQUEST_ID"
      },
      {
        name: "Visual Studio App Center",
        constant: "APPCENTER",
        env: "APPCENTER_BUILD_ID"
      },
      {
        name: "Woodpecker",
        constant: "WOODPECKER",
        env: {
          CI: "woodpecker"
        },
        pr: {
          CI_BUILD_EVENT: "pull_request"
        }
      },
      {
        name: "Xcode Cloud",
        constant: "XCODE_CLOUD",
        env: "CI_XCODE_PROJECT",
        pr: "CI_PULL_REQUEST_NUMBER"
      },
      {
        name: "Xcode Server",
        constant: "XCODE_SERVER",
        env: "XCS"
      }
    ];
  }
}), require_ci_info = __commonJS({
  "node_modules/ci-info/index.js"(exports2) {
    var vendors = require_vendors(), env2 = process.env;
    Object.defineProperty(exports2, "_vendors", {
      value: vendors.map(function(v) {
        return v.constant;
      })
    }), exports2.name = null, exports2.isPR = null, vendors.forEach(function(vendor) {
      const isCI2 = (Array.isArray(vendor.env) ? vendor.env : [vendor.env]).every(function(obj) {
        return checkEnv(obj);
      });
      if (exports2[vendor.constant] = isCI2, !!isCI2)
        switch (exports2.name = vendor.name, typeof vendor.pr) {
          case "string":
            exports2.isPR = !!env2[vendor.pr];
            break;
          case "object":
            "env" in vendor.pr ? exports2.isPR = vendor.pr.env in env2 && env2[vendor.pr.env] !== vendor.pr.ne : "any" in vendor.pr ? exports2.isPR = vendor.pr.any.some(function(key2) {
              return !!env2[key2];
            }) : exports2.isPR = checkEnv(vendor.pr);
            break;
          default:
            exports2.isPR = null;
        }
    }), exports2.isCI = !!(env2.CI !== "false" && // Bypass all checks if CI env is explicitly set to 'false'
    (env2.BUILD_ID || // Jenkins, Cloudbees
    env2.BUILD_NUMBER || // Jenkins, TeamCity
    env2.CI || // Travis CI, CircleCI, Cirrus CI, Gitlab CI, Appveyor, CodeShip, dsari
    env2.CI_APP_ID || // Appflow
    env2.CI_BUILD_ID || // Appflow
    env2.CI_BUILD_NUMBER || // Appflow
    env2.CI_NAME || // Codeship and others
    env2.CONTINUOUS_INTEGRATION || // Travis CI, Cirrus CI
    env2.RUN_ID || // TaskCluster, dsari
    exports2.name));
    function checkEnv(obj) {
      return typeof obj == "string" ? !!env2[obj] : "env" in obj ? env2[obj.env] && env2[obj.env].includes(obj.includes) : "any" in obj ? obj.any.some(function(k) {
        return !!env2[k];
      }) : Object.keys(obj).every(function(k) {
        return env2[k] === obj[k];
      });
    }
  }
}), require_parser = __commonJS({
  "node_modules/@iarna/toml/lib/parser.js"(exports2, module2) {
    var ParserEND = 1114112, ParserError = class _ParserError extends Error {
      /* istanbul ignore next */
      constructor(msg, filename, linenumber) {
        super("[ParserError] " + msg, filename, linenumber), this.name = "ParserError", this.code = "ParserError", Error.captureStackTrace && Error.captureStackTrace(this, _ParserError);
      }
    }, State = class {
      constructor(parser) {
        this.parser = parser, this.buf = "", this.returned = null, this.result = null, this.resultTable = null, this.resultArr = null;
      }
    }, Parser = class {
      constructor() {
        this.pos = 0, this.col = 0, this.line = 0, this.obj = {}, this.ctx = this.obj, this.stack = [], this._buf = "", this.char = null, this.ii = 0, this.state = new State(this.parseStart);
      }
      parse(str2) {
        if (str2.length === 0 || str2.length == null)
          return;
        this._buf = String(str2), this.ii = -1, this.char = -1;
        let getNext;
        for (; getNext === !1 || this.nextChar(); )
          getNext = this.runOne();
        this._buf = null;
      }
      nextChar() {
        return this.char === 10 && (++this.line, this.col = -1), ++this.ii, this.char = this._buf.codePointAt(this.ii), ++this.pos, ++this.col, this.haveBuffer();
      }
      haveBuffer() {
        return this.ii < this._buf.length;
      }
      runOne() {
        return this.state.parser.call(this, this.state.returned);
      }
      finish() {
        this.char = ParserEND;
        let last;
        do
          last = this.state.parser, this.runOne();
        while (this.state.parser !== last);
        return this.ctx = null, this.state = null, this._buf = null, this.obj;
      }
      next(fn) {
        if (typeof fn != "function")
          throw new ParserError("Tried to set state to non-existent state: " + JSON.stringify(fn));
        this.state.parser = fn;
      }
      goto(fn) {
        return this.next(fn), this.runOne();
      }
      call(fn, returnWith) {
        returnWith && this.next(returnWith), this.stack.push(this.state), this.state = new State(fn);
      }
      callNow(fn, returnWith) {
        return this.call(fn, returnWith), this.runOne();
      }
      return(value) {
        if (this.stack.length === 0)
          throw this.error(new ParserError("Stack underflow"));
        value === void 0 && (value = this.state.buf), this.state = this.stack.pop(), this.state.returned = value;
      }
      returnNow(value) {
        return this.return(value), this.runOne();
      }
      consume() {
        if (this.char === ParserEND)
          throw this.error(new ParserError("Unexpected end-of-buffer"));
        this.state.buf += this._buf[this.ii];
      }
      error(err) {
        return err.line = this.line, err.col = this.col, err.pos = this.pos, err;
      }
      /* istanbul ignore next */
      parseStart() {
        throw new ParserError("Must declare a parseStart method");
      }
    };
    Parser.END = ParserEND, Parser.Error = ParserError, module2.exports = Parser;
  }
}), require_create_datetime = __commonJS({
  "node_modules/@iarna/toml/lib/create-datetime.js"(exports2, module2) {
    module2.exports = (value) => {
      const date = new Date(value);
      if (isNaN(date))
        throw new TypeError("Invalid Datetime");
      return date;
    };
  }
}), require_format_num = __commonJS({
  "node_modules/@iarna/toml/lib/format-num.js"(exports2, module2) {
    module2.exports = (d, num) => {
      for (num = String(num); num.length < d; )
        num = "0" + num;
      return num;
    };
  }
}), require_create_datetime_float = __commonJS({
  "node_modules/@iarna/toml/lib/create-datetime-float.js"(exports2, module2) {
    var f = require_format_num(), FloatingDateTime = class extends Date {
      constructor(value) {
        super(value + "Z"), this.isFloating = !0;
      }
      toISOString() {
        const date = `${this.getUTCFullYear()}-${f(2, this.getUTCMonth() + 1)}-${f(2, this.getUTCDate())}`, time = `${f(2, this.getUTCHours())}:${f(2, this.getUTCMinutes())}:${f(2, this.getUTCSeconds())}.${f(3, this.getUTCMilliseconds())}`;
        return `${date}T${time}`;
      }
    };
    module2.exports = (value) => {
      const date = new FloatingDateTime(value);
      if (isNaN(date))
        throw new TypeError("Invalid Datetime");
      return date;
    };
  }
}), require_create_date = __commonJS({
  "node_modules/@iarna/toml/lib/create-date.js"(exports2, module2) {
    var f = require_format_num(), DateTime = global.Date, Date2 = class extends DateTime {
      constructor(value) {
        super(value), this.isDate = !0;
      }
      toISOString() {
        return `${this.getUTCFullYear()}-${f(2, this.getUTCMonth() + 1)}-${f(2, this.getUTCDate())}`;
      }
    };
    module2.exports = (value) => {
      const date = new Date2(value);
      if (isNaN(date))
        throw new TypeError("Invalid Datetime");
      return date;
    };
  }
}), require_create_time = __commonJS({
  "node_modules/@iarna/toml/lib/create-time.js"(exports2, module2) {
    var f = require_format_num(), Time = class extends Date {
      constructor(value) {
        super(`0000-01-01T${value}Z`), this.isTime = !0;
      }
      toISOString() {
        return `${f(2, this.getUTCHours())}:${f(2, this.getUTCMinutes())}:${f(2, this.getUTCSeconds())}.${f(3, this.getUTCMilliseconds())}`;
      }
    };
    module2.exports = (value) => {
      const date = new Time(value);
      if (isNaN(date))
        throw new TypeError("Invalid Datetime");
      return date;
    };
  }
}), require_toml_parser = __commonJS({
  "node_modules/@iarna/toml/lib/toml-parser.js"(exports2, module2) {
    module2.exports = makeParserClass(require_parser()), module2.exports.makeParserClass = makeParserClass;
    var TomlError = class _TomlError extends Error {
      constructor(msg) {
        super(msg), this.name = "TomlError", Error.captureStackTrace && Error.captureStackTrace(this, _TomlError), this.fromTOML = !0, this.wrapped = null;
      }
    };
    TomlError.wrap = (err) => {
      const terr = new TomlError(err.message);
      return terr.code = err.code, terr.wrapped = err, terr;
    }, module2.exports.TomlError = TomlError;
    var createDateTime = require_create_datetime(), createDateTimeFloat = require_create_datetime_float(), createDate = require_create_date(), createTime = require_create_time(), CTRL_I = 9, CTRL_J = 10, CTRL_M = 13, CTRL_CHAR_BOUNDARY = 31, CHAR_SP = 32, CHAR_QUOT = 34, CHAR_NUM = 35, CHAR_APOS = 39, CHAR_PLUS = 43, CHAR_COMMA = 44, CHAR_HYPHEN = 45, CHAR_PERIOD = 46, CHAR_0 = 48, CHAR_1 = 49, CHAR_7 = 55, CHAR_9 = 57, CHAR_COLON = 58, CHAR_EQUALS = 61, CHAR_A = 65, CHAR_E = 69, CHAR_F = 70, CHAR_T = 84, CHAR_U = 85, CHAR_Z = 90, CHAR_LOWBAR = 95, CHAR_a = 97, CHAR_b = 98, CHAR_e = 101, CHAR_f = 102, CHAR_i = 105, CHAR_l = 108, CHAR_n = 110, CHAR_o = 111, CHAR_r = 114, CHAR_s = 115, CHAR_t = 116, CHAR_u = 117, CHAR_x = 120, CHAR_z = 122, CHAR_LCUB = 123, CHAR_RCUB = 125, CHAR_LSQB = 91, CHAR_BSOL = 92, CHAR_RSQB = 93, CHAR_DEL = 127, SURROGATE_FIRST = 55296, SURROGATE_LAST = 57343, escapes = {
      [CHAR_b]: "\b",
      [CHAR_t]: "	",
      [CHAR_n]: `
`,
      [CHAR_f]: "\f",
      [CHAR_r]: "\r",
      [CHAR_QUOT]: '"',
      [CHAR_BSOL]: "\\"
    };
    function isDigit(cp) {
      return cp >= CHAR_0 && cp <= CHAR_9;
    }
    function isHexit(cp) {
      return cp >= CHAR_A && cp <= CHAR_F || cp >= CHAR_a && cp <= CHAR_f || cp >= CHAR_0 && cp <= CHAR_9;
    }
    function isBit(cp) {
      return cp === CHAR_1 || cp === CHAR_0;
    }
    function isOctit(cp) {
      return cp >= CHAR_0 && cp <= CHAR_7;
    }
    function isAlphaNumQuoteHyphen(cp) {
      return cp >= CHAR_A && cp <= CHAR_Z || cp >= CHAR_a && cp <= CHAR_z || cp >= CHAR_0 && cp <= CHAR_9 || cp === CHAR_APOS || cp === CHAR_QUOT || cp === CHAR_LOWBAR || cp === CHAR_HYPHEN;
    }
    function isAlphaNumHyphen(cp) {
      return cp >= CHAR_A && cp <= CHAR_Z || cp >= CHAR_a && cp <= CHAR_z || cp >= CHAR_0 && cp <= CHAR_9 || cp === CHAR_LOWBAR || cp === CHAR_HYPHEN;
    }
    var _type = Symbol("type"), _declared = Symbol("declared"), hasOwnProperty3 = Object.prototype.hasOwnProperty, defineProperty = Object.defineProperty, descriptor = { configurable: !0, enumerable: !0, writable: !0, value: void 0 };
    function hasKey(obj, key2) {
      return hasOwnProperty3.call(obj, key2) ? !0 : (key2 === "__proto__" && defineProperty(obj, "__proto__", descriptor), !1);
    }
    var INLINE_TABLE = Symbol("inline-table");
    function InlineTable() {
      return Object.defineProperties({}, {
        [_type]: { value: INLINE_TABLE }
      });
    }
    function isInlineTable(obj) {
      return obj === null || typeof obj != "object" ? !1 : obj[_type] === INLINE_TABLE;
    }
    var TABLE = Symbol("table");
    function Table() {
      return Object.defineProperties({}, {
        [_type]: { value: TABLE },
        [_declared]: { value: !1, writable: !0 }
      });
    }
    function isTable(obj) {
      return obj === null || typeof obj != "object" ? !1 : obj[_type] === TABLE;
    }
    var _contentType = Symbol("content-type"), INLINE_LIST = Symbol("inline-list");
    function InlineList(type2) {
      return Object.defineProperties([], {
        [_type]: { value: INLINE_LIST },
        [_contentType]: { value: type2 }
      });
    }
    function isInlineList(obj) {
      return obj === null || typeof obj != "object" ? !1 : obj[_type] === INLINE_LIST;
    }
    var LIST = Symbol("list");
    function List() {
      return Object.defineProperties([], {
        [_type]: { value: LIST }
      });
    }
    function isList(obj) {
      return obj === null || typeof obj != "object" ? !1 : obj[_type] === LIST;
    }
    var _custom;
    try {
      _custom = __require("util").inspect.custom;
    } catch {
    }
    var _inspect = _custom || "inspect", BoxedBigInt = class {
      constructor(value) {
        try {
          this.value = global.BigInt.asIntN(64, value);
        } catch {
          this.value = null;
        }
        Object.defineProperty(this, _type, { value: INTEGER });
      }
      isNaN() {
        return this.value === null;
      }
      /* istanbul ignore next */
      toString() {
        return String(this.value);
      }
      /* istanbul ignore next */
      [_inspect]() {
        return `[BigInt: ${this.toString()}]}`;
      }
      valueOf() {
        return this.value;
      }
    }, INTEGER = Symbol("integer");
    function Integer(value) {
      let num = Number(value);
      return Object.is(num, -0) && (num = 0), global.BigInt && !Number.isSafeInteger(num) ? new BoxedBigInt(value) : Object.defineProperties(new Number(num), {
        isNaN: { value: function() {
          return isNaN(this);
        } },
        [_type]: { value: INTEGER },
        [_inspect]: { value: () => `[Integer: ${value}]` }
      });
    }
    function isInteger2(obj) {
      return obj === null || typeof obj != "object" ? !1 : obj[_type] === INTEGER;
    }
    var FLOAT = Symbol("float");
    function Float(value) {
      return Object.defineProperties(new Number(value), {
        [_type]: { value: FLOAT },
        [_inspect]: { value: () => `[Float: ${value}]` }
      });
    }
    function isFloat2(obj) {
      return obj === null || typeof obj != "object" ? !1 : obj[_type] === FLOAT;
    }
    function tomlType(value) {
      const type2 = typeof value;
      if (type2 === "object") {
        if (value === null)
          return "null";
        if (value instanceof Date)
          return "datetime";
        if (_type in value)
          switch (value[_type]) {
            case INLINE_TABLE:
              return "inline-table";
            case INLINE_LIST:
              return "inline-list";
            case TABLE:
              return "table";
            case LIST:
              return "list";
            case FLOAT:
              return "float";
            case INTEGER:
              return "integer";
          }
      }
      return type2;
    }
    function makeParserClass(Parser) {
      class TOMLParser extends Parser {
        constructor() {
          super(), this.ctx = this.obj = Table();
        }
        /* MATCH HELPER */
        atEndOfWord() {
          return this.char === CHAR_NUM || this.char === CTRL_I || this.char === CHAR_SP || this.atEndOfLine();
        }
        atEndOfLine() {
          return this.char === Parser.END || this.char === CTRL_J || this.char === CTRL_M;
        }
        parseStart() {
          if (this.char === Parser.END)
            return null;
          if (this.char === CHAR_LSQB)
            return this.call(this.parseTableOrList);
          if (this.char === CHAR_NUM)
            return this.call(this.parseComment);
          if (this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M)
            return null;
          if (isAlphaNumQuoteHyphen(this.char))
            return this.callNow(this.parseAssignStatement);
          throw this.error(new TomlError(`Unknown character "${this.char}"`));
        }
        // HELPER, this strips any whitespace and comments to the end of the line
        // then RETURNS. Last state in a production.
        parseWhitespaceToEOL() {
          if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M)
            return null;
          if (this.char === CHAR_NUM)
            return this.goto(this.parseComment);
          if (this.char === Parser.END || this.char === CTRL_J)
            return this.return();
          throw this.error(new TomlError("Unexpected character, expected only whitespace or comments till end of line"));
        }
        /* ASSIGNMENT: key = value */
        parseAssignStatement() {
          return this.callNow(this.parseAssign, this.recordAssignStatement);
        }
        recordAssignStatement(kv) {
          let target = this.ctx, finalKey = kv.key.pop();
          for (let kw of kv.key) {
            if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared]))
              throw this.error(new TomlError("Can't redefine existing key"));
            target = target[kw] = target[kw] || Table();
          }
          if (hasKey(target, finalKey))
            throw this.error(new TomlError("Can't redefine existing key"));
          return isInteger2(kv.value) || isFloat2(kv.value) ? target[finalKey] = kv.value.valueOf() : target[finalKey] = kv.value, this.goto(this.parseWhitespaceToEOL);
        }
        /* ASSSIGNMENT expression, key = value possibly inside an inline table */
        parseAssign() {
          return this.callNow(this.parseKeyword, this.recordAssignKeyword);
        }
        recordAssignKeyword(key2) {
          return this.state.resultTable ? this.state.resultTable.push(key2) : this.state.resultTable = [key2], this.goto(this.parseAssignKeywordPreDot);
        }
        parseAssignKeywordPreDot() {
          if (this.char === CHAR_PERIOD)
            return this.next(this.parseAssignKeywordPostDot);
          if (this.char !== CHAR_SP && this.char !== CTRL_I)
            return this.goto(this.parseAssignEqual);
        }
        parseAssignKeywordPostDot() {
          if (this.char !== CHAR_SP && this.char !== CTRL_I)
            return this.callNow(this.parseKeyword, this.recordAssignKeyword);
        }
        parseAssignEqual() {
          if (this.char === CHAR_EQUALS)
            return this.next(this.parseAssignPreValue);
          throw this.error(new TomlError('Invalid character, expected "="'));
        }
        parseAssignPreValue() {
          return this.char === CHAR_SP || this.char === CTRL_I ? null : this.callNow(this.parseValue, this.recordAssignValue);
        }
        recordAssignValue(value) {
          return this.returnNow({ key: this.state.resultTable, value });
        }
        /* COMMENTS: #...eol */
        parseComment() {
          do
            if (this.char === Parser.END || this.char === CTRL_J)
              return this.return();
          while (this.nextChar());
        }
        /* TABLES AND LISTS, [foo] and [[foo]] */
        parseTableOrList() {
          if (this.char === CHAR_LSQB)
            this.next(this.parseList);
          else
            return this.goto(this.parseTable);
        }
        /* TABLE [foo.bar.baz] */
        parseTable() {
          return this.ctx = this.obj, this.goto(this.parseTableNext);
        }
        parseTableNext() {
          return this.char === CHAR_SP || this.char === CTRL_I ? null : this.callNow(this.parseKeyword, this.parseTableMore);
        }
        parseTableMore(keyword) {
          if (this.char === CHAR_SP || this.char === CTRL_I)
            return null;
          if (this.char === CHAR_RSQB) {
            if (hasKey(this.ctx, keyword) && (!isTable(this.ctx[keyword]) || this.ctx[keyword][_declared]))
              throw this.error(new TomlError("Can't redefine existing key"));
            return this.ctx = this.ctx[keyword] = this.ctx[keyword] || Table(), this.ctx[_declared] = !0, this.next(this.parseWhitespaceToEOL);
          } else if (this.char === CHAR_PERIOD) {
            if (!hasKey(this.ctx, keyword))
              this.ctx = this.ctx[keyword] = Table();
            else if (isTable(this.ctx[keyword]))
              this.ctx = this.ctx[keyword];
            else if (isList(this.ctx[keyword]))
              this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];
            else
              throw this.error(new TomlError("Can't redefine existing key"));
            return this.next(this.parseTableNext);
          } else
            throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
        }
        /* LIST [[a.b.c]] */
        parseList() {
          return this.ctx = this.obj, this.goto(this.parseListNext);
        }
        parseListNext() {
          return this.char === CHAR_SP || this.char === CTRL_I ? null : this.callNow(this.parseKeyword, this.parseListMore);
        }
        parseListMore(keyword) {
          if (this.char === CHAR_SP || this.char === CTRL_I)
            return null;
          if (this.char === CHAR_RSQB) {
            if (hasKey(this.ctx, keyword) || (this.ctx[keyword] = List()), isInlineList(this.ctx[keyword]))
              throw this.error(new TomlError("Can't extend an inline array"));
            if (isList(this.ctx[keyword])) {
              const next = Table();
              this.ctx[keyword].push(next), this.ctx = next;
            } else
              throw this.error(new TomlError("Can't redefine an existing key"));
            return this.next(this.parseListEnd);
          } else if (this.char === CHAR_PERIOD) {
            if (!hasKey(this.ctx, keyword))
              this.ctx = this.ctx[keyword] = Table();
            else {
              if (isInlineList(this.ctx[keyword]))
                throw this.error(new TomlError("Can't extend an inline array"));
              if (isInlineTable(this.ctx[keyword]))
                throw this.error(new TomlError("Can't extend an inline table"));
              if (isList(this.ctx[keyword]))
                this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];
              else if (isTable(this.ctx[keyword]))
                this.ctx = this.ctx[keyword];
              else
                throw this.error(new TomlError("Can't redefine an existing key"));
            }
            return this.next(this.parseListNext);
          } else
            throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
        }
        parseListEnd(keyword) {
          if (this.char === CHAR_RSQB)
            return this.next(this.parseWhitespaceToEOL);
          throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
        }
        /* VALUE string, number, boolean, inline list, inline object */
        parseValue() {
          if (this.char === Parser.END)
            throw this.error(new TomlError("Key without value"));
          if (this.char === CHAR_QUOT)
            return this.next(this.parseDoubleString);
          if (this.char === CHAR_APOS)
            return this.next(this.parseSingleString);
          if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS)
            return this.goto(this.parseNumberSign);
          if (this.char === CHAR_i)
            return this.next(this.parseInf);
          if (this.char === CHAR_n)
            return this.next(this.parseNan);
          if (isDigit(this.char))
            return this.goto(this.parseNumberOrDateTime);
          if (this.char === CHAR_t || this.char === CHAR_f)
            return this.goto(this.parseBoolean);
          if (this.char === CHAR_LSQB)
            return this.call(this.parseInlineList, this.recordValue);
          if (this.char === CHAR_LCUB)
            return this.call(this.parseInlineTable, this.recordValue);
          throw this.error(new TomlError("Unexpected character, expecting string, number, datetime, boolean, inline array or inline table"));
        }
        recordValue(value) {
          return this.returnNow(value);
        }
        parseInf() {
          if (this.char === CHAR_n)
            return this.next(this.parseInf2);
          throw this.error(new TomlError('Unexpected character, expected "inf", "+inf" or "-inf"'));
        }
        parseInf2() {
          if (this.char === CHAR_f)
            return this.state.buf === "-" ? this.return(-1 / 0) : this.return(1 / 0);
          throw this.error(new TomlError('Unexpected character, expected "inf", "+inf" or "-inf"'));
        }
        parseNan() {
          if (this.char === CHAR_a)
            return this.next(this.parseNan2);
          throw this.error(new TomlError('Unexpected character, expected "nan"'));
        }
        parseNan2() {
          if (this.char === CHAR_n)
            return this.return(NaN);
          throw this.error(new TomlError('Unexpected character, expected "nan"'));
        }
        /* KEYS, barewords or basic, literal, or dotted */
        parseKeyword() {
          return this.char === CHAR_QUOT ? this.next(this.parseBasicString) : this.char === CHAR_APOS ? this.next(this.parseLiteralString) : this.goto(this.parseBareKey);
        }
        /* KEYS: barewords */
        parseBareKey() {
          do {
            if (this.char === Parser.END)
              throw this.error(new TomlError("Key ended without value"));
            if (isAlphaNumHyphen(this.char))
              this.consume();
            else {
              if (this.state.buf.length === 0)
                throw this.error(new TomlError("Empty bare keys are not allowed"));
              return this.returnNow();
            }
          } while (this.nextChar());
        }
        /* STRINGS, single quoted (literal) */
        parseSingleString() {
          return this.char === CHAR_APOS ? this.next(this.parseLiteralMultiStringMaybe) : this.goto(this.parseLiteralString);
        }
        parseLiteralString() {
          do {
            if (this.char === CHAR_APOS)
              return this.return();
            if (this.atEndOfLine())
              throw this.error(new TomlError("Unterminated string"));
            if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I)
              throw this.errorControlCharInString();
            this.consume();
          } while (this.nextChar());
        }
        parseLiteralMultiStringMaybe() {
          return this.char === CHAR_APOS ? this.next(this.parseLiteralMultiString) : this.returnNow();
        }
        parseLiteralMultiString() {
          return this.char === CTRL_M ? null : this.char === CTRL_J ? this.next(this.parseLiteralMultiStringContent) : this.goto(this.parseLiteralMultiStringContent);
        }
        parseLiteralMultiStringContent() {
          do {
            if (this.char === CHAR_APOS)
              return this.next(this.parseLiteralMultiEnd);
            if (this.char === Parser.END)
              throw this.error(new TomlError("Unterminated multi-line string"));
            if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M)
              throw this.errorControlCharInString();
            this.consume();
          } while (this.nextChar());
        }
        parseLiteralMultiEnd() {
          return this.char === CHAR_APOS ? this.next(this.parseLiteralMultiEnd2) : (this.state.buf += "'", this.goto(this.parseLiteralMultiStringContent));
        }
        parseLiteralMultiEnd2() {
          return this.char === CHAR_APOS ? this.return() : (this.state.buf += "''", this.goto(this.parseLiteralMultiStringContent));
        }
        /* STRINGS double quoted */
        parseDoubleString() {
          return this.char === CHAR_QUOT ? this.next(this.parseMultiStringMaybe) : this.goto(this.parseBasicString);
        }
        parseBasicString() {
          do {
            if (this.char === CHAR_BSOL)
              return this.call(this.parseEscape, this.recordEscapeReplacement);
            if (this.char === CHAR_QUOT)
              return this.return();
            if (this.atEndOfLine())
              throw this.error(new TomlError("Unterminated string"));
            if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I)
              throw this.errorControlCharInString();
            this.consume();
          } while (this.nextChar());
        }
        recordEscapeReplacement(replacement) {
          return this.state.buf += replacement, this.goto(this.parseBasicString);
        }
        parseMultiStringMaybe() {
          return this.char === CHAR_QUOT ? this.next(this.parseMultiString) : this.returnNow();
        }
        parseMultiString() {
          return this.char === CTRL_M ? null : this.char === CTRL_J ? this.next(this.parseMultiStringContent) : this.goto(this.parseMultiStringContent);
        }
        parseMultiStringContent() {
          do {
            if (this.char === CHAR_BSOL)
              return this.call(this.parseMultiEscape, this.recordMultiEscapeReplacement);
            if (this.char === CHAR_QUOT)
              return this.next(this.parseMultiEnd);
            if (this.char === Parser.END)
              throw this.error(new TomlError("Unterminated multi-line string"));
            if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M)
              throw this.errorControlCharInString();
            this.consume();
          } while (this.nextChar());
        }
        errorControlCharInString() {
          let displayCode = "\\u00";
          return this.char < 16 && (displayCode += "0"), displayCode += this.char.toString(16), this.error(new TomlError(`Control characters (codes < 0x1f and 0x7f) are not allowed in strings, use ${displayCode} instead`));
        }
        recordMultiEscapeReplacement(replacement) {
          return this.state.buf += replacement, this.goto(this.parseMultiStringContent);
        }
        parseMultiEnd() {
          return this.char === CHAR_QUOT ? this.next(this.parseMultiEnd2) : (this.state.buf += '"', this.goto(this.parseMultiStringContent));
        }
        parseMultiEnd2() {
          return this.char === CHAR_QUOT ? this.return() : (this.state.buf += '""', this.goto(this.parseMultiStringContent));
        }
        parseMultiEscape() {
          return this.char === CTRL_M || this.char === CTRL_J ? this.next(this.parseMultiTrim) : this.char === CHAR_SP || this.char === CTRL_I ? this.next(this.parsePreMultiTrim) : this.goto(this.parseEscape);
        }
        parsePreMultiTrim() {
          if (this.char === CHAR_SP || this.char === CTRL_I)
            return null;
          if (this.char === CTRL_M || this.char === CTRL_J)
            return this.next(this.parseMultiTrim);
          throw this.error(new TomlError("Can't escape whitespace"));
        }
        parseMultiTrim() {
          return this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M ? null : this.returnNow();
        }
        parseEscape() {
          if (this.char in escapes)
            return this.return(escapes[this.char]);
          if (this.char === CHAR_u)
            return this.call(this.parseSmallUnicode, this.parseUnicodeReturn);
          if (this.char === CHAR_U)
            return this.call(this.parseLargeUnicode, this.parseUnicodeReturn);
          throw this.error(new TomlError("Unknown escape character: " + this.char));
        }
        parseUnicodeReturn(char) {
          try {
            const codePoint = parseInt(char, 16);
            if (codePoint >= SURROGATE_FIRST && codePoint <= SURROGATE_LAST)
              throw this.error(new TomlError("Invalid unicode, character in range 0xD800 - 0xDFFF is reserved"));
            return this.returnNow(String.fromCodePoint(codePoint));
          } catch (err) {
            throw this.error(TomlError.wrap(err));
          }
        }
        parseSmallUnicode() {
          if (isHexit(this.char)) {
            if (this.consume(), this.state.buf.length >= 4)
              return this.return();
          } else
            throw this.error(new TomlError("Invalid character in unicode sequence, expected hex"));
        }
        parseLargeUnicode() {
          if (isHexit(this.char)) {
            if (this.consume(), this.state.buf.length >= 8)
              return this.return();
          } else
            throw this.error(new TomlError("Invalid character in unicode sequence, expected hex"));
        }
        /* NUMBERS */
        parseNumberSign() {
          return this.consume(), this.next(this.parseMaybeSignedInfOrNan);
        }
        parseMaybeSignedInfOrNan() {
          return this.char === CHAR_i ? this.next(this.parseInf) : this.char === CHAR_n ? this.next(this.parseNan) : this.callNow(this.parseNoUnder, this.parseNumberIntegerStart);
        }
        parseNumberIntegerStart() {
          return this.char === CHAR_0 ? (this.consume(), this.next(this.parseNumberIntegerExponentOrDecimal)) : this.goto(this.parseNumberInteger);
        }
        parseNumberIntegerExponentOrDecimal() {
          return this.char === CHAR_PERIOD ? (this.consume(), this.call(this.parseNoUnder, this.parseNumberFloat)) : this.char === CHAR_E || this.char === CHAR_e ? (this.consume(), this.next(this.parseNumberExponentSign)) : this.returnNow(Integer(this.state.buf));
        }
        parseNumberInteger() {
          if (isDigit(this.char))
            this.consume();
          else {
            if (this.char === CHAR_LOWBAR)
              return this.call(this.parseNoUnder);
            if (this.char === CHAR_E || this.char === CHAR_e)
              return this.consume(), this.next(this.parseNumberExponentSign);
            if (this.char === CHAR_PERIOD)
              return this.consume(), this.call(this.parseNoUnder, this.parseNumberFloat);
            {
              const result = Integer(this.state.buf);
              if (result.isNaN())
                throw this.error(new TomlError("Invalid number"));
              return this.returnNow(result);
            }
          }
        }
        parseNoUnder() {
          if (this.char === CHAR_LOWBAR || this.char === CHAR_PERIOD || this.char === CHAR_E || this.char === CHAR_e)
            throw this.error(new TomlError("Unexpected character, expected digit"));
          if (this.atEndOfWord())
            throw this.error(new TomlError("Incomplete number"));
          return this.returnNow();
        }
        parseNoUnderHexOctBinLiteral() {
          if (this.char === CHAR_LOWBAR || this.char === CHAR_PERIOD)
            throw this.error(new TomlError("Unexpected character, expected digit"));
          if (this.atEndOfWord())
            throw this.error(new TomlError("Incomplete number"));
          return this.returnNow();
        }
        parseNumberFloat() {
          if (this.char === CHAR_LOWBAR)
            return this.call(this.parseNoUnder, this.parseNumberFloat);
          if (isDigit(this.char))
            this.consume();
          else
            return this.char === CHAR_E || this.char === CHAR_e ? (this.consume(), this.next(this.parseNumberExponentSign)) : this.returnNow(Float(this.state.buf));
        }
        parseNumberExponentSign() {
          if (isDigit(this.char))
            return this.goto(this.parseNumberExponent);
          if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS)
            this.consume(), this.call(this.parseNoUnder, this.parseNumberExponent);
          else
            throw this.error(new TomlError("Unexpected character, expected -, + or digit"));
        }
        parseNumberExponent() {
          if (isDigit(this.char))
            this.consume();
          else
            return this.char === CHAR_LOWBAR ? this.call(this.parseNoUnder) : this.returnNow(Float(this.state.buf));
        }
        /* NUMBERS or DATETIMES  */
        parseNumberOrDateTime() {
          return this.char === CHAR_0 ? (this.consume(), this.next(this.parseNumberBaseOrDateTime)) : this.goto(this.parseNumberOrDateTimeOnly);
        }
        parseNumberOrDateTimeOnly() {
          if (this.char === CHAR_LOWBAR)
            return this.call(this.parseNoUnder, this.parseNumberInteger);
          if (isDigit(this.char))
            this.consume(), this.state.buf.length > 4 && this.next(this.parseNumberInteger);
          else
            return this.char === CHAR_E || this.char === CHAR_e ? (this.consume(), this.next(this.parseNumberExponentSign)) : this.char === CHAR_PERIOD ? (this.consume(), this.call(this.parseNoUnder, this.parseNumberFloat)) : this.char === CHAR_HYPHEN ? this.goto(this.parseDateTime) : this.char === CHAR_COLON ? this.goto(this.parseOnlyTimeHour) : this.returnNow(Integer(this.state.buf));
        }
        parseDateTimeOnly() {
          if (this.state.buf.length < 4) {
            if (isDigit(this.char))
              return this.consume();
            if (this.char === CHAR_COLON)
              return this.goto(this.parseOnlyTimeHour);
            throw this.error(new TomlError("Expected digit while parsing year part of a date"));
          } else {
            if (this.char === CHAR_HYPHEN)
              return this.goto(this.parseDateTime);
            throw this.error(new TomlError("Expected hyphen (-) while parsing year part of date"));
          }
        }
        parseNumberBaseOrDateTime() {
          return this.char === CHAR_b ? (this.consume(), this.call(this.parseNoUnderHexOctBinLiteral, this.parseIntegerBin)) : this.char === CHAR_o ? (this.consume(), this.call(this.parseNoUnderHexOctBinLiteral, this.parseIntegerOct)) : this.char === CHAR_x ? (this.consume(), this.call(this.parseNoUnderHexOctBinLiteral, this.parseIntegerHex)) : this.char === CHAR_PERIOD ? this.goto(this.parseNumberInteger) : isDigit(this.char) ? this.goto(this.parseDateTimeOnly) : this.returnNow(Integer(this.state.buf));
        }
        parseIntegerHex() {
          if (isHexit(this.char))
            this.consume();
          else {
            if (this.char === CHAR_LOWBAR)
              return this.call(this.parseNoUnderHexOctBinLiteral);
            {
              const result = Integer(this.state.buf);
              if (result.isNaN())
                throw this.error(new TomlError("Invalid number"));
              return this.returnNow(result);
            }
          }
        }
        parseIntegerOct() {
          if (isOctit(this.char))
            this.consume();
          else {
            if (this.char === CHAR_LOWBAR)
              return this.call(this.parseNoUnderHexOctBinLiteral);
            {
              const result = Integer(this.state.buf);
              if (result.isNaN())
                throw this.error(new TomlError("Invalid number"));
              return this.returnNow(result);
            }
          }
        }
        parseIntegerBin() {
          if (isBit(this.char))
            this.consume();
          else {
            if (this.char === CHAR_LOWBAR)
              return this.call(this.parseNoUnderHexOctBinLiteral);
            {
              const result = Integer(this.state.buf);
              if (result.isNaN())
                throw this.error(new TomlError("Invalid number"));
              return this.returnNow(result);
            }
          }
        }
        /* DATETIME */
        parseDateTime() {
          if (this.state.buf.length < 4)
            throw this.error(new TomlError("Years less than 1000 must be zero padded to four characters"));
          return this.state.result = this.state.buf, this.state.buf = "", this.next(this.parseDateMonth);
        }
        parseDateMonth() {
          if (this.char === CHAR_HYPHEN) {
            if (this.state.buf.length < 2)
              throw this.error(new TomlError("Months less than 10 must be zero padded to two characters"));
            return this.state.result += "-" + this.state.buf, this.state.buf = "", this.next(this.parseDateDay);
          } else if (isDigit(this.char))
            this.consume();
          else
            throw this.error(new TomlError("Incomplete datetime"));
        }
        parseDateDay() {
          if (this.char === CHAR_T || this.char === CHAR_SP) {
            if (this.state.buf.length < 2)
              throw this.error(new TomlError("Days less than 10 must be zero padded to two characters"));
            return this.state.result += "-" + this.state.buf, this.state.buf = "", this.next(this.parseStartTimeHour);
          } else {
            if (this.atEndOfWord())
              return this.returnNow(createDate(this.state.result + "-" + this.state.buf));
            if (isDigit(this.char))
              this.consume();
            else
              throw this.error(new TomlError("Incomplete datetime"));
          }
        }
        parseStartTimeHour() {
          return this.atEndOfWord() ? this.returnNow(createDate(this.state.result)) : this.goto(this.parseTimeHour);
        }
        parseTimeHour() {
          if (this.char === CHAR_COLON) {
            if (this.state.buf.length < 2)
              throw this.error(new TomlError("Hours less than 10 must be zero padded to two characters"));
            return this.state.result += "T" + this.state.buf, this.state.buf = "", this.next(this.parseTimeMin);
          } else if (isDigit(this.char))
            this.consume();
          else
            throw this.error(new TomlError("Incomplete datetime"));
        }
        parseTimeMin() {
          if (this.state.buf.length < 2 && isDigit(this.char))
            this.consume();
          else {
            if (this.state.buf.length === 2 && this.char === CHAR_COLON)
              return this.state.result += ":" + this.state.buf, this.state.buf = "", this.next(this.parseTimeSec);
            throw this.error(new TomlError("Incomplete datetime"));
          }
        }
        parseTimeSec() {
          if (isDigit(this.char)) {
            if (this.consume(), this.state.buf.length === 2)
              return this.state.result += ":" + this.state.buf, this.state.buf = "", this.next(this.parseTimeZoneOrFraction);
          } else
            throw this.error(new TomlError("Incomplete datetime"));
        }
        parseOnlyTimeHour() {
          if (this.char === CHAR_COLON) {
            if (this.state.buf.length < 2)
              throw this.error(new TomlError("Hours less than 10 must be zero padded to two characters"));
            return this.state.result = this.state.buf, this.state.buf = "", this.next(this.parseOnlyTimeMin);
          } else
            throw this.error(new TomlError("Incomplete time"));
        }
        parseOnlyTimeMin() {
          if (this.state.buf.length < 2 && isDigit(this.char))
            this.consume();
          else {
            if (this.state.buf.length === 2 && this.char === CHAR_COLON)
              return this.state.result += ":" + this.state.buf, this.state.buf = "", this.next(this.parseOnlyTimeSec);
            throw this.error(new TomlError("Incomplete time"));
          }
        }
        parseOnlyTimeSec() {
          if (isDigit(this.char)) {
            if (this.consume(), this.state.buf.length === 2)
              return this.next(this.parseOnlyTimeFractionMaybe);
          } else
            throw this.error(new TomlError("Incomplete time"));
        }
        parseOnlyTimeFractionMaybe() {
          if (this.state.result += ":" + this.state.buf, this.char === CHAR_PERIOD)
            this.state.buf = "", this.next(this.parseOnlyTimeFraction);
          else
            return this.return(createTime(this.state.result));
        }
        parseOnlyTimeFraction() {
          if (isDigit(this.char))
            this.consume();
          else if (this.atEndOfWord()) {
            if (this.state.buf.length === 0)
              throw this.error(new TomlError("Expected digit in milliseconds"));
            return this.returnNow(createTime(this.state.result + "." + this.state.buf));
          } else
            throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
        }
        parseTimeZoneOrFraction() {
          if (this.char === CHAR_PERIOD)
            this.consume(), this.next(this.parseDateTimeFraction);
          else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS)
            this.consume(), this.next(this.parseTimeZoneHour);
          else {
            if (this.char === CHAR_Z)
              return this.consume(), this.return(createDateTime(this.state.result + this.state.buf));
            if (this.atEndOfWord())
              return this.returnNow(createDateTimeFloat(this.state.result + this.state.buf));
            throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
          }
        }
        parseDateTimeFraction() {
          if (isDigit(this.char))
            this.consume();
          else {
            if (this.state.buf.length === 1)
              throw this.error(new TomlError("Expected digit in milliseconds"));
            if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS)
              this.consume(), this.next(this.parseTimeZoneHour);
            else {
              if (this.char === CHAR_Z)
                return this.consume(), this.return(createDateTime(this.state.result + this.state.buf));
              if (this.atEndOfWord())
                return this.returnNow(createDateTimeFloat(this.state.result + this.state.buf));
              throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
            }
          }
        }
        parseTimeZoneHour() {
          if (isDigit(this.char)) {
            if (this.consume(), /\d\d$/.test(this.state.buf))
              return this.next(this.parseTimeZoneSep);
          } else
            throw this.error(new TomlError("Unexpected character in datetime, expected digit"));
        }
        parseTimeZoneSep() {
          if (this.char === CHAR_COLON)
            this.consume(), this.next(this.parseTimeZoneMin);
          else
            throw this.error(new TomlError("Unexpected character in datetime, expected colon"));
        }
        parseTimeZoneMin() {
          if (isDigit(this.char)) {
            if (this.consume(), /\d\d$/.test(this.state.buf))
              return this.return(createDateTime(this.state.result + this.state.buf));
          } else
            throw this.error(new TomlError("Unexpected character in datetime, expected digit"));
        }
        /* BOOLEAN */
        parseBoolean() {
          if (this.char === CHAR_t)
            return this.consume(), this.next(this.parseTrue_r);
          if (this.char === CHAR_f)
            return this.consume(), this.next(this.parseFalse_a);
        }
        parseTrue_r() {
          if (this.char === CHAR_r)
            return this.consume(), this.next(this.parseTrue_u);
          throw this.error(new TomlError("Invalid boolean, expected true or false"));
        }
        parseTrue_u() {
          if (this.char === CHAR_u)
            return this.consume(), this.next(this.parseTrue_e);
          throw this.error(new TomlError("Invalid boolean, expected true or false"));
        }
        parseTrue_e() {
          if (this.char === CHAR_e)
            return this.return(!0);
          throw this.error(new TomlError("Invalid boolean, expected true or false"));
        }
        parseFalse_a() {
          if (this.char === CHAR_a)
            return this.consume(), this.next(this.parseFalse_l);
          throw this.error(new TomlError("Invalid boolean, expected true or false"));
        }
        parseFalse_l() {
          if (this.char === CHAR_l)
            return this.consume(), this.next(this.parseFalse_s);
          throw this.error(new TomlError("Invalid boolean, expected true or false"));
        }
        parseFalse_s() {
          if (this.char === CHAR_s)
            return this.consume(), this.next(this.parseFalse_e);
          throw this.error(new TomlError("Invalid boolean, expected true or false"));
        }
        parseFalse_e() {
          if (this.char === CHAR_e)
            return this.return(!1);
          throw this.error(new TomlError("Invalid boolean, expected true or false"));
        }
        /* INLINE LISTS */
        parseInlineList() {
          if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J)
            return null;
          if (this.char === Parser.END)
            throw this.error(new TomlError("Unterminated inline array"));
          return this.char === CHAR_NUM ? this.call(this.parseComment) : this.char === CHAR_RSQB ? this.return(this.state.resultArr || InlineList()) : this.callNow(this.parseValue, this.recordInlineListValue);
        }
        recordInlineListValue(value) {
          if (this.state.resultArr) {
            const listType = this.state.resultArr[_contentType], valueType = tomlType(value);
            if (listType !== valueType)
              throw this.error(new TomlError(`Inline lists must be a single type, not a mix of ${listType} and ${valueType}`));
          } else
            this.state.resultArr = InlineList(tomlType(value));
          return isFloat2(value) || isInteger2(value) ? this.state.resultArr.push(value.valueOf()) : this.state.resultArr.push(value), this.goto(this.parseInlineListNext);
        }
        parseInlineListNext() {
          if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J)
            return null;
          if (this.char === CHAR_NUM)
            return this.call(this.parseComment);
          if (this.char === CHAR_COMMA)
            return this.next(this.parseInlineList);
          if (this.char === CHAR_RSQB)
            return this.goto(this.parseInlineList);
          throw this.error(new TomlError("Invalid character, expected whitespace, comma (,) or close bracket (])"));
        }
        /* INLINE TABLE */
        parseInlineTable() {
          if (this.char === CHAR_SP || this.char === CTRL_I)
            return null;
          if (this.char === Parser.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M)
            throw this.error(new TomlError("Unterminated inline array"));
          return this.char === CHAR_RCUB ? this.return(this.state.resultTable || InlineTable()) : (this.state.resultTable || (this.state.resultTable = InlineTable()), this.callNow(this.parseAssign, this.recordInlineTableValue));
        }
        recordInlineTableValue(kv) {
          let target = this.state.resultTable, finalKey = kv.key.pop();
          for (let kw of kv.key) {
            if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared]))
              throw this.error(new TomlError("Can't redefine existing key"));
            target = target[kw] = target[kw] || Table();
          }
          if (hasKey(target, finalKey))
            throw this.error(new TomlError("Can't redefine existing key"));
          return isInteger2(kv.value) || isFloat2(kv.value) ? target[finalKey] = kv.value.valueOf() : target[finalKey] = kv.value, this.goto(this.parseInlineTableNext);
        }
        parseInlineTableNext() {
          if (this.char === CHAR_SP || this.char === CTRL_I)
            return null;
          if (this.char === Parser.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M)
            throw this.error(new TomlError("Unterminated inline array"));
          if (this.char === CHAR_COMMA)
            return this.next(this.parseInlineTable);
          if (this.char === CHAR_RCUB)
            return this.goto(this.parseInlineTable);
          throw this.error(new TomlError("Invalid character, expected whitespace, comma (,) or close bracket (])"));
        }
      }
      return TOMLParser;
    }
  }
}), require_parse_pretty_error = __commonJS({
  "node_modules/@iarna/toml/parse-pretty-error.js"(exports2, module2) {
    module2.exports = prettyError;
    function prettyError(err, buf) {
      if (err.pos == null || err.line == null)
        return err;
      let msg = err.message;
      if (msg += ` at row ${err.line + 1}, col ${err.col + 1}, pos ${err.pos}:
`, buf && buf.split) {
        const lines = buf.split(/\n/), lineNumWidth = String(Math.min(lines.length, err.line + 3)).length;
        let linePadding = " ";
        for (; linePadding.length < lineNumWidth; )
          linePadding += " ";
        for (let ii = Math.max(0, err.line - 1); ii < Math.min(lines.length, err.line + 2); ++ii) {
          let lineNum = String(ii + 1);
          if (lineNum.length < lineNumWidth && (lineNum = " " + lineNum), err.line === ii) {
            msg += lineNum + "> " + lines[ii] + `
`, msg += linePadding + "  ";
            for (let hh = 0; hh < err.col; ++hh)
              msg += " ";
            msg += `^
`;
          } else
            msg += lineNum + ": " + lines[ii] + `
`;
        }
      }
      return err.message = msg + `
`, err;
    }
  }
}), require_parse_async = __commonJS({
  "node_modules/@iarna/toml/parse-async.js"(exports2, module2) {
    module2.exports = parseAsync;
    var TOMLParser = require_toml_parser(), prettyError = require_parse_pretty_error();
    function parseAsync(str2, opts) {
      opts || (opts = {});
      const index = 0, blocksize = opts.blocksize || 40960, parser = new TOMLParser();
      return new Promise((resolve3, reject) => {
        setImmediate(parseAsyncNext, index, blocksize, resolve3, reject);
      });
      function parseAsyncNext(index2, blocksize2, resolve3, reject) {
        if (index2 >= str2.length)
          try {
            return resolve3(parser.finish());
          } catch (err) {
            return reject(prettyError(err, str2));
          }
        try {
          parser.parse(str2.slice(index2, index2 + blocksize2)), setImmediate(parseAsyncNext, index2 + blocksize2, blocksize2, resolve3, reject);
        } catch (err) {
          reject(prettyError(err, str2));
        }
      }
    }
  }
}), require_js_tokens = __commonJS({
  "node_modules/js-tokens/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    }), exports2.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g, exports2.matchToToken = function(match) {
      var token2 = { type: "invalid", value: match[0], closed: void 0 };
      return match[1] ? (token2.type = "string", token2.closed = !!(match[3] || match[4])) : match[5] ? token2.type = "comment" : match[6] ? (token2.type = "comment", token2.closed = !!match[7]) : match[8] ? token2.type = "regex" : match[9] ? token2.type = "number" : match[10] ? token2.type = "name" : match[11] ? token2.type = "punctuator" : match[12] && (token2.type = "whitespace"), token2;
    };
  }
}), require_identifier = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/identifier.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    }), exports2.isIdentifierChar = isIdentifierChar, exports2.isIdentifierName = isIdentifierName, exports2.isIdentifierStart = isIdentifierStart;
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]"), nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code, set2) {
      let pos2 = 65536;
      for (let i2 = 0, length = set2.length; i2 < length; i2 += 2) {
        if (pos2 += set2[i2], pos2 > code)
          return !1;
        if (pos2 += set2[i2 + 1], pos2 >= code)
          return !0;
      }
      return !1;
    }
    function isIdentifierStart(code) {
      return code < 65 ? code === 36 : code <= 90 ? !0 : code < 97 ? code === 95 : code <= 122 ? !0 : code <= 65535 ? code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code)) : isInAstralSet(code, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code) {
      return code < 48 ? code === 36 : code < 58 ? !0 : code < 65 ? !1 : code <= 90 ? !0 : code < 97 ? code === 95 : code <= 122 ? !0 : code <= 65535 ? code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code)) : isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    function isIdentifierName(name) {
      let isFirst = !0;
      for (let i2 = 0; i2 < name.length; i2++) {
        let cp = name.charCodeAt(i2);
        if ((cp & 64512) === 55296 && i2 + 1 < name.length) {
          const trail = name.charCodeAt(++i2);
          (trail & 64512) === 56320 && (cp = 65536 + ((cp & 1023) << 10) + (trail & 1023));
        }
        if (isFirst) {
          if (isFirst = !1, !isIdentifierStart(cp))
            return !1;
        } else if (!isIdentifierChar(cp))
          return !1;
      }
      return !isFirst;
    }
  }
}), require_keyword = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/keyword.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    }), exports2.isKeyword = isKeyword, exports2.isReservedWord = isReservedWord, exports2.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord, exports2.isStrictBindReservedWord = isStrictBindReservedWord, exports2.isStrictReservedWord = isStrictReservedWord;
    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    }, keywords = new Set(reservedWords.keyword), reservedWordsStrictSet = new Set(reservedWords.strict), reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords.has(word);
    }
  }
}), require_lib = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    }), Object.defineProperty(exports2, "isIdentifierChar", {
      enumerable: !0,
      get: function() {
        return _identifier.isIdentifierChar;
      }
    }), Object.defineProperty(exports2, "isIdentifierName", {
      enumerable: !0,
      get: function() {
        return _identifier.isIdentifierName;
      }
    }), Object.defineProperty(exports2, "isIdentifierStart", {
      enumerable: !0,
      get: function() {
        return _identifier.isIdentifierStart;
      }
    }), Object.defineProperty(exports2, "isKeyword", {
      enumerable: !0,
      get: function() {
        return _keyword.isKeyword;
      }
    }), Object.defineProperty(exports2, "isReservedWord", {
      enumerable: !0,
      get: function() {
        return _keyword.isReservedWord;
      }
    }), Object.defineProperty(exports2, "isStrictBindOnlyReservedWord", {
      enumerable: !0,
      get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
      }
    }), Object.defineProperty(exports2, "isStrictBindReservedWord", {
      enumerable: !0,
      get: function() {
        return _keyword.isStrictBindReservedWord;
      }
    }), Object.defineProperty(exports2, "isStrictReservedWord", {
      enumerable: !0,
      get: function() {
        return _keyword.isStrictReservedWord;
      }
    });
    var _identifier = require_identifier(), _keyword = require_keyword();
  }
}), require_escape_string_regexp = __commonJS({
  "node_modules/@babel/code-frame/node_modules/escape-string-regexp/index.js"(exports2, module2) {
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    module2.exports = function(str2) {
      if (typeof str2 != "string")
        throw new TypeError("Expected a string");
      return str2.replace(matchOperatorsRe, "\\$&");
    };
  }
}), require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports2, module2) {
    module2.exports = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50]
    };
  }
}), require_conversions = __commonJS({
  "node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name(), reverseKeywords = {};
    for (key2 in cssKeywords)
      cssKeywords.hasOwnProperty(key2) && (reverseKeywords[cssKeywords[key2]] = key2);
    var key2, convert = module2.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (model in convert)
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model]))
          throw new Error("missing channels property: " + model);
        if (!("labels" in convert[model]))
          throw new Error("missing channel labels property: " + model);
        if (convert[model].labels.length !== convert[model].channels)
          throw new Error("channel and label counts mismatch: " + model);
        channels = convert[model].channels, labels = convert[model].labels, delete convert[model].channels, delete convert[model].labels, Object.defineProperty(convert[model], "channels", { value: channels }), Object.defineProperty(convert[model], "labels", { value: labels });
      }
    var channels, labels, model;
    convert.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), delta = max - min, h, s, l;
      return max === min ? h = 0 : r === max ? h = (g - b) / delta : g === max ? h = 2 + (b - r) / delta : b === max && (h = 4 + (r - g) / delta), h = Math.min(h * 60, 360), h < 0 && (h += 360), l = (min + max) / 2, max === min ? s = 0 : l <= 0.5 ? s = delta / (max + min) : s = delta / (2 - max - min), [h, s * 100, l * 100];
    }, convert.rgb.hsv = function(rgb) {
      var rdif, gdif, bdif, h, s, r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, v = Math.max(r, g, b), diff = v - Math.min(r, g, b), diffc = function(c2) {
        return (v - c2) / 6 / diff + 1 / 2;
      };
      return diff === 0 ? h = s = 0 : (s = diff / v, rdif = diffc(r), gdif = diffc(g), bdif = diffc(b), r === v ? h = bdif - gdif : g === v ? h = 1 / 3 + rdif - bdif : b === v && (h = 2 / 3 + gdif - rdif), h < 0 ? h += 1 : h > 1 && (h -= 1)), [
        h * 360,
        s * 100,
        v * 100
      ];
    }, convert.rgb.hwb = function(rgb) {
      var r = rgb[0], g = rgb[1], b = rgb[2], h = convert.rgb.hsl(rgb)[0], w = 1 / 255 * Math.min(r, Math.min(g, b));
      return b = 1 - 1 / 255 * Math.max(r, Math.max(g, b)), [h, w * 100, b * 100];
    }, convert.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, c2, m, y, k;
      return k = Math.min(1 - r, 1 - g, 1 - b), c2 = (1 - r - k) / (1 - k) || 0, m = (1 - g - k) / (1 - k) || 0, y = (1 - b - k) / (1 - k) || 0, [c2 * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed)
        return reversed;
      var currentClosestDistance = 1 / 0, currentClosestKeyword;
      for (var keyword in cssKeywords)
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword], distance = comparativeDistance(rgb, value);
          distance < currentClosestDistance && (currentClosestDistance = distance, currentClosestKeyword = keyword);
        }
      return currentClosestKeyword;
    }, convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    }, convert.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92, g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92, b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805, y = r * 0.2126 + g * 0.7152 + b * 0.0722, z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    }, convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb), x = xyz[0], y = xyz[1], z = xyz[2], l, a, b;
      return x /= 95.047, y /= 100, z /= 108.883, x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116, y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116, z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116, l = 116 * y - 16, a = 500 * (x - y), b = 200 * (y - z), [l, a, b];
    }, convert.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360, s = hsl[1] / 100, l = hsl[2] / 100, t1, t2, t3, rgb, val;
      if (s === 0)
        return val = l * 255, [val, val, val];
      l < 0.5 ? t2 = l * (1 + s) : t2 = l + s - l * s, t1 = 2 * l - t2, rgb = [0, 0, 0];
      for (var i2 = 0; i2 < 3; i2++)
        t3 = h + 1 / 3 * -(i2 - 1), t3 < 0 && t3++, t3 > 1 && t3--, 6 * t3 < 1 ? val = t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? val = t2 : 3 * t3 < 2 ? val = t1 + (t2 - t1) * (2 / 3 - t3) * 6 : val = t1, rgb[i2] = val * 255;
      return rgb;
    }, convert.hsl.hsv = function(hsl) {
      var h = hsl[0], s = hsl[1] / 100, l = hsl[2] / 100, smin = s, lmin = Math.max(l, 0.01), sv, v;
      return l *= 2, s *= l <= 1 ? l : 2 - l, smin *= lmin <= 1 ? lmin : 2 - lmin, v = (l + s) / 2, sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s), [h, sv * 100, v * 100];
    }, convert.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60, s = hsv[1] / 100, v = hsv[2] / 100, hi = Math.floor(h) % 6, f = h - Math.floor(h), p = 255 * v * (1 - s), q = 255 * v * (1 - s * f), t = 255 * v * (1 - s * (1 - f));
      switch (v *= 255, hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    }, convert.hsv.hsl = function(hsv) {
      var h = hsv[0], s = hsv[1] / 100, v = hsv[2] / 100, vmin = Math.max(v, 0.01), lmin, sl, l;
      return l = (2 - s) * v, lmin = (2 - s) * vmin, sl = s * vmin, sl /= lmin <= 1 ? lmin : 2 - lmin, sl = sl || 0, l /= 2, [h, sl * 100, l * 100];
    }, convert.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360, wh = hwb[1] / 100, bl = hwb[2] / 100, ratio = wh + bl, i2, v, f, n;
      ratio > 1 && (wh /= ratio, bl /= ratio), i2 = Math.floor(6 * h), v = 1 - bl, f = 6 * h - i2, i2 & 1 && (f = 1 - f), n = wh + f * (v - wh);
      var r, g, b;
      switch (i2) {
        default:
        case 6:
        case 0:
          r = v, g = n, b = wh;
          break;
        case 1:
          r = n, g = v, b = wh;
          break;
        case 2:
          r = wh, g = v, b = n;
          break;
        case 3:
          r = wh, g = n, b = v;
          break;
        case 4:
          r = n, g = wh, b = v;
          break;
        case 5:
          r = v, g = wh, b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    }, convert.cmyk.rgb = function(cmyk) {
      var c2 = cmyk[0] / 100, m = cmyk[1] / 100, y = cmyk[2] / 100, k = cmyk[3] / 100, r, g, b;
      return r = 1 - Math.min(1, c2 * (1 - k) + k), g = 1 - Math.min(1, m * (1 - k) + k), b = 1 - Math.min(1, y * (1 - k) + k), [r * 255, g * 255, b * 255];
    }, convert.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100, y = xyz[1] / 100, z = xyz[2] / 100, r, g, b;
      return r = x * 3.2406 + y * -1.5372 + z * -0.4986, g = x * -0.9689 + y * 1.8758 + z * 0.0415, b = x * 0.0557 + y * -0.204 + z * 1.057, r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92, g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92, b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92, r = Math.min(Math.max(0, r), 1), g = Math.min(Math.max(0, g), 1), b = Math.min(Math.max(0, b), 1), [r * 255, g * 255, b * 255];
    }, convert.xyz.lab = function(xyz) {
      var x = xyz[0], y = xyz[1], z = xyz[2], l, a, b;
      return x /= 95.047, y /= 100, z /= 108.883, x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116, y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116, z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116, l = 116 * y - 16, a = 500 * (x - y), b = 200 * (y - z), [l, a, b];
    }, convert.lab.xyz = function(lab) {
      var l = lab[0], a = lab[1], b = lab[2], x, y, z;
      y = (l + 16) / 116, x = a / 500 + y, z = y - b / 200;
      var y2 = Math.pow(y, 3), x2 = Math.pow(x, 3), z2 = Math.pow(z, 3);
      return y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787, x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787, z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787, x *= 95.047, y *= 100, z *= 108.883, [x, y, z];
    }, convert.lab.lch = function(lab) {
      var l = lab[0], a = lab[1], b = lab[2], hr, h, c2;
      return hr = Math.atan2(b, a), h = hr * 360 / 2 / Math.PI, h < 0 && (h += 360), c2 = Math.sqrt(a * a + b * b), [l, c2, h];
    }, convert.lch.lab = function(lch) {
      var l = lch[0], c2 = lch[1], h = lch[2], a, b, hr;
      return hr = h / 360 * 2 * Math.PI, a = c2 * Math.cos(hr), b = c2 * Math.sin(hr), [l, a, b];
    }, convert.rgb.ansi16 = function(args) {
      var r = args[0], g = args[1], b = args[2], value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      if (value = Math.round(value / 50), value === 0)
        return 30;
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      return value === 2 && (ansi += 60), ansi;
    }, convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    }, convert.rgb.ansi256 = function(args) {
      var r = args[0], g = args[1], b = args[2];
      if (r === g && g === b)
        return r < 8 ? 16 : r > 248 ? 231 : Math.round((r - 8) / 247 * 24) + 232;
      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    }, convert.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7)
        return args > 50 && (color += 3.5), color = color / 10.5 * 255, [color, color, color];
      var mult = (~~(args > 50) + 1) * 0.5, r = (color & 1) * mult * 255, g = (color >> 1 & 1) * mult * 255, b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    }, convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c2 = (args - 232) * 10 + 8;
        return [c2, c2, c2];
      }
      args -= 16;
      var rem, r = Math.floor(args / 36) / 5 * 255, g = Math.floor((rem = args % 36) / 6) / 5 * 255, b = rem % 6 / 5 * 255;
      return [r, g, b];
    }, convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255), string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    }, convert.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match)
        return [0, 0, 0];
      var colorString = match[0];
      match[0].length === 3 && (colorString = colorString.split("").map(function(char) {
        return char + char;
      }).join(""));
      var integer = parseInt(colorString, 16), r = integer >> 16 & 255, g = integer >> 8 & 255, b = integer & 255;
      return [r, g, b];
    }, convert.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, max = Math.max(Math.max(r, g), b), min = Math.min(Math.min(r, g), b), chroma = max - min, grayscale, hue;
      return chroma < 1 ? grayscale = min / (1 - chroma) : grayscale = 0, chroma <= 0 ? hue = 0 : max === r ? hue = (g - b) / chroma % 6 : max === g ? hue = 2 + (b - r) / chroma : hue = 4 + (r - g) / chroma + 4, hue /= 6, hue %= 1, [hue * 360, chroma * 100, grayscale * 100];
    }, convert.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100, l = hsl[2] / 100, c2 = 1, f = 0;
      return l < 0.5 ? c2 = 2 * s * l : c2 = 2 * s * (1 - l), c2 < 1 && (f = (l - 0.5 * c2) / (1 - c2)), [hsl[0], c2 * 100, f * 100];
    }, convert.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100, v = hsv[2] / 100, c2 = s * v, f = 0;
      return c2 < 1 && (f = (v - c2) / (1 - c2)), [hsv[0], c2 * 100, f * 100];
    }, convert.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360, c2 = hcg[1] / 100, g = hcg[2] / 100;
      if (c2 === 0)
        return [g * 255, g * 255, g * 255];
      var pure = [0, 0, 0], hi = h % 1 * 6, v = hi % 1, w = 1 - v, mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1, pure[1] = v, pure[2] = 0;
          break;
        case 1:
          pure[0] = w, pure[1] = 1, pure[2] = 0;
          break;
        case 2:
          pure[0] = 0, pure[1] = 1, pure[2] = v;
          break;
        case 3:
          pure[0] = 0, pure[1] = w, pure[2] = 1;
          break;
        case 4:
          pure[0] = v, pure[1] = 0, pure[2] = 1;
          break;
        default:
          pure[0] = 1, pure[1] = 0, pure[2] = w;
      }
      return mg = (1 - c2) * g, [
        (c2 * pure[0] + mg) * 255,
        (c2 * pure[1] + mg) * 255,
        (c2 * pure[2] + mg) * 255
      ];
    }, convert.hcg.hsv = function(hcg) {
      var c2 = hcg[1] / 100, g = hcg[2] / 100, v = c2 + g * (1 - c2), f = 0;
      return v > 0 && (f = c2 / v), [hcg[0], f * 100, v * 100];
    }, convert.hcg.hsl = function(hcg) {
      var c2 = hcg[1] / 100, g = hcg[2] / 100, l = g * (1 - c2) + 0.5 * c2, s = 0;
      return l > 0 && l < 0.5 ? s = c2 / (2 * l) : l >= 0.5 && l < 1 && (s = c2 / (2 * (1 - l))), [hcg[0], s * 100, l * 100];
    }, convert.hcg.hwb = function(hcg) {
      var c2 = hcg[1] / 100, g = hcg[2] / 100, v = c2 + g * (1 - c2);
      return [hcg[0], (v - c2) * 100, (1 - v) * 100];
    }, convert.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100, b = hwb[2] / 100, v = 1 - b, c2 = v - w, g = 0;
      return c2 < 1 && (g = (v - c2) / (1 - c2)), [hwb[0], c2 * 100, g * 100];
    }, convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    }, convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    }, convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    }, convert.gray.hsl = convert.gray.hsv = function(args) {
      return [0, 0, args[0]];
    }, convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    }, convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    }, convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    }, convert.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255, integer = (val << 16) + (val << 8) + val, string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    }, convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
}), require_route = __commonJS({
  "node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      for (var graph = {}, models = Object.keys(conversions), len = models.length, i2 = 0; i2 < len; i2++)
        graph[models[i2]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph(), queue = [fromModel];
      for (graph[fromModel].distance = 0; queue.length; )
        for (var current = queue.pop(), adjacents = Object.keys(conversions[current]), len = adjacents.length, i2 = 0; i2 < len; i2++) {
          var adjacent = adjacents[i2], node = graph[adjacent];
          node.distance === -1 && (node.distance = graph[current].distance + 1, node.parent = current, queue.unshift(adjacent));
        }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      for (var path13 = [graph[toModel].parent, toModel], fn = conversions[graph[toModel].parent][toModel], cur = graph[toModel].parent; graph[cur].parent; )
        path13.unshift(graph[cur].parent), fn = link(conversions[graph[cur].parent][cur], fn), cur = graph[cur].parent;
      return fn.conversion = path13, fn;
    }
    module2.exports = function(fromModel) {
      for (var graph = deriveBFS(fromModel), conversion = {}, models = Object.keys(graph), len = models.length, i2 = 0; i2 < len; i2++) {
        var toModel = models[i2], node = graph[toModel];
        node.parent !== null && (conversion[toModel] = wrapConversion(toModel, graph));
      }
      return conversion;
    };
  }
}), require_color_convert = __commonJS({
  "node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions(), route = require_route(), convert = {}, models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        return args == null ? args : (arguments.length > 1 && (args = Array.prototype.slice.call(arguments)), fn(args));
      };
      return "conversion" in fn && (wrappedFn.conversion = fn.conversion), wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args == null)
          return args;
        arguments.length > 1 && (args = Array.prototype.slice.call(arguments));
        var result = fn(args);
        if (typeof result == "object")
          for (var len = result.length, i2 = 0; i2 < len; i2++)
            result[i2] = Math.round(result[i2]);
        return result;
      };
      return "conversion" in fn && (wrappedFn.conversion = fn.conversion), wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {}, Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels }), Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel), routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn), convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    }), module2.exports = convert;
  }
}), require_ansi_styles = __commonJS({
  "node_modules/@babel/code-frame/node_modules/ansi-styles/index.js"(exports2, module2) {
    var colorConvert = require_color_convert(), wrapAnsi162 = (fn, offset) => function() {
      return `\x1B[${fn.apply(colorConvert, arguments) + offset}m`;
    }, wrapAnsi2562 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset};5;${code}m`;
    }, wrapAnsi16m2 = (fn, offset) => function() {
      const rgb = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    function assembleStyles2() {
      const codes2 = /* @__PURE__ */ new Map(), styles3 = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          // Bright color
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles3.color.grey = styles3.color.gray;
      for (const groupName of Object.keys(styles3)) {
        const group2 = styles3[groupName];
        for (const styleName of Object.keys(group2)) {
          const style = group2[styleName];
          styles3[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          }, group2[styleName] = styles3[styleName], codes2.set(style[0], style[1]);
        }
        Object.defineProperty(styles3, groupName, {
          value: group2,
          enumerable: !1
        }), Object.defineProperty(styles3, "codes", {
          value: codes2,
          enumerable: !1
        });
      }
      const ansi2ansi = (n) => n, rgb2rgb = (r, g, b) => [r, g, b];
      styles3.color.close = "\x1B[39m", styles3.bgColor.close = "\x1B[49m", styles3.color.ansi = {
        ansi: wrapAnsi162(ansi2ansi, 0)
      }, styles3.color.ansi256 = {
        ansi256: wrapAnsi2562(ansi2ansi, 0)
      }, styles3.color.ansi16m = {
        rgb: wrapAnsi16m2(rgb2rgb, 0)
      }, styles3.bgColor.ansi = {
        ansi: wrapAnsi162(ansi2ansi, 10)
      }, styles3.bgColor.ansi256 = {
        ansi256: wrapAnsi2562(ansi2ansi, 10)
      }, styles3.bgColor.ansi16m = {
        rgb: wrapAnsi16m2(rgb2rgb, 10)
      };
      for (let key2 of Object.keys(colorConvert)) {
        if (typeof colorConvert[key2] != "object")
          continue;
        const suite = colorConvert[key2];
        key2 === "ansi16" && (key2 = "ansi"), "ansi16" in suite && (styles3.color.ansi[key2] = wrapAnsi162(suite.ansi16, 0), styles3.bgColor.ansi[key2] = wrapAnsi162(suite.ansi16, 10)), "ansi256" in suite && (styles3.color.ansi256[key2] = wrapAnsi2562(suite.ansi256, 0), styles3.bgColor.ansi256[key2] = wrapAnsi2562(suite.ansi256, 10)), "rgb" in suite && (styles3.color.ansi16m[key2] = wrapAnsi16m2(suite.rgb, 0), styles3.bgColor.ansi16m[key2] = wrapAnsi16m2(suite.rgb, 10));
      }
      return styles3;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: !0,
      get: assembleStyles2
    });
  }
}), require_has_flag = __commonJS({
  "node_modules/@babel/code-frame/node_modules/has-flag/index.js"(exports2, module2) {
    module2.exports = (flag, argv) => {
      argv = argv || process.argv;
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--", pos2 = argv.indexOf(prefix + flag), terminatorPos = argv.indexOf("--");
      return pos2 !== -1 && (terminatorPos === -1 ? !0 : pos2 < terminatorPos);
    };
  }
}), require_supports_color = __commonJS({
  "node_modules/@babel/code-frame/node_modules/supports-color/index.js"(exports2, module2) {
    var os2 = __require("os"), hasFlag2 = require_has_flag(), env2 = process.env, forceColor;
    hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") ? forceColor = !1 : (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) && (forceColor = !0), "FORCE_COLOR" in env2 && (forceColor = env2.FORCE_COLOR.length === 0 || parseInt(env2.FORCE_COLOR, 10) !== 0);
    function translateLevel2(level) {
      return level === 0 ? !1 : {
        level,
        hasBasic: !0,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor2(stream) {
      if (forceColor === !1)
        return 0;
      if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor"))
        return 3;
      if (hasFlag2("color=256"))
        return 2;
      if (stream && !stream.isTTY && forceColor !== !0)
        return 0;
      const min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        const osRelease = os2.release().split(".");
        return Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586 ? Number(osRelease[2]) >= 14931 ? 3 : 2 : 1;
      }
      if ("CI" in env2)
        return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign2) => sign2 in env2) || env2.CI_NAME === "codeship" ? 1 : min;
      if ("TEAMCITY_VERSION" in env2)
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      if (env2.COLORTERM === "truecolor")
        return 3;
      if ("TERM_PROGRAM" in env2) {
        const version = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      return /-256(color)?$/i.test(env2.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM) || "COLORTERM" in env2 ? 1 : (env2.TERM === "dumb", min);
    }
    function getSupportLevel(stream) {
      const level = supportsColor2(stream);
      return translateLevel2(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
}), require_templates = __commonJS({
  "node_modules/@babel/code-frame/node_modules/chalk/templates.js"(exports2, module2) {
    var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, ESCAPES = /* @__PURE__ */ new Map([
      ["n", `
`],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape(c2) {
      return c2[0] === "u" && c2.length === 5 || c2[0] === "x" && c2.length === 3 ? String.fromCharCode(parseInt(c2.slice(1), 16)) : ESCAPES.get(c2) || c2;
    }
    function parseArguments(name, args) {
      const results = [], chunks = args.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks)
        if (!isNaN(chunk))
          results.push(Number(chunk));
        else if (matches = chunk.match(STRING_REGEX))
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape2, chr) => escape2 ? unescape(escape2) : chr));
        else
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      for (; (matches = STYLE_REGEX.exec(style)) !== null; ) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else
          results.push([name]);
      }
      return results;
    }
    function buildStyle(chalk2, styles3) {
      const enabled = {};
      for (const layer of styles3)
        for (const style of layer.styles)
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
      let current = chalk2;
      for (const styleName of Object.keys(enabled))
        if (Array.isArray(enabled[styleName])) {
          if (!(styleName in current))
            throw new Error(`Unknown Chalk style: ${styleName}`);
          enabled[styleName].length > 0 ? current = current[styleName].apply(current, enabled[styleName]) : current = current[styleName];
        }
      return current;
    }
    module2.exports = (chalk2, tmp) => {
      const styles3 = [], chunks = [];
      let chunk = [];
      if (tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
        if (escapeChar)
          chunk.push(unescape(escapeChar));
        else if (style) {
          const str2 = chunk.join("");
          chunk = [], chunks.push(styles3.length === 0 ? str2 : buildStyle(chalk2, styles3)(str2)), styles3.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles3.length === 0)
            throw new Error("Found extraneous } in Chalk template literal");
          chunks.push(buildStyle(chalk2, styles3)(chunk.join(""))), chunk = [], styles3.pop();
        } else
          chunk.push(chr);
      }), chunks.push(chunk.join("")), styles3.length > 0) {
        const errMsg = `Chalk template literal is missing ${styles3.length} closing bracket${styles3.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMsg);
      }
      return chunks.join("");
    };
  }
}), require_chalk = __commonJS({
  "node_modules/@babel/code-frame/node_modules/chalk/index.js"(exports2, module2) {
    var escapeStringRegexp2 = require_escape_string_regexp(), ansiStyles2 = require_ansi_styles(), stdoutColor2 = require_supports_color().stdout, template = require_templates(), isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm"), levelMapping2 = ["ansi", "ansi", "ansi256", "ansi16m"], skipModels = /* @__PURE__ */ new Set(["gray"]), styles3 = /* @__PURE__ */ Object.create(null);
    function applyOptions2(obj, options8) {
      options8 = options8 || {};
      const scLevel = stdoutColor2 ? stdoutColor2.level : 0;
      obj.level = options8.level === void 0 ? scLevel : options8.level, obj.enabled = "enabled" in options8 ? options8.enabled : obj.level > 0;
    }
    function Chalk(options8) {
      if (!this || !(this instanceof Chalk) || this.template) {
        const chalk2 = {};
        return applyOptions2(chalk2, options8), chalk2.template = function() {
          const args = [].slice.call(arguments);
          return chalkTag.apply(null, [chalk2.template].concat(args));
        }, Object.setPrototypeOf(chalk2, Chalk.prototype), Object.setPrototypeOf(chalk2.template, chalk2), chalk2.template.constructor = Chalk, chalk2.template;
      }
      applyOptions2(this, options8);
    }
    isSimpleWindowsTerm && (ansiStyles2.blue.open = "\x1B[94m");
    for (const key2 of Object.keys(ansiStyles2))
      ansiStyles2[key2].closeRe = new RegExp(escapeStringRegexp2(ansiStyles2[key2].close), "g"), styles3[key2] = {
        get() {
          const codes2 = ansiStyles2[key2];
          return build.call(this, this._styles ? this._styles.concat(codes2) : [codes2], this._empty, key2);
        }
      };
    styles3.visible = {
      get() {
        return build.call(this, this._styles || [], !0, "visible");
      }
    }, ansiStyles2.color.closeRe = new RegExp(escapeStringRegexp2(ansiStyles2.color.close), "g");
    for (const model of Object.keys(ansiStyles2.color.ansi))
      skipModels.has(model) || (styles3[model] = {
        get() {
          const level = this.level;
          return function() {
            const codes2 = {
              open: ansiStyles2.color[levelMapping2[level]][model].apply(null, arguments),
              close: ansiStyles2.color.close,
              closeRe: ansiStyles2.color.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes2) : [codes2], this._empty, model);
          };
        }
      });
    ansiStyles2.bgColor.closeRe = new RegExp(escapeStringRegexp2(ansiStyles2.bgColor.close), "g");
    for (const model of Object.keys(ansiStyles2.bgColor.ansi)) {
      if (skipModels.has(model))
        continue;
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles3[bgModel] = {
        get() {
          const level = this.level;
          return function() {
            const codes2 = {
              open: ansiStyles2.bgColor[levelMapping2[level]][model].apply(null, arguments),
              close: ansiStyles2.bgColor.close,
              closeRe: ansiStyles2.bgColor.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes2) : [codes2], this._empty, model);
          };
        }
      };
    }
    var proto2 = Object.defineProperties(() => {
    }, styles3);
    function build(_styles, _empty, key2) {
      const builder = function() {
        return applyStyle2.apply(builder, arguments);
      };
      builder._styles = _styles, builder._empty = _empty;
      const self = this;
      return Object.defineProperty(builder, "level", {
        enumerable: !0,
        get() {
          return self.level;
        },
        set(level) {
          self.level = level;
        }
      }), Object.defineProperty(builder, "enabled", {
        enumerable: !0,
        get() {
          return self.enabled;
        },
        set(enabled) {
          self.enabled = enabled;
        }
      }), builder.hasGrey = this.hasGrey || key2 === "gray" || key2 === "grey", builder.__proto__ = proto2, builder;
    }
    function applyStyle2() {
      const args = arguments, argsLen = args.length;
      let str2 = String(arguments[0]);
      if (argsLen === 0)
        return "";
      if (argsLen > 1)
        for (let a = 1; a < argsLen; a++)
          str2 += " " + args[a];
      if (!this.enabled || this.level <= 0 || !str2)
        return this._empty ? "" : str2;
      const originalDim = ansiStyles2.dim.open;
      isSimpleWindowsTerm && this.hasGrey && (ansiStyles2.dim.open = "");
      for (const code of this._styles.slice().reverse())
        str2 = code.open + str2.replace(code.closeRe, code.open) + code.close, str2 = str2.replace(/\r?\n/g, `${code.close}$&${code.open}`);
      return ansiStyles2.dim.open = originalDim, str2;
    }
    function chalkTag(chalk2, strings) {
      if (!Array.isArray(strings))
        return [].slice.call(arguments, 1).join(" ");
      const args = [].slice.call(arguments, 2), parts = [strings.raw[0]];
      for (let i2 = 1; i2 < strings.length; i2++)
        parts.push(String(args[i2 - 1]).replace(/[{}\\]/g, "\\$&")), parts.push(String(strings.raw[i2]));
      return template(chalk2, parts.join(""));
    }
    Object.defineProperties(Chalk.prototype, styles3), module2.exports = Chalk(), module2.exports.supportsColor = stdoutColor2, module2.exports.default = module2.exports;
  }
}), require_lib2 = __commonJS({
  "node_modules/@babel/highlight/lib/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    }), exports2.default = highlight, exports2.shouldHighlight = shouldHighlight;
    var _jsTokens = require_js_tokens(), _helperValidatorIdentifier = require_lib(), _chalk = _interopRequireWildcard(require_chalk(), !0);
    function _getRequireWildcardCache(e) {
      if (typeof WeakMap != "function")
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (e === null || typeof e != "object" && typeof e != "function")
        return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if (u !== "default" && Object.prototype.hasOwnProperty.call(e, u)) {
          var i2 = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i2 && (i2.get || i2.set) ? Object.defineProperty(n, u, i2) : n[u] = e[u];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    var sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
    function getDefs(chalk2) {
      return {
        keyword: chalk2.cyan,
        capitalized: chalk2.yellow,
        jsxIdentifier: chalk2.yellow,
        punctuator: chalk2.yellow,
        number: chalk2.magenta,
        string: chalk2.green,
        regex: chalk2.magenta,
        comment: chalk2.grey,
        invalid: chalk2.white.bgRed.bold
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/, BRACKET = /^[()[\]{}]$/, tokenize;
    {
      const JSX_TAG = /^[a-z][\w-]*$/i, getTokenType = function(token2, offset, text) {
        if (token2.type === "name") {
          if ((0, _helperValidatorIdentifier.isKeyword)(token2.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token2.value, !0) || sometimesKeywords.has(token2.value))
            return "keyword";
          if (JSX_TAG.test(token2.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) == "</"))
            return "jsxIdentifier";
          if (token2.value[0] !== token2.value[0].toLowerCase())
            return "capitalized";
        }
        return token2.type === "punctuator" && BRACKET.test(token2.value) ? "bracket" : token2.type === "invalid" && (token2.value === "@" || token2.value === "#") ? "punctuator" : token2.type;
      };
      tokenize = function* (text) {
        let match;
        for (; match = _jsTokens.default.exec(text); ) {
          const token2 = _jsTokens.matchToToken(match);
          yield {
            type: getTokenType(token2, match.index, text),
            value: token2.value
          };
        }
      };
    }
    function highlightTokens(defs, text) {
      let highlighted = "";
      for (const {
        type: type2,
        value
      } of tokenize(text)) {
        const colorize = defs[type2];
        colorize ? highlighted += value.split(NEWLINE).map((str2) => colorize(str2)).join(`
`) : highlighted += value;
      }
      return highlighted;
    }
    function shouldHighlight(options8) {
      return _chalk.default.level > 0 || options8.forceColor;
    }
    var chalkWithForcedColor = void 0;
    function getChalk(forceColor) {
      if (forceColor) {
        var _chalkWithForcedColor;
        return (_chalkWithForcedColor = chalkWithForcedColor) != null || (chalkWithForcedColor = new _chalk.default.constructor({
          enabled: !0,
          level: 1
        })), chalkWithForcedColor;
      }
      return _chalk.default;
    }
    exports2.getChalk = (options8) => getChalk(options8.forceColor);
    function highlight(code, options8 = {}) {
      if (code !== "" && shouldHighlight(options8)) {
        const defs = getDefs(getChalk(options8.forceColor));
        return highlightTokens(defs, code);
      } else
        return code;
    }
  }
}), require_lib3 = __commonJS({
  "node_modules/@babel/code-frame/lib/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    }), exports2.codeFrameColumns = codeFrameColumns3, exports2.default = _default2;
    var _highlight = require_lib2(), _chalk = _interopRequireWildcard(require_chalk(), !0);
    function _getRequireWildcardCache(e) {
      if (typeof WeakMap != "function")
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (e === null || typeof e != "object" && typeof e != "function")
        return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if (u !== "default" && Object.prototype.hasOwnProperty.call(e, u)) {
          var i2 = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i2 && (i2.get || i2.set) ? Object.defineProperty(n, u, i2) : n[u] = e[u];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    var chalkWithForcedColor = void 0;
    function getChalk(forceColor) {
      if (forceColor) {
        var _chalkWithForcedColor;
        return (_chalkWithForcedColor = chalkWithForcedColor) != null || (chalkWithForcedColor = new _chalk.default.constructor({
          enabled: !0,
          level: 1
        })), chalkWithForcedColor;
      }
      return _chalk.default;
    }
    var deprecationWarningShown = !1;
    function getDefs(chalk2) {
      return {
        gutter: chalk2.grey,
        marker: chalk2.red.bold,
        message: chalk2.red.bold
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    function getMarkerLines(loc, source2, opts) {
      const startLoc = Object.assign({
        column: 0,
        line: -1
      }, loc.start), endLoc = Object.assign({}, startLoc, loc.end), {
        linesAbove = 2,
        linesBelow = 3
      } = opts || {}, startLine = startLoc.line, startColumn = startLoc.column, endLine = endLoc.line, endColumn = endLoc.column;
      let start = Math.max(startLine - (linesAbove + 1), 0), end = Math.min(source2.length, endLine + linesBelow);
      startLine === -1 && (start = 0), endLine === -1 && (end = source2.length);
      const lineDiff = endLine - startLine, markerLines = {};
      if (lineDiff)
        for (let i2 = 0; i2 <= lineDiff; i2++) {
          const lineNumber = i2 + startLine;
          if (!startColumn)
            markerLines[lineNumber] = !0;
          else if (i2 === 0) {
            const sourceLength = source2[lineNumber - 1].length;
            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
          } else if (i2 === lineDiff)
            markerLines[lineNumber] = [0, endColumn];
          else {
            const sourceLength = source2[lineNumber - i2].length;
            markerLines[lineNumber] = [0, sourceLength];
          }
        }
      else
        startColumn === endColumn ? startColumn ? markerLines[startLine] = [startColumn, 0] : markerLines[startLine] = !0 : markerLines[startLine] = [startColumn, endColumn - startColumn];
      return {
        start,
        end,
        markerLines
      };
    }
    function codeFrameColumns3(rawLines, loc, opts = {}) {
      const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts), chalk2 = getChalk(opts.forceColor), defs = getDefs(chalk2), maybeHighlight = (chalkFn, string) => highlighted ? chalkFn(string) : string, lines = rawLines.split(NEWLINE), {
        start,
        end,
        markerLines
      } = getMarkerLines(loc, lines, opts), hasColumns = loc.start && typeof loc.start.column == "number", numberMaxWidth = String(end).length;
      let frame = (highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines).split(NEWLINE, end).slice(start, end).map((line3, index) => {
        const number = start + 1 + index, gutter = ` ${` ${number}`.slice(-numberMaxWidth)} |`, hasMarker = markerLines[number], lastMarkerLine = !markerLines[number + 1];
        if (hasMarker) {
          let markerLine = "";
          if (Array.isArray(hasMarker)) {
            const markerSpacing = line3.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " "), numberOfMarkers = hasMarker[1] || 1;
            markerLine = [`
 `, maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), " ", markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join(""), lastMarkerLine && opts.message && (markerLine += " " + maybeHighlight(defs.message, opts.message));
          }
          return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line3.length > 0 ? ` ${line3}` : "", markerLine].join("");
        } else
          return ` ${maybeHighlight(defs.gutter, gutter)}${line3.length > 0 ? ` ${line3}` : ""}`;
      }).join(`
`);
      return opts.message && !hasColumns && (frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`), highlighted ? chalk2.reset(frame) : frame;
    }
    function _default2(rawLines, lineNumber, colNumber, opts = {}) {
      if (!deprecationWarningShown) {
        deprecationWarningShown = !0;
        const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
        if (process.emitWarning)
          process.emitWarning(message, "DeprecationWarning");
        else {
          const deprecationError = new Error(message);
          deprecationError.name = "DeprecationWarning", console.warn(new Error(message));
        }
      }
      return colNumber = Math.max(colNumber, 0), codeFrameColumns3(rawLines, {
        start: {
          column: colNumber,
          line: lineNumber
        }
      }, opts);
    }
  }
}), require_ignore = __commonJS({
  "node_modules/ignore/index.js"(exports2, module2) {
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var EMPTY = "", SPACE = " ", ESCAPE = "\\", REGEX_TEST_BLANK_LINE = /^\s+$/, REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/, REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/, REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/, REGEX_SPLITALL_CRLF = /\r?\n/g, REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/, SLASH = "/", TMP_KEY_IGNORE = "node-ignore";
    typeof Symbol < "u" && (TMP_KEY_IGNORE = Symbol.for("node-ignore"));
    var KEY_IGNORE = TMP_KEY_IGNORE, define = (object, key2, value) => Object.defineProperty(object, key2, { value }), REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g, RETURN_FALSE = () => !1, sanitizeRange = (range) => range.replace(
      REGEX_REGEXP_RANGE,
      (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY
    ), cleanRangeBackSlash = (slashes) => {
      const { length } = slashes;
      return slashes.slice(0, length - length % 2);
    }, REPLACERS = [
      [
        // remove BOM
        // TODO:
        // Other similar zero-width characters?
        /^\uFEFF/,
        () => EMPTY
      ],
      // > Trailing spaces are ignored unless they are quoted with backslash ("\")
      [
        // (a\ ) -> (a )
        // (a  ) -> (a)
        // (a \ ) -> (a  )
        /\\?\s+$/,
        (match) => match.indexOf("\\") === 0 ? SPACE : EMPTY
      ],
      // replace (\ ) with ' '
      [
        /\\\s/g,
        () => SPACE
      ],
      // Escape metacharacters
      // which is written down by users but means special for regular expressions.
      // > There are 12 characters with special meanings:
      // > - the backslash \,
      // > - the caret ^,
      // > - the dollar sign $,
      // > - the period or dot .,
      // > - the vertical bar or pipe symbol |,
      // > - the question mark ?,
      // > - the asterisk or star *,
      // > - the plus sign +,
      // > - the opening parenthesis (,
      // > - the closing parenthesis ),
      // > - and the opening square bracket [,
      // > - the opening curly brace {,
      // > These special characters are often called "metacharacters".
      [
        /[\\$.|*+(){^]/g,
        (match) => `\\${match}`
      ],
      [
        // > a question mark (?) matches a single character
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      // leading slash
      [
        // > A leading slash matches the beginning of the pathname.
        // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
        // A leading slash matches the beginning of the pathname
        /^\//,
        () => "^"
      ],
      // replace special metacharacter slash after the leading slash
      [
        /\//g,
        () => "\\/"
      ],
      [
        // > A leading "**" followed by a slash means match in all directories.
        // > For example, "**/foo" matches file or directory "foo" anywhere,
        // > the same as pattern "foo".
        // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
        // >   under directory "foo".
        // Notice that the '*'s have been replaced as '\\*'
        /^\^*\\\*\\\*\\\//,
        // '**/foo' <-> 'foo'
        () => "^(?:.*\\/)?"
      ],
      // starting
      [
        // there will be no leading '/'
        //   (which has been replaced by section "leading slash")
        // If starts with '**', adding a '^' to the regular expression also works
        /^(?=[^^])/,
        function() {
          return /\/(?!$)/.test(this) ? "^" : "(?:^|\\/)";
        }
      ],
      // two globstars
      [
        // Use lookahead assertions so that we could match more than one `'/**'`
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        // Zero, one or several directories
        // should not use '*', or it will be replaced by the next replacer
        // Check if it is not the last `'/**'`
        (_, index, str2) => index + 6 < str2.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      // normal intermediate wildcards
      [
        // Never replace escaped '*'
        // ignore rule '\*' will match the path '*'
        // 'abc.*/' -> go
        // 'abc.*'  -> skip this rule,
        //    coz trailing single wildcard will be handed by [trailing wildcard]
        /(^|[^\\]+)(\\\*)+(?=.+)/g,
        // '*.js' matches '.js'
        // '*.js' doesn't match 'abc'
        (_, p1, p2) => {
          const unescaped = p2.replace(/\\\*/g, "[^\\/]*");
          return p1 + unescaped;
        }
      ],
      [
        // unescape, revert step 3 except for back slash
        // For example, if a user escape a '\\*',
        // after step 3, the result will be '\\\\\\*'
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE
      ],
      [
        // '\\\\' -> '\\'
        /\\\\/g,
        () => ESCAPE
      ],
      [
        // > The range notation, e.g. [a-zA-Z],
        // > can be used to match one of the characters in a range.
        // `\` is escaped by step 3
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" && endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]"
      ],
      // ending
      [
        // 'js' will not match 'js.'
        // 'ab' will not match 'abc'
        /(?:[^*])$/,
        // WTF!
        // https://git-scm.com/docs/gitignore
        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
        // which re-fixes #24, #38
        // > If there is a separator at the end of the pattern then the pattern
        // > will only match directories, otherwise the pattern can match both
        // > files and directories.
        // 'js*' will not match 'a.js'
        // 'js/' will not match 'a.js'
        // 'js' will match 'a.js' and 'a.js/'
        (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
      ],
      // trailing wildcard
      [
        /(\^|\\\/)?\\\*$/,
        (_, p1) => `${p1 ? `${p1}[^/]+` : "[^/]*"}(?=$|\\/$)`
      ]
    ], regexCache = /* @__PURE__ */ Object.create(null), makeRegex = (pattern, ignoreCase) => {
      let source2 = regexCache[pattern];
      return source2 || (source2 = REPLACERS.reduce(
        (prev, current) => prev.replace(current[0], current[1].bind(pattern)),
        pattern
      ), regexCache[pattern] = source2), ignoreCase ? new RegExp(source2, "i") : new RegExp(source2);
    }, isString = (subject) => typeof subject == "string", checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf("#") !== 0, splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF), IgnoreRule = class {
      constructor(origin, pattern, negative, regex) {
        this.origin = origin, this.pattern = pattern, this.negative = negative, this.regex = regex;
      }
    }, createRule = (pattern, ignoreCase) => {
      const origin = pattern;
      let negative = !1;
      pattern.indexOf("!") === 0 && (negative = !0, pattern = pattern.substr(1)), pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regex = makeRegex(pattern, ignoreCase);
      return new IgnoreRule(
        origin,
        pattern,
        negative,
        regex
      );
    }, throwError2 = (message, Ctor) => {
      throw new Ctor(message);
    }, checkPath = (path13, originalPath, doThrow) => isString(path13) ? path13 ? checkPath.isNotRelative(path13) ? doThrow(
      `path should be a \`path.relative()\`d string, but got "${originalPath}"`,
      RangeError
    ) : !0 : doThrow("path must not be empty", TypeError) : doThrow(
      `path must be a string, but got \`${originalPath}\``,
      TypeError
    ), isNotRelative = (path13) => REGEX_TEST_INVALID_PATH.test(path13);
    checkPath.isNotRelative = isNotRelative, checkPath.convert = (p) => p;
    var Ignore = class {
      constructor({
        ignorecase = !0,
        ignoreCase = ignorecase,
        allowRelativePaths = !1
      } = {}) {
        define(this, KEY_IGNORE, !0), this._rules = [], this._ignoreCase = ignoreCase, this._allowRelativePaths = allowRelativePaths, this._initCache();
      }
      _initCache() {
        this._ignoreCache = /* @__PURE__ */ Object.create(null), this._testCache = /* @__PURE__ */ Object.create(null);
      }
      _addPattern(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules), this._added = !0;
          return;
        }
        if (checkPattern(pattern)) {
          const rule = createRule(pattern, this._ignoreCase);
          this._added = !0, this._rules.push(rule);
        }
      }
      // @param {Array<string> | string | Ignore} pattern
      add(pattern) {
        return this._added = !1, makeArray(
          isString(pattern) ? splitPattern(pattern) : pattern
        ).forEach(this._addPattern, this), this._added && this._initCache(), this;
      }
      // legacy
      addPattern(pattern) {
        return this.add(pattern);
      }
      //          |           ignored : unignored
      // negative |   0:0   |   0:1   |   1:0   |   1:1
      // -------- | ------- | ------- | ------- | --------
      //     0    |  TEST   |  TEST   |  SKIP   |    X
      //     1    |  TESTIF |  SKIP   |  TEST   |    X
      // - SKIP: always skip
      // - TEST: always test
      // - TESTIF: only test if checkUnignored
      // - X: that never happen
      // @param {boolean} whether should check if the path is unignored,
      //   setting `checkUnignored` to `false` could reduce additional
      //   path matching.
      // @returns {TestResult} true if a file is ignored
      _testOne(path13, checkUnignored) {
        let ignored = !1, unignored = !1;
        return this._rules.forEach((rule) => {
          const { negative } = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored)
            return;
          rule.regex.test(path13) && (ignored = !negative, unignored = negative);
        }), {
          ignored,
          unignored
        };
      }
      // @returns {TestResult}
      _test(originalPath, cache3, checkUnignored, slices) {
        const path13 = originalPath && checkPath.convert(originalPath);
        return checkPath(
          path13,
          originalPath,
          this._allowRelativePaths ? RETURN_FALSE : throwError2
        ), this._t(path13, cache3, checkUnignored, slices);
      }
      _t(path13, cache3, checkUnignored, slices) {
        if (path13 in cache3)
          return cache3[path13];
        if (slices || (slices = path13.split(SLASH)), slices.pop(), !slices.length)
          return cache3[path13] = this._testOne(path13, checkUnignored);
        const parent = this._t(
          slices.join(SLASH) + SLASH,
          cache3,
          checkUnignored,
          slices
        );
        return cache3[path13] = parent.ignored ? parent : this._testOne(path13, checkUnignored);
      }
      ignores(path13) {
        return this._test(path13, this._ignoreCache, !1).ignored;
      }
      createFilter() {
        return (path13) => !this.ignores(path13);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      // @returns {TestResult}
      test(path13) {
        return this._test(path13, this._testCache, !0);
      }
    }, factory = (options8) => new Ignore(options8), isPathValid = (path13) => checkPath(path13 && checkPath.convert(path13), path13, RETURN_FALSE);
    if (factory.isPathValid = isPathValid, factory.default = factory, module2.exports = factory, // Detect `process` so that it can run in browsers.
    typeof process < "u" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")) {
      const makePosix = (str2) => /^\\\\\?\\/.test(str2) || /["<>|\u0000-\u001F]+/u.test(str2) ? str2 : str2.replace(/\\/g, "/");
      checkPath.convert = makePosix;
      const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path13) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path13) || isNotRelative(path13);
    }
  }
}), require_readlines = __commonJS({
  "node_modules/n-readlines/readlines.js"(exports2, module2) {
    var fs7 = __require("fs"), LineByLine = class {
      constructor(file, options8) {
        options8 = options8 || {}, options8.readChunk || (options8.readChunk = 1024), options8.newLineCharacter ? options8.newLineCharacter = options8.newLineCharacter.charCodeAt(0) : options8.newLineCharacter = 10, typeof file == "number" ? this.fd = file : this.fd = fs7.openSync(file, "r"), this.options = options8, this.newLineCharacter = options8.newLineCharacter, this.reset();
      }
      _searchInBuffer(buffer2, hexNeedle) {
        let found = -1;
        for (let i2 = 0; i2 <= buffer2.length; i2++)
          if (buffer2[i2] === hexNeedle) {
            found = i2;
            break;
          }
        return found;
      }
      reset() {
        this.eofReached = !1, this.linesCache = [], this.fdPosition = 0;
      }
      close() {
        fs7.closeSync(this.fd), this.fd = null;
      }
      _extractLines(buffer2) {
        let line3;
        const lines = [];
        let bufferPosition = 0, lastNewLineBufferPosition = 0;
        for (; ; ) {
          let bufferPositionValue = buffer2[bufferPosition++];
          if (bufferPositionValue === this.newLineCharacter)
            line3 = buffer2.slice(lastNewLineBufferPosition, bufferPosition), lines.push(line3), lastNewLineBufferPosition = bufferPosition;
          else if (bufferPositionValue === void 0)
            break;
        }
        let leftovers = buffer2.slice(lastNewLineBufferPosition, bufferPosition);
        return leftovers.length && lines.push(leftovers), lines;
      }
      _readChunk(lineLeftovers) {
        let totalBytesRead = 0, bytesRead;
        const buffers = [];
        do {
          const readBuffer = Buffer.alloc(this.options.readChunk);
          bytesRead = fs7.readSync(this.fd, readBuffer, 0, this.options.readChunk, this.fdPosition), totalBytesRead = totalBytesRead + bytesRead, this.fdPosition = this.fdPosition + bytesRead, buffers.push(readBuffer);
        } while (bytesRead && this._searchInBuffer(buffers[buffers.length - 1], this.options.newLineCharacter) === -1);
        let bufferData = Buffer.concat(buffers);
        return bytesRead < this.options.readChunk && (this.eofReached = !0, bufferData = bufferData.slice(0, totalBytesRead)), totalBytesRead && (this.linesCache = this._extractLines(bufferData), lineLeftovers && (this.linesCache[0] = Buffer.concat([lineLeftovers, this.linesCache[0]]))), totalBytesRead;
      }
      next() {
        if (!this.fd)
          return !1;
        let line3 = !1;
        if (this.eofReached && this.linesCache.length === 0)
          return line3;
        let bytesRead;
        return this.linesCache.length || (bytesRead = this._readChunk()), this.linesCache.length && (line3 = this.linesCache.shift(), line3[line3.length - 1] !== this.newLineCharacter && (bytesRead = this._readChunk(line3), bytesRead && (line3 = this.linesCache.shift()))), this.eofReached && this.linesCache.length === 0 && this.close(), line3 && line3[line3.length - 1] === this.newLineCharacter && (line3 = line3.slice(0, line3.length - 1)), line3;
      }
    };
    module2.exports = LineByLine;
  }
}), require_base = __commonJS({
  "node_modules/diff/lib/diff/base.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    }), exports2.default = Diff;
    function Diff() {
    }
    Diff.prototype = {
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      diff: function(oldString, newString) {
        var options8 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, callback = options8.callback;
        typeof options8 == "function" && (callback = options8, options8 = {}), this.options = options8;
        var self = this;
        function done(value) {
          return callback ? (setTimeout(function() {
            callback(void 0, value);
          }, 0), !0) : value;
        }
        oldString = this.castInput(oldString), newString = this.castInput(newString), oldString = this.removeEmpty(this.tokenize(oldString)), newString = this.removeEmpty(this.tokenize(newString));
        var newLen = newString.length, oldLen = oldString.length, editLength = 1, maxEditLength = newLen + oldLen;
        options8.maxEditLength && (maxEditLength = Math.min(maxEditLength, options8.maxEditLength));
        var bestPath = [{
          newPos: -1,
          components: []
        }], oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
        if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen)
          return done([{
            value: this.join(newString),
            count: newString.length
          }]);
        function execEditLength() {
          for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
            var basePath = (
              /*istanbul ignore start*/
              void 0
            ), addPath = bestPath[diagonalPath - 1], removePath = bestPath[diagonalPath + 1], _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
            addPath && (bestPath[diagonalPath - 1] = void 0);
            var canAdd = addPath && addPath.newPos + 1 < newLen, canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
            if (!canAdd && !canRemove) {
              bestPath[diagonalPath] = void 0;
              continue;
            }
            if (!canAdd || canRemove && addPath.newPos < removePath.newPos ? (basePath = clonePath(removePath), self.pushComponent(basePath.components, void 0, !0)) : (basePath = addPath, basePath.newPos++, self.pushComponent(basePath.components, !0, void 0)), _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath), basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen)
              return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
            bestPath[diagonalPath] = basePath;
          }
          editLength++;
        }
        if (callback)
          (function exec() {
            setTimeout(function() {
              if (editLength > maxEditLength)
                return callback();
              execEditLength() || exec();
            }, 0);
          })();
        else
          for (; editLength <= maxEditLength; ) {
            var ret = execEditLength();
            if (ret)
              return ret;
          }
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      pushComponent: function(components, added, removed) {
        var last = components[components.length - 1];
        last && last.added === added && last.removed === removed ? components[components.length - 1] = {
          count: last.count + 1,
          added,
          removed
        } : components.push({
          count: 1,
          added,
          removed
        });
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      extractCommon: function(basePath, newString, oldString, diagonalPath) {
        for (var newLen = newString.length, oldLen = oldString.length, newPos = basePath.newPos, oldPos = newPos - diagonalPath, commonCount = 0; newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1]); )
          newPos++, oldPos++, commonCount++;
        return commonCount && basePath.components.push({
          count: commonCount
        }), basePath.newPos = newPos, oldPos;
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      equals: function(left, right) {
        return this.options.comparator ? this.options.comparator(left, right) : left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      removeEmpty: function(array2) {
        for (var ret = [], i2 = 0; i2 < array2.length; i2++)
          array2[i2] && ret.push(array2[i2]);
        return ret;
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      castInput: function(value) {
        return value;
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      tokenize: function(value) {
        return value.split("");
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      join: function(chars) {
        return chars.join("");
      }
    };
    function buildValues(diff, components, newString, oldString, useLongestToken) {
      for (var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0; componentPos < componentLen; componentPos++) {
        var component = components[componentPos];
        if (component.removed) {
          if (component.value = diff.join(oldString.slice(oldPos, oldPos + component.count)), oldPos += component.count, componentPos && components[componentPos - 1].added) {
            var tmp = components[componentPos - 1];
            components[componentPos - 1] = components[componentPos], components[componentPos] = tmp;
          }
        } else {
          if (!component.added && useLongestToken) {
            var value = newString.slice(newPos, newPos + component.count);
            value = value.map(function(value2, i2) {
              var oldValue = oldString[oldPos + i2];
              return oldValue.length > value2.length ? oldValue : value2;
            }), component.value = diff.join(value);
          } else
            component.value = diff.join(newString.slice(newPos, newPos + component.count));
          newPos += component.count, component.added || (oldPos += component.count);
        }
      }
      var lastComponent = components[componentLen - 1];
      return componentLen > 1 && typeof lastComponent.value == "string" && (lastComponent.added || lastComponent.removed) && diff.equals("", lastComponent.value) && (components[componentLen - 2].value += lastComponent.value, components.pop()), components;
    }
    function clonePath(path13) {
      return {
        newPos: path13.newPos,
        components: path13.components.slice(0)
      };
    }
  }
}), require_array2 = __commonJS({
  "node_modules/diff/lib/diff/array.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    }), exports2.diffArrays = diffArrays2, exports2.arrayDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var arrayDiff = new /*istanbul ignore start*/
    _base.default();
    exports2.arrayDiff = arrayDiff, arrayDiff.tokenize = function(value) {
      return value.slice();
    }, arrayDiff.join = arrayDiff.removeEmpty = function(value) {
      return value;
    };
    function diffArrays2(oldArr, newArr, callback) {
      return arrayDiff.diff(oldArr, newArr, callback);
    }
  }
}), src_exports = {};
__export(src_exports, {
  __debug: () => debugApis,
  __internal: () => sharedWithCli,
  check: () => check,
  clearConfigCache: () => clearCache3,
  doc: () => doc,
  format: () => format2,
  formatWithCursor: () => formatWithCursor2,
  getFileInfo: () => getFileInfo2,
  getSupportInfo: () => getSupportInfo2,
  resolveConfig: () => resolveConfig,
  resolveConfigFile: () => resolveConfigFile,
  util: () => public_exports,
  version: () => version_evaluate_default
});
var import_fast_glob = __toESM(require_out4(), 1), apiDescriptor = {
  key: (key2) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(key2) ? key2 : JSON.stringify(key2),
  value(value) {
    if (value === null || typeof value != "object")
      return JSON.stringify(value);
    if (Array.isArray(value))
      return `[${value.map((subValue) => apiDescriptor.value(subValue)).join(", ")}]`;
    const keys = Object.keys(value);
    return keys.length === 0 ? "{}" : `{ ${keys.map((key2) => `${apiDescriptor.key(key2)}: ${apiDescriptor.value(value[key2])}`).join(", ")} }`;
  },
  pair: ({ key: key2, value }) => apiDescriptor.value({ [key2]: value })
}, ANSI_BACKGROUND_OFFSET = 10, wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`, wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`, wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`, styles = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
function assembleStyles() {
  const codes2 = /* @__PURE__ */ new Map();
  for (const [groupName, group2] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group2))
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      }, group2[styleName] = styles[styleName], codes2.set(style[0], style[1]);
    Object.defineProperty(styles, groupName, {
      value: group2,
      enumerable: !1
    });
  }
  return Object.defineProperty(styles, "codes", {
    value: codes2,
    enumerable: !1
  }), styles.color.close = "\x1B[39m", styles.bgColor.close = "\x1B[49m", styles.color.ansi = wrapAnsi16(), styles.color.ansi256 = wrapAnsi256(), styles.color.ansi16m = wrapAnsi16m(), styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET), styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET), styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET), Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        return red === green && green === blue ? red < 8 ? 16 : red > 248 ? 231 : Math.round((red - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: !1
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches)
          return [0, 0, 0];
        let [colorString] = matches;
        colorString.length === 3 && (colorString = [...colorString].map((character) => character + character).join(""));
        const integer = Number.parseInt(colorString, 16);
        return [
          /* eslint-disable no-bitwise */
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: !1
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: !1
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8)
          return 30 + code;
        if (code < 16)
          return 90 + (code - 8);
        let red, green, blue;
        if (code >= 232)
          red = ((code - 232) * 10 + 8) / 255, green = red, blue = red;
        else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5, green = Math.floor(remainder / 6) / 5, blue = remainder % 6 / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0)
          return 30;
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        return value === 2 && (result += 60), result;
      },
      enumerable: !1
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: !1
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: !1
    }
  }), styles;
}
var ansiStyles = assembleStyles(), ansi_styles_default = ansiStyles;
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : process3__default.default.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--", position = argv.indexOf(prefix + flag), terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
var { env } = process3__default.default, flagForceColor;
hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never") ? flagForceColor = 0 : (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) && (flagForceColor = 1);
function envForceColor() {
  if ("FORCE_COLOR" in env)
    return env.FORCE_COLOR === "true" ? 1 : env.FORCE_COLOR === "false" ? 0 : env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
}
function translateLevel(level) {
  return level === 0 ? !1 : {
    level,
    hasBasic: !0,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = !0 } = {}) {
  const noFlagForceColor = envForceColor();
  noFlagForceColor !== void 0 && (flagForceColor = noFlagForceColor);
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0)
    return 0;
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor"))
      return 3;
    if (hasFlag("color=256"))
      return 2;
  }
  if ("TF_BUILD" in env && "AGENT_NAME" in env)
    return 1;
  if (haveStream && !streamIsTTY && forceColor === void 0)
    return 0;
  const min = forceColor || 0;
  if (env.TERM === "dumb")
    return min;
  if (process3__default.default.platform === "win32") {
    const osRelease = require$$0__default.default.release().split(".");
    return Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586 ? Number(osRelease[2]) >= 14931 ? 3 : 2 : 1;
  }
  if ("CI" in env)
    return "GITHUB_ACTIONS" in env || "GITEA_ACTIONS" in env ? 3 : ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign2) => sign2 in env) || env.CI_NAME === "codeship" ? 1 : min;
  if ("TEAMCITY_VERSION" in env)
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  if (env.COLORTERM === "truecolor" || env.TERM === "xterm-kitty")
    return 3;
  if ("TERM_PROGRAM" in env) {
    const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app":
        return version >= 3 ? 3 : 2;
      case "Apple_Terminal":
        return 2;
    }
  }
  return /-256(color)?$/i.test(env.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM) || "COLORTERM" in env ? 1 : min;
}
function createSupportsColor(stream, options8 = {}) {
  const level = _supportsColor(stream, {
    streamIsTTY: stream && stream.isTTY,
    ...options8
  });
  return translateLevel(level);
}
var supportsColor = {
  stdout: createSupportsColor({ isTTY: tty__default.default.isatty(1) }),
  stderr: createSupportsColor({ isTTY: tty__default.default.isatty(2) })
}, supports_color_default = supportsColor;
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1)
    return string;
  const substringLength = substring.length;
  let endIndex = 0, returnValue = "";
  do
    returnValue += string.slice(endIndex, index) + substring + replacer, endIndex = index + substringLength, index = string.indexOf(substring, endIndex);
  while (index !== -1);
  return returnValue += string.slice(endIndex), returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0, returnValue = "";
  do {
    const gotCR = string[index - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? `\r
` : `
`) + postfix, endIndex = index + 1, index = string.indexOf(`
`, endIndex);
  } while (index !== -1);
  return returnValue += string.slice(endIndex), returnValue;
}
var { stdout: stdoutColor, stderr: stderrColor } = supports_color_default, GENERATOR = Symbol("GENERATOR"), STYLER = Symbol("STYLER"), IS_EMPTY = Symbol("IS_EMPTY"), levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
], styles2 = /* @__PURE__ */ Object.create(null), applyOptions = (object, options8 = {}) => {
  if (options8.level && !(Number.isInteger(options8.level) && options8.level >= 0 && options8.level <= 3))
    throw new Error("The `level` option should be an integer from 0 to 3");
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options8.level === void 0 ? colorLevel : options8.level;
}, chalkFactory = (options8) => {
  const chalk2 = (...strings) => strings.join(" ");
  return applyOptions(chalk2, options8), Object.setPrototypeOf(chalk2, createChalk.prototype), chalk2;
};
function createChalk(options8) {
  return chalkFactory(options8);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default))
  styles2[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      return Object.defineProperty(this, styleName, { value: builder }), builder;
    }
  };
styles2.visible = {
  get() {
    const builder = createBuilder(this, this[STYLER], !0);
    return Object.defineProperty(this, "visible", { value: builder }), builder;
  }
};
var getModelAnsi = (model, level, type2, ...arguments_) => model === "rgb" ? level === "ansi16m" ? ansi_styles_default[type2].ansi16m(...arguments_) : level === "ansi256" ? ansi_styles_default[type2].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_)) : ansi_styles_default[type2].ansi(ansi_styles_default.rgbToAnsi(...arguments_)) : model === "hex" ? getModelAnsi("rgb", level, type2, ...ansi_styles_default.hexToRgb(...arguments_)) : ansi_styles_default[type2][model](...arguments_), usedModels = ["rgb", "hex", "ansi256"];
for (const model of usedModels) {
  styles2[model] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles2[bgModel] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
}
var proto = Object.defineProperties(() => {
}, {
  ...styles2,
  level: {
    enumerable: !0,
    get() {
      return this[GENERATOR].level;
    },
    set(level) {
      this[GENERATOR].level = level;
    }
  }
}), createStyler = (open, close, parent) => {
  let openAll, closeAll;
  return parent === void 0 ? (openAll = open, closeAll = close) : (openAll = parent.openAll + open, closeAll = close + parent.closeAll), {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
}, createBuilder = (self, _styler, _isEmpty) => {
  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  return Object.setPrototypeOf(builder, proto), builder[GENERATOR] = self, builder[STYLER] = _styler, builder[IS_EMPTY] = _isEmpty, builder;
}, applyStyle = (self, string) => {
  if (self.level <= 0 || !string)
    return self[IS_EMPTY] ? "" : string;
  let styler = self[STYLER];
  if (styler === void 0)
    return string;
  const { openAll, closeAll } = styler;
  if (string.includes("\x1B"))
    for (; styler !== void 0; )
      string = stringReplaceAll(string, styler.close, styler.open), styler = styler.parent;
  const lfIndex = string.indexOf(`
`);
  return lfIndex !== -1 && (string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex)), openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles2);
var chalk = createChalk();
createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk, commonDeprecatedHandler = (keyOrPair, redirectTo, { descriptor }) => {
  const messages2 = [
    `${source_default.yellow(typeof keyOrPair == "string" ? descriptor.key(keyOrPair) : descriptor.pair(keyOrPair))} is deprecated`
  ];
  return redirectTo && messages2.push(`we now treat it as ${source_default.blue(typeof redirectTo == "string" ? descriptor.key(redirectTo) : descriptor.pair(redirectTo))}`), messages2.join("; ") + ".";
}, VALUE_NOT_EXIST = Symbol.for("vnopts.VALUE_NOT_EXIST"), VALUE_UNCHANGED = Symbol.for("vnopts.VALUE_UNCHANGED"), INDENTATION = " ".repeat(2), commonInvalidHandler = (key2, value, utils2) => {
  const { text, list } = utils2.normalizeExpectedResult(utils2.schemas[key2].expected(utils2)), descriptions = [];
  return text && descriptions.push(getDescription(key2, value, text, utils2.descriptor)), list && descriptions.push([getDescription(key2, value, list.title, utils2.descriptor)].concat(list.values.map((valueDescription) => getListDescription(valueDescription, utils2.loggerPrintWidth))).join(`
`)), chooseDescription(descriptions, utils2.loggerPrintWidth);
};
function getDescription(key2, value, expected, descriptor) {
  return [
    `Invalid ${source_default.red(descriptor.key(key2))} value.`,
    `Expected ${source_default.blue(expected)},`,
    `but received ${value === VALUE_NOT_EXIST ? source_default.gray("nothing") : source_default.red(descriptor.value(value))}.`
  ].join(" ");
}
function getListDescription({ text, list }, printWidth) {
  const descriptions = [];
  return text && descriptions.push(`- ${source_default.blue(text)}`), list && descriptions.push([`- ${source_default.blue(list.title)}:`].concat(list.values.map((valueDescription) => getListDescription(valueDescription, printWidth - INDENTATION.length).replace(/^|\n/g, `$&${INDENTATION}`))).join(`
`)), chooseDescription(descriptions, printWidth);
}
function chooseDescription(descriptions, printWidth) {
  if (descriptions.length === 1)
    return descriptions[0];
  const [firstDescription, secondDescription] = descriptions, [firstWidth, secondWidth] = descriptions.map((description) => description.split(`
`, 1)[0].length);
  return firstWidth > printWidth && firstWidth > secondWidth ? secondDescription : firstDescription;
}
var array = [], characterCodeCache = [];
function leven(first, second) {
  if (first === second)
    return 0;
  const swap = first;
  first.length > second.length && (first = second, second = swap);
  let firstLength = first.length, secondLength = second.length;
  for (; firstLength > 0 && first.charCodeAt(~-firstLength) === second.charCodeAt(~-secondLength); )
    firstLength--, secondLength--;
  let start = 0;
  for (; start < firstLength && first.charCodeAt(start) === second.charCodeAt(start); )
    start++;
  if (firstLength -= start, secondLength -= start, firstLength === 0)
    return secondLength;
  let bCharacterCode, result, temporary, temporary2, index = 0, index2 = 0;
  for (; index < firstLength; )
    characterCodeCache[index] = first.charCodeAt(start + index), array[index] = ++index;
  for (; index2 < secondLength; )
    for (bCharacterCode = second.charCodeAt(start + index2), temporary = index2++, result = index2, index = 0; index < firstLength; index++)
      temporary2 = bCharacterCode === characterCodeCache[index] ? temporary : temporary + 1, temporary = array[index], result = array[index] = temporary > result ? temporary2 > result ? result + 1 : temporary2 : temporary2 > temporary ? temporary + 1 : temporary2;
  return result;
}
var levenUnknownHandler = (key2, value, { descriptor, logger, schemas }) => {
  const messages2 = [
    `Ignored unknown option ${source_default.yellow(descriptor.pair({ key: key2, value }))}.`
  ], suggestion = Object.keys(schemas).sort().find((knownKey) => leven(key2, knownKey) < 3);
  suggestion && messages2.push(`Did you mean ${source_default.blue(descriptor.key(suggestion))}?`), logger.warn(messages2.join(" "));
}, HANDLER_KEYS = [
  "default",
  "expected",
  "validate",
  "deprecated",
  "forward",
  "redirect",
  "overlap",
  "preprocess",
  "postprocess"
];
function createSchema(SchemaConstructor, parameters) {
  const schema2 = new SchemaConstructor(parameters), subSchema = Object.create(schema2);
  for (const handlerKey of HANDLER_KEYS)
    handlerKey in parameters && (subSchema[handlerKey] = normalizeHandler(parameters[handlerKey], schema2, Schema.prototype[handlerKey].length));
  return subSchema;
}
var Schema = class {
  static create(parameters) {
    return createSchema(this, parameters);
  }
  constructor(parameters) {
    this.name = parameters.name;
  }
  default(_utils) {
  }
  // this is actually an abstract method but we need a placeholder to get `function.length`
  /* c8 ignore start */
  expected(_utils) {
    return "nothing";
  }
  /* c8 ignore stop */
  // this is actually an abstract method but we need a placeholder to get `function.length`
  /* c8 ignore start */
  validate(_value, _utils) {
    return !1;
  }
  /* c8 ignore stop */
  deprecated(_value, _utils) {
    return !1;
  }
  forward(_value, _utils) {
  }
  redirect(_value, _utils) {
  }
  overlap(currentValue, _newValue, _utils) {
    return currentValue;
  }
  preprocess(value, _utils) {
    return value;
  }
  postprocess(_value, _utils) {
    return VALUE_UNCHANGED;
  }
};
function normalizeHandler(handler, superSchema, handlerArgumentsLength) {
  return typeof handler == "function" ? (...args) => handler(...args.slice(0, handlerArgumentsLength - 1), superSchema, ...args.slice(handlerArgumentsLength - 1)) : () => handler;
}
var AliasSchema = class extends Schema {
  constructor(parameters) {
    super(parameters), this._sourceName = parameters.sourceName;
  }
  expected(utils2) {
    return utils2.schemas[this._sourceName].expected(utils2);
  }
  validate(value, utils2) {
    return utils2.schemas[this._sourceName].validate(value, utils2);
  }
  redirect(_value, _utils) {
    return this._sourceName;
  }
}, AnySchema = class extends Schema {
  expected() {
    return "anything";
  }
  validate() {
    return !0;
  }
}, ArraySchema = class extends Schema {
  constructor({ valueSchema, name = valueSchema.name, ...handlers }) {
    super({ ...handlers, name }), this._valueSchema = valueSchema;
  }
  expected(utils2) {
    const { text, list } = utils2.normalizeExpectedResult(this._valueSchema.expected(utils2));
    return {
      text: text && `an array of ${text}`,
      list: list && {
        title: "an array of the following values",
        values: [{ list }]
      }
    };
  }
  validate(value, utils2) {
    if (!Array.isArray(value))
      return !1;
    const invalidValues = [];
    for (const subValue of value) {
      const subValidateResult = utils2.normalizeValidateResult(this._valueSchema.validate(subValue, utils2), subValue);
      subValidateResult !== !0 && invalidValues.push(subValidateResult.value);
    }
    return invalidValues.length === 0 ? !0 : { value: invalidValues };
  }
  deprecated(value, utils2) {
    const deprecatedResult = [];
    for (const subValue of value) {
      const subDeprecatedResult = utils2.normalizeDeprecatedResult(this._valueSchema.deprecated(subValue, utils2), subValue);
      subDeprecatedResult !== !1 && deprecatedResult.push(...subDeprecatedResult.map(({ value: deprecatedValue }) => ({
        value: [deprecatedValue]
      })));
    }
    return deprecatedResult;
  }
  forward(value, utils2) {
    const forwardResult = [];
    for (const subValue of value) {
      const subForwardResult = utils2.normalizeForwardResult(this._valueSchema.forward(subValue, utils2), subValue);
      forwardResult.push(...subForwardResult.map(wrapTransferResult));
    }
    return forwardResult;
  }
  redirect(value, utils2) {
    const remain = [], redirect = [];
    for (const subValue of value) {
      const subRedirectResult = utils2.normalizeRedirectResult(this._valueSchema.redirect(subValue, utils2), subValue);
      "remain" in subRedirectResult && remain.push(subRedirectResult.remain), redirect.push(...subRedirectResult.redirect.map(wrapTransferResult));
    }
    return remain.length === 0 ? { redirect } : { redirect, remain };
  }
  overlap(currentValue, newValue) {
    return currentValue.concat(newValue);
  }
};
function wrapTransferResult({ from, to }) {
  return { from: [from], to };
}
var BooleanSchema = class extends Schema {
  expected() {
    return "true or false";
  }
  validate(value) {
    return typeof value == "boolean";
  }
};
function recordFromArray(array2, mainKey) {
  const record = /* @__PURE__ */ Object.create(null);
  for (const value of array2) {
    const key2 = value[mainKey];
    if (record[key2])
      throw new Error(`Duplicate ${mainKey} ${JSON.stringify(key2)}`);
    record[key2] = value;
  }
  return record;
}
function mapFromArray(array2, mainKey) {
  const map2 = /* @__PURE__ */ new Map();
  for (const value of array2) {
    const key2 = value[mainKey];
    if (map2.has(key2))
      throw new Error(`Duplicate ${mainKey} ${JSON.stringify(key2)}`);
    map2.set(key2, value);
  }
  return map2;
}
function createAutoChecklist() {
  const map2 = /* @__PURE__ */ Object.create(null);
  return (id) => {
    const idString = JSON.stringify(id);
    return map2[idString] ? !0 : (map2[idString] = !0, !1);
  };
}
function partition(array2, predicate) {
  const trueArray = [], falseArray = [];
  for (const value of array2)
    predicate(value) ? trueArray.push(value) : falseArray.push(value);
  return [trueArray, falseArray];
}
function isInt(value) {
  return value === Math.floor(value);
}
function comparePrimitive(a, b) {
  if (a === b)
    return 0;
  const typeofA = typeof a, typeofB = typeof b, orders = [
    "undefined",
    "object",
    "boolean",
    "number",
    "string"
  ];
  return typeofA !== typeofB ? orders.indexOf(typeofA) - orders.indexOf(typeofB) : typeofA !== "string" ? Number(a) - Number(b) : a.localeCompare(b);
}
function normalizeInvalidHandler(invalidHandler) {
  return (...args) => {
    const errorMessageOrError = invalidHandler(...args);
    return typeof errorMessageOrError == "string" ? new Error(errorMessageOrError) : errorMessageOrError;
  };
}
function normalizeDefaultResult(result) {
  return result === void 0 ? {} : result;
}
function normalizeExpectedResult(result) {
  if (typeof result == "string")
    return { text: result };
  const { text, list } = result;
  return assert((text || list) !== void 0, "Unexpected `expected` result, there should be at least one field."), list ? {
    text,
    list: {
      title: list.title,
      values: list.values.map(normalizeExpectedResult)
    }
  } : { text };
}
function normalizeValidateResult(result, value) {
  return result === !0 ? !0 : result === !1 ? { value } : result;
}
function normalizeDeprecatedResult(result, value, doNotNormalizeTrue = !1) {
  return result === !1 ? !1 : result === !0 ? doNotNormalizeTrue ? !0 : [{ value }] : "value" in result ? [result] : result.length === 0 ? !1 : result;
}
function normalizeTransferResult(result, value) {
  return typeof result == "string" || "key" in result ? { from: value, to: result } : "from" in result ? { from: result.from, to: result.to } : { from: value, to: result.to };
}
function normalizeForwardResult(result, value) {
  return result === void 0 ? [] : Array.isArray(result) ? result.map((transferResult) => normalizeTransferResult(transferResult, value)) : [normalizeTransferResult(result, value)];
}
function normalizeRedirectResult(result, value) {
  const redirect = normalizeForwardResult(typeof result == "object" && "redirect" in result ? result.redirect : result, value);
  return redirect.length === 0 ? { remain: value, redirect } : typeof result == "object" && "remain" in result ? { remain: result.remain, redirect } : { redirect };
}
function assert(isValid, message) {
  if (!isValid)
    throw new Error(message);
}
var ChoiceSchema = class extends Schema {
  constructor(parameters) {
    super(parameters), this._choices = mapFromArray(parameters.choices.map((choice) => choice && typeof choice == "object" ? choice : { value: choice }), "value");
  }
  expected({ descriptor }) {
    const choiceDescriptions = Array.from(this._choices.keys()).map((value) => this._choices.get(value)).filter(({ hidden }) => !hidden).map((choiceInfo) => choiceInfo.value).sort(comparePrimitive).map(descriptor.value), head = choiceDescriptions.slice(0, -2), tail = choiceDescriptions.slice(-2);
    return {
      text: head.concat(tail.join(" or ")).join(", "),
      list: {
        title: "one of the following values",
        values: choiceDescriptions
      }
    };
  }
  validate(value) {
    return this._choices.has(value);
  }
  deprecated(value) {
    const choiceInfo = this._choices.get(value);
    return choiceInfo && choiceInfo.deprecated ? { value } : !1;
  }
  forward(value) {
    const choiceInfo = this._choices.get(value);
    return choiceInfo ? choiceInfo.forward : void 0;
  }
  redirect(value) {
    const choiceInfo = this._choices.get(value);
    return choiceInfo ? choiceInfo.redirect : void 0;
  }
}, NumberSchema = class extends Schema {
  expected() {
    return "a number";
  }
  validate(value, _utils) {
    return typeof value == "number";
  }
}, IntegerSchema = class extends NumberSchema {
  expected() {
    return "an integer";
  }
  validate(value, utils2) {
    return utils2.normalizeValidateResult(super.validate(value, utils2), value) === !0 && isInt(value);
  }
}, StringSchema = class extends Schema {
  expected() {
    return "a string";
  }
  validate(value) {
    return typeof value == "string";
  }
}, defaultDescriptor = apiDescriptor, defaultUnknownHandler = levenUnknownHandler, defaultInvalidHandler = commonInvalidHandler, defaultDeprecatedHandler = commonDeprecatedHandler, Normalizer = class {
  constructor(schemas, opts) {
    const { logger = console, loggerPrintWidth = 80, descriptor = defaultDescriptor, unknown = defaultUnknownHandler, invalid = defaultInvalidHandler, deprecated = defaultDeprecatedHandler, missing = () => !1, required = () => !1, preprocess = (x) => x, postprocess = () => VALUE_UNCHANGED } = opts || {};
    this._utils = {
      descriptor,
      logger: (
        /* c8 ignore next */
        logger || { warn: () => {
        } }
      ),
      loggerPrintWidth,
      schemas: recordFromArray(schemas, "name"),
      normalizeDefaultResult,
      normalizeExpectedResult,
      normalizeDeprecatedResult,
      normalizeForwardResult,
      normalizeRedirectResult,
      normalizeValidateResult
    }, this._unknownHandler = unknown, this._invalidHandler = normalizeInvalidHandler(invalid), this._deprecatedHandler = deprecated, this._identifyMissing = (k, o) => !(k in o) || missing(k, o), this._identifyRequired = required, this._preprocess = preprocess, this._postprocess = postprocess, this.cleanHistory();
  }
  cleanHistory() {
    this._hasDeprecationWarned = createAutoChecklist();
  }
  normalize(options8) {
    const newOptions = {}, restOptionsArray = [this._preprocess(options8, this._utils)], applyNormalization = () => {
      for (; restOptionsArray.length !== 0; ) {
        const currentOptions = restOptionsArray.shift(), transferredOptionsArray = this._applyNormalization(currentOptions, newOptions);
        restOptionsArray.push(...transferredOptionsArray);
      }
    };
    applyNormalization();
    for (const key2 of Object.keys(this._utils.schemas)) {
      const schema2 = this._utils.schemas[key2];
      if (!(key2 in newOptions)) {
        const defaultResult = normalizeDefaultResult(schema2.default(this._utils));
        "value" in defaultResult && restOptionsArray.push({ [key2]: defaultResult.value });
      }
    }
    applyNormalization();
    for (const key2 of Object.keys(this._utils.schemas)) {
      if (!(key2 in newOptions))
        continue;
      const schema2 = this._utils.schemas[key2], value = newOptions[key2], newValue = schema2.postprocess(value, this._utils);
      newValue !== VALUE_UNCHANGED && (this._applyValidation(newValue, key2, schema2), newOptions[key2] = newValue);
    }
    return this._applyPostprocess(newOptions), this._applyRequiredCheck(newOptions), newOptions;
  }
  _applyNormalization(options8, newOptions) {
    const transferredOptionsArray = [], { knownKeys, unknownKeys } = this._partitionOptionKeys(options8);
    for (const key2 of knownKeys) {
      const schema2 = this._utils.schemas[key2], value = schema2.preprocess(options8[key2], this._utils);
      this._applyValidation(value, key2, schema2);
      const appendTransferredOptions = ({ from, to }) => {
        transferredOptionsArray.push(typeof to == "string" ? { [to]: from } : { [to.key]: to.value });
      }, warnDeprecated = ({ value: currentValue, redirectTo }) => {
        const deprecatedResult = normalizeDeprecatedResult(
          schema2.deprecated(currentValue, this._utils),
          value,
          /* doNotNormalizeTrue */
          !0
        );
        if (deprecatedResult !== !1)
          if (deprecatedResult === !0)
            this._hasDeprecationWarned(key2) || this._utils.logger.warn(this._deprecatedHandler(key2, redirectTo, this._utils));
          else
            for (const { value: deprecatedValue } of deprecatedResult) {
              const pair = { key: key2, value: deprecatedValue };
              if (!this._hasDeprecationWarned(pair)) {
                const redirectToPair = typeof redirectTo == "string" ? { key: redirectTo, value: deprecatedValue } : redirectTo;
                this._utils.logger.warn(this._deprecatedHandler(pair, redirectToPair, this._utils));
              }
            }
      };
      normalizeForwardResult(schema2.forward(value, this._utils), value).forEach(appendTransferredOptions);
      const redirectResult = normalizeRedirectResult(schema2.redirect(value, this._utils), value);
      if (redirectResult.redirect.forEach(appendTransferredOptions), "remain" in redirectResult) {
        const remainingValue = redirectResult.remain;
        newOptions[key2] = key2 in newOptions ? schema2.overlap(newOptions[key2], remainingValue, this._utils) : remainingValue, warnDeprecated({ value: remainingValue });
      }
      for (const { from, to } of redirectResult.redirect)
        warnDeprecated({ value: from, redirectTo: to });
    }
    for (const key2 of unknownKeys) {
      const value = options8[key2];
      this._applyUnknownHandler(key2, value, newOptions, (knownResultKey, knownResultValue) => {
        transferredOptionsArray.push({ [knownResultKey]: knownResultValue });
      });
    }
    return transferredOptionsArray;
  }
  _applyRequiredCheck(options8) {
    for (const key2 of Object.keys(this._utils.schemas))
      if (this._identifyMissing(key2, options8) && this._identifyRequired(key2))
        throw this._invalidHandler(key2, VALUE_NOT_EXIST, this._utils);
  }
  _partitionOptionKeys(options8) {
    const [knownKeys, unknownKeys] = partition(Object.keys(options8).filter((key2) => !this._identifyMissing(key2, options8)), (key2) => key2 in this._utils.schemas);
    return { knownKeys, unknownKeys };
  }
  _applyValidation(value, key2, schema2) {
    const validateResult = normalizeValidateResult(schema2.validate(value, this._utils), value);
    if (validateResult !== !0)
      throw this._invalidHandler(key2, validateResult.value, this._utils);
  }
  _applyUnknownHandler(key2, value, newOptions, knownResultHandler) {
    const unknownResult = this._unknownHandler(key2, value, this._utils);
    if (unknownResult)
      for (const resultKey of Object.keys(unknownResult)) {
        if (this._identifyMissing(resultKey, unknownResult))
          continue;
        const resultValue = unknownResult[resultKey];
        resultKey in this._utils.schemas ? knownResultHandler(resultKey, resultValue) : newOptions[resultKey] = resultValue;
      }
  }
  _applyPostprocess(options8) {
    const postprocessed = this._postprocess(options8, this._utils);
    if (postprocessed !== VALUE_UNCHANGED) {
      if (postprocessed.delete)
        for (const deleteKey of postprocessed.delete)
          delete options8[deleteKey];
      if (postprocessed.override) {
        const { knownKeys, unknownKeys } = this._partitionOptionKeys(postprocessed.override);
        for (const key2 of knownKeys) {
          const value = postprocessed.override[key2];
          this._applyValidation(value, key2, this._utils.schemas[key2]), options8[key2] = value;
        }
        for (const key2 of unknownKeys) {
          const value = postprocessed.override[key2];
          this._applyUnknownHandler(key2, value, options8, (knownResultKey, knownResultValue) => {
            const schema2 = this._utils.schemas[knownResultKey];
            this._applyValidation(knownResultValue, knownResultKey, schema2), options8[knownResultKey] = knownResultValue;
          });
        }
      }
    }
  }
}, errors_exports = {};
__export(errors_exports, {
  ArgExpansionBailout: () => ArgExpansionBailout,
  ConfigError: () => ConfigError,
  UndefinedParserError: () => UndefinedParserError
});
var ConfigError = class extends Error {
  name = "ConfigError";
}, UndefinedParserError = class extends Error {
  name = "UndefinedParserError";
}, ArgExpansionBailout = class extends Error {
  name = "ArgExpansionBailout";
}, import_micromatch = __toESM(require_micromatch(), 1), isUrlInstance = (value) => value instanceof URL, isUrlString = (value) => typeof value == "string" && value.startsWith("file://"), isUrl = (urlOrPath) => isUrlInstance(urlOrPath) || isUrlString(urlOrPath), toPath = (urlOrPath) => isUrl(urlOrPath) ? require$$0.fileURLToPath(urlOrPath) : urlOrPath;
function partition2(array2, predicate) {
  const result = [[], []];
  for (const value of array2)
    result[predicate(value) ? 0 : 1].push(value);
  return result;
}
var partition_default = partition2, import_editorconfig = __toESM(require_src(), 1);
async function isDirectory(directory, options8) {
  const allowSymlinks = options8?.allowSymlinks ?? !0;
  let stats;
  try {
    stats = await (allowSymlinks ? fs__default.default.stat : fs__default.default.lstat)(toPath(directory));
  } catch {
    return !1;
  }
  return stats.isDirectory();
}
var is_directory_default = isDirectory, toAbsolutePath = (value) => path__namespace.resolve(toPath(value));
function* iterateDirectoryUp(from, to) {
  from = toAbsolutePath(from);
  const { root: root2 } = path__namespace.parse(from);
  if (to = to ? toAbsolutePath(to) : root2, !(from !== to && !from.startsWith(to))) {
    for (let directory = from; directory !== to; directory = path__namespace.dirname(directory))
      yield directory;
    yield to;
  }
}
var iterate_directory_up_default = iterateDirectoryUp, _names, _filter, _stopDirectory, _cache, _searchInDirectory, searchInDirectory_fn, Searcher = class {
  /**
   * @param {{
   *   names: string[],
   *   filter: (fileOrDirectory: {name: string, path: string}) => Promise<boolean>,
   *   stopDirectory?: string,
   * }} param0
   */
  constructor({ names, filter: filter2, stopDirectory }) {
    __privateAdd(this, _searchInDirectory), __privateAdd(this, _names, void 0), __privateAdd(this, _filter, void 0), __privateAdd(this, _stopDirectory, void 0), __privateAdd(this, _cache, /* @__PURE__ */ new Map()), __privateSet(this, _names, names), __privateSet(this, _filter, filter2), __privateSet(this, _stopDirectory, stopDirectory);
  }
  async search(startDirectory, { shouldCache }) {
    const cache3 = __privateGet(this, _cache);
    if (shouldCache && cache3.has(startDirectory))
      return cache3.get(startDirectory);
    const searchedDirectories = [];
    let result;
    for (const directory of iterate_directory_up_default(
      startDirectory,
      __privateGet(this, _stopDirectory)
    ))
      if (searchedDirectories.push(directory), result = await __privateMethod(this, _searchInDirectory, searchInDirectory_fn).call(this, directory, shouldCache), result)
        break;
    for (const directory of searchedDirectories)
      cache3.set(directory, result);
    return result;
  }
  clearCache() {
    __privateGet(this, _cache).clear();
  }
};
_names = /* @__PURE__ */ new WeakMap();
_filter = /* @__PURE__ */ new WeakMap();
_stopDirectory = /* @__PURE__ */ new WeakMap();
_cache = /* @__PURE__ */ new WeakMap();
_searchInDirectory = /* @__PURE__ */ new WeakSet();
searchInDirectory_fn = async function(directory, shouldCache) {
  const cache3 = __privateGet(this, _cache);
  if (shouldCache && cache3.has(directory))
    return cache3.get(directory);
  for (const name of __privateGet(this, _names)) {
    const fileOrDirectory = path__namespace.default.join(directory, name);
    if (await __privateGet(this, _filter).call(this, { name, path: fileOrDirectory }))
      return fileOrDirectory;
  }
};
var searcher_default = Searcher, MARKERS = [".git", ".hg"], searcher, searchOptions = {
  names: MARKERS,
  filter: ({ path: directory }) => is_directory_default(directory, { allowSymlinks: !1 })
};
async function findProjectRoot(startDirectory, options8) {
  searcher ?? (searcher = new searcher_default(searchOptions));
  const mark = await searcher.search(startDirectory, options8);
  return mark ? path__namespace.dirname(mark) : void 0;
}
function clearFindProjectRootCache() {
  searcher?.clearCache();
}
function removeUnset(editorConfig) {
  const result = {}, keys = Object.keys(editorConfig);
  for (let i2 = 0; i2 < keys.length; i2++) {
    const key2 = keys[i2];
    editorConfig[key2] !== "unset" && (result[key2] = editorConfig[key2]);
  }
  return result;
}
function editorConfigToPrettier(editorConfig) {
  if (!editorConfig || (editorConfig = removeUnset(editorConfig), Object.keys(editorConfig).length === 0))
    return null;
  const result = {};
  return editorConfig.indent_style && (result.useTabs = editorConfig.indent_style === "tab"), editorConfig.indent_size === "tab" && (result.useTabs = !0), result.useTabs && editorConfig.tab_width ? result.tabWidth = editorConfig.tab_width : editorConfig.indent_style === "space" && editorConfig.indent_size && editorConfig.indent_size !== "tab" ? result.tabWidth = editorConfig.indent_size : editorConfig.tab_width !== void 0 && (result.tabWidth = editorConfig.tab_width), editorConfig.max_line_length && (editorConfig.max_line_length === "off" ? result.printWidth = Number.POSITIVE_INFINITY : result.printWidth = editorConfig.max_line_length), editorConfig.quote_type === "single" ? result.singleQuote = !0 : editorConfig.quote_type === "double" && (result.singleQuote = !1), ["cr", "crlf", "lf"].includes(editorConfig.end_of_line) && (result.endOfLine = editorConfig.end_of_line), result;
}
var editorconfig_to_prettier_default = editorConfigToPrettier, editorconfigCache = /* @__PURE__ */ new Map();
function clearEditorconfigCache() {
  clearFindProjectRootCache(), editorconfigCache.clear();
}
async function loadEditorconfigInternal(file, { shouldCache }) {
  const directory = path__namespace.default.dirname(file), root2 = await findProjectRoot(directory, { shouldCache }), editorConfig = await import_editorconfig.default.parse(file, { root: root2 });
  return editorconfig_to_prettier_default(editorConfig);
}
function loadEditorconfig(file, { shouldCache }) {
  return file = path__namespace.default.resolve(file), (!shouldCache || !editorconfigCache.has(file)) && editorconfigCache.set(
    file,
    loadEditorconfigInternal(file, { shouldCache })
  ), editorconfigCache.get(file);
}
var import_ci_info = __toESM(require_ci_info(), 1), { stdin } = process;
async function getStdin() {
  let result = "";
  if (stdin.isTTY)
    return result;
  stdin.setEncoding("utf8");
  for await (const chunk of stdin)
    result += chunk;
  return result;
}
getStdin.buffer = async () => {
  const result = [];
  let length = 0;
  if (stdin.isTTY)
    return Buffer.concat([]);
  for await (const chunk of stdin)
    result.push(chunk), length += chunk.length;
  return Buffer.concat(result, length);
};
function writeFormattedFile(file, data) {
  return fs__default.default.writeFile(file, data);
}
var mockable = {
  getPrettierConfigSearchStopDirectory: () => {
  },
  getStdin,
  isCI: () => import_ci_info.isCI,
  writeFormattedFile
}, mockable_default = mockable;
async function isFile(file, options8) {
  const allowSymlinks = options8?.allowSymlinks ?? !0;
  let stats;
  try {
    stats = await (allowSymlinks ? fs__default.default.stat : fs__default.default.lstat)(toPath(file));
  } catch {
    return !1;
  }
  return stats.isFile();
}
var is_file_default = isFile, import_parse_async = __toESM(require_parse_async(), 1);
function isNothing(subject) {
  return typeof subject > "u" || subject === null;
}
function isObject(subject) {
  return typeof subject == "object" && subject !== null;
}
function toArray(sequence) {
  return Array.isArray(sequence) ? sequence : isNothing(sequence) ? [] : [sequence];
}
function extend(target, source2) {
  var index, length, key2, sourceKeys;
  if (source2)
    for (sourceKeys = Object.keys(source2), index = 0, length = sourceKeys.length; index < length; index += 1)
      key2 = sourceKeys[index], target[key2] = source2[key2];
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1)
    result += string;
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing, isObject_1 = isObject, toArray_1 = toArray, repeat_1 = repeat, isNegativeZero_1 = isNegativeZero, extend_1 = extend, common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  return exception2.mark ? (exception2.mark.name && (where += 'in "' + exception2.mark.name + '" '), where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")", !compact && exception2.mark.snippet && (where += `

` + exception2.mark.snippet), message + " " + where) : message;
}
function YAMLException$1(reason, mark) {
  Error.call(this), this.name = "YAMLException", this.reason = reason, this.mark = mark, this.message = formatError(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
function getLine(buffer2, lineStart, lineEnd, position, maxLineLength) {
  var head = "", tail = "", maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  return position - lineStart > maxHalfLength && (head = " ... ", lineStart = position - maxHalfLength + head.length), lineEnd - position > maxHalfLength && (tail = " ...", lineEnd = position + maxHalfLength - tail.length), {
    str: head + buffer2.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options8) {
  if (options8 = Object.create(options8 || null), !mark.buffer)
    return null;
  options8.maxLength || (options8.maxLength = 79), typeof options8.indent != "number" && (options8.indent = 1), typeof options8.linesBefore != "number" && (options8.linesBefore = 3), typeof options8.linesAfter != "number" && (options8.linesAfter = 2);
  for (var re = /\r?\n|\r|\0/g, lineStarts = [0], lineEnds = [], match, foundLineNo = -1; match = re.exec(mark.buffer); )
    lineEnds.push(match.index), lineStarts.push(match.index + match[0].length), mark.position <= match.index && foundLineNo < 0 && (foundLineNo = lineStarts.length - 2);
  foundLineNo < 0 && (foundLineNo = lineStarts.length - 1);
  var result = "", i2, line3, lineNoLength = Math.min(mark.line + options8.linesAfter, lineEnds.length).toString().length, maxLineLength = options8.maxLength - (options8.indent + lineNoLength + 3);
  for (i2 = 1; i2 <= options8.linesBefore && !(foundLineNo - i2 < 0); i2++)
    line3 = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i2],
      lineEnds[foundLineNo - i2],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i2]),
      maxLineLength
    ), result = common.repeat(" ", options8.indent) + padStart((mark.line - i2 + 1).toString(), lineNoLength) + " | " + line3.str + `
` + result;
  for (line3 = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength), result += common.repeat(" ", options8.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line3.str + `
`, result += common.repeat("-", options8.indent + lineNoLength + 3 + line3.pos) + `^
`, i2 = 1; i2 <= options8.linesAfter && !(foundLineNo + i2 >= lineEnds.length); i2++)
    line3 = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i2],
      lineEnds[foundLineNo + i2],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i2]),
      maxLineLength
    ), result += common.repeat(" ", options8.indent) + padStart((mark.line + i2 + 1).toString(), lineNoLength) + " | " + line3.str + `
`;
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet, TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
], YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result = {};
  return map2 !== null && Object.keys(map2).forEach(function(style) {
    map2[style].forEach(function(alias) {
      result[String(alias)] = style;
    });
  }), result;
}
function Type$1(tag, options8) {
  if (options8 = options8 || {}, Object.keys(options8).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1)
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
  }), this.options = options8, this.tag = tag, this.kind = options8.kind || null, this.resolve = options8.resolve || function() {
    return !0;
  }, this.construct = options8.construct || function(data) {
    return data;
  }, this.instanceOf = options8.instanceOf || null, this.predicate = options8.predicate || null, this.represent = options8.represent || null, this.representName = options8.representName || null, this.defaultStyle = options8.defaultStyle || null, this.multi = options8.multi || !1, this.styleAliases = compileStyleAliases(options8.styleAliases || null), YAML_NODE_KINDS.indexOf(this.kind) === -1)
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
}
var type = Type$1;
function compileList(schema2, name) {
  var result = [];
  return schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi && (newIndex = previousIndex);
    }), result[newIndex] = currentType;
  }), result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    type2.multi ? (result.multi[type2.kind].push(type2), result.multi.fallback.push(type2)) : result[type2.kind][type2.tag] = result.fallback[type2.tag] = type2;
  }
  for (index = 0, length = arguments.length; index < length; index += 1)
    arguments[index].forEach(collectType);
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function(definition) {
  var implicit = [], explicit = [];
  if (definition instanceof type)
    explicit.push(definition);
  else if (Array.isArray(definition))
    explicit = explicit.concat(definition);
  else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit)))
    definition.implicit && (implicit = implicit.concat(definition.implicit)), definition.explicit && (explicit = explicit.concat(definition.explicit));
  else
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type))
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (type$1.loadKind && type$1.loadKind !== "scalar")
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    if (type$1.multi)
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
  }), explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type))
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  });
  var result = Object.create(Schema$1.prototype);
  return result.implicit = (this.implicit || []).concat(implicit), result.explicit = (this.explicit || []).concat(explicit), result.compiledImplicit = compileList(result, "implicit"), result.compiledExplicit = compileList(result, "explicit"), result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit), result;
};
var schema = Schema$1, str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
}), seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
}), map = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
}), failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});
function resolveYamlNull(data) {
  if (data === null)
    return !0;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null)
    return !1;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c2) {
  return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
}
function isOctCode(c2) {
  return 48 <= c2 && c2 <= 55;
}
function isDecCode(c2) {
  return 48 <= c2 && c2 <= 57;
}
function resolveYamlInteger(data) {
  if (data === null)
    return !1;
  var max = data.length, index = 0, hasDigits = !1, ch;
  if (!max)
    return !1;
  if (ch = data[index], (ch === "-" || ch === "+") && (ch = data[++index]), ch === "0") {
    if (index + 1 === max)
      return !0;
    if (ch = data[++index], ch === "b") {
      for (index++; index < max; index++)
        if (ch = data[index], ch !== "_") {
          if (ch !== "0" && ch !== "1")
            return !1;
          hasDigits = !0;
        }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      for (index++; index < max; index++)
        if (ch = data[index], ch !== "_") {
          if (!isHexCode(data.charCodeAt(index)))
            return !1;
          hasDigits = !0;
        }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      for (index++; index < max; index++)
        if (ch = data[index], ch !== "_") {
          if (!isOctCode(data.charCodeAt(index)))
            return !1;
          hasDigits = !0;
        }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_")
    return !1;
  for (; index < max; index++)
    if (ch = data[index], ch !== "_") {
      if (!isDecCode(data.charCodeAt(index)))
        return !1;
      hasDigits = !0;
    }
  return !(!hasDigits || ch === "_");
}
function constructYamlInteger(data) {
  var value = data, sign2 = 1, ch;
  if (value.indexOf("_") !== -1 && (value = value.replace(/_/g, "")), ch = value[0], (ch === "-" || ch === "+") && (ch === "-" && (sign2 = -1), value = value.slice(1), ch = value[0]), value === "0")
    return 0;
  if (ch === "0") {
    if (value[1] === "b")
      return sign2 * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign2 * parseInt(value.slice(2), 16);
    if (value[1] === "o")
      return sign2 * parseInt(value.slice(2), 8);
  }
  return sign2 * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && object % 1 === 0 && !common.isNegativeZero(object);
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
}), YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  return !(data === null || !YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_");
}
function constructYamlFloat(data) {
  var value, sign2;
  return value = data.replace(/_/g, "").toLowerCase(), sign2 = value[0] === "-" ? -1 : 1, "+-".indexOf(value[0]) >= 0 && (value = value.slice(1)), value === ".inf" ? sign2 === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : value === ".nan" ? NaN : sign2 * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object))
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === object)
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === object)
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (common.isNegativeZero(object))
    return "-0.0";
  return res = object.toString(10), SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
}), json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
}), core = json, YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
), YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  return data === null ? !1 : YAML_DATE_REGEXP.exec(data) !== null || YAML_TIMESTAMP_REGEXP.exec(data) !== null;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  if (match = YAML_DATE_REGEXP.exec(data), match === null && (match = YAML_TIMESTAMP_REGEXP.exec(data)), match === null)
    throw new Error("Date resolve error");
  if (year = +match[1], month = +match[2] - 1, day = +match[3], !match[4])
    return new Date(Date.UTC(year, month, day));
  if (hour = +match[4], minute = +match[5], second = +match[6], match[7]) {
    for (fraction = match[7].slice(0, 3); fraction.length < 3; )
      fraction += "0";
    fraction = +fraction;
  }
  return match[9] && (tz_hour = +match[10], tz_minute = +(match[11] || 0), delta = (tz_hour * 60 + tz_minute) * 6e4, match[9] === "-" && (delta = -delta)), date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction)), delta && date.setTime(date.getTime() - delta), date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
}), BASE64_MAP = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function resolveYamlBinary(data) {
  if (data === null)
    return !1;
  var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++)
    if (code = map2.indexOf(data.charAt(idx)), !(code > 64)) {
      if (code < 0)
        return !1;
      bitlen += 6;
    }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++)
    idx % 4 === 0 && idx && (result.push(bits >> 16 & 255), result.push(bits >> 8 & 255), result.push(bits & 255)), bits = bits << 6 | map2.indexOf(input.charAt(idx));
  return tailbits = max % 4 * 6, tailbits === 0 ? (result.push(bits >> 16 & 255), result.push(bits >> 8 & 255), result.push(bits & 255)) : tailbits === 18 ? (result.push(bits >> 10 & 255), result.push(bits >> 2 & 255)) : tailbits === 12 && result.push(bits >> 4 & 255), new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++)
    idx % 3 === 0 && idx && (result += map2[bits >> 18 & 63], result += map2[bits >> 12 & 63], result += map2[bits >> 6 & 63], result += map2[bits & 63]), bits = (bits << 8) + object[idx];
  return tail = max % 3, tail === 0 ? (result += map2[bits >> 18 & 63], result += map2[bits >> 12 & 63], result += map2[bits >> 6 & 63], result += map2[bits & 63]) : tail === 2 ? (result += map2[bits >> 10 & 63], result += map2[bits >> 4 & 63], result += map2[bits << 2 & 63], result += map2[64]) : tail === 1 && (result += map2[bits >> 2 & 63], result += map2[bits << 4 & 63], result += map2[64], result += map2[64]), result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
}), _hasOwnProperty$3 = Object.prototype.hasOwnProperty, _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null)
    return !0;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    if (pair = object[index], pairHasKey = !1, _toString$2.call(pair) !== "[object Object]")
      return !1;
    for (pairKey in pair)
      if (_hasOwnProperty$3.call(pair, pairKey))
        if (!pairHasKey)
          pairHasKey = !0;
        else
          return !1;
    if (!pairHasKey)
      return !1;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return !1;
  }
  return !0;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
}), _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null)
    return !0;
  var index, length, pair, keys, result, object = data;
  for (result = new Array(object.length), index = 0, length = object.length; index < length; index += 1) {
    if (pair = object[index], _toString$1.call(pair) !== "[object Object]" || (keys = Object.keys(pair), keys.length !== 1))
      return !1;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return !0;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  var index, length, pair, keys, result, object = data;
  for (result = new Array(object.length), index = 0, length = object.length; index < length; index += 1)
    pair = object[index], keys = Object.keys(pair), result[index] = [keys[0], pair[keys[0]]];
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
}), _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null)
    return !0;
  var key2, object = data;
  for (key2 in object)
    if (_hasOwnProperty$2.call(object, key2) && object[key2] !== null)
      return !1;
  return !0;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
}), _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
}), _hasOwnProperty$1 = Object.prototype.hasOwnProperty, CONTEXT_FLOW_IN = 1, CONTEXT_FLOW_OUT = 2, CONTEXT_BLOCK_IN = 3, CONTEXT_BLOCK_OUT = 4, CHOMPING_CLIP = 1, CHOMPING_STRIP = 2, CHOMPING_KEEP = 3, PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/, PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/, PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i, PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c2) {
  return c2 === 10 || c2 === 13;
}
function is_WHITE_SPACE(c2) {
  return c2 === 9 || c2 === 32;
}
function is_WS_OR_EOL(c2) {
  return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
}
function is_FLOW_INDICATOR(c2) {
  return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;
}
function fromHexCode(c2) {
  var lc;
  return 48 <= c2 && c2 <= 57 ? c2 - 48 : (lc = c2 | 32, 97 <= lc && lc <= 102 ? lc - 97 + 10 : -1);
}
function escapedHexLen(c2) {
  return c2 === 120 ? 2 : c2 === 117 ? 4 : c2 === 85 ? 8 : 0;
}
function fromDecimalCode(c2) {
  return 48 <= c2 && c2 <= 57 ? c2 - 48 : -1;
}
function simpleEscapeSequence(c2) {
  return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 || c2 === 9 ? "	" : c2 === 110 ? `
` : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "\x1B" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "\x85" : c2 === 95 ? "\xA0" : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
}
function charFromCodepoint(c2) {
  return c2 <= 65535 ? String.fromCharCode(c2) : String.fromCharCode(
    (c2 - 65536 >> 10) + 55296,
    (c2 - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256), simpleEscapeMap = new Array(256);
for (i = 0; i < 256; i++)
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0, simpleEscapeMap[i] = simpleEscapeSequence(i);
var i;
function State$1(input, options8) {
  this.input = input, this.filename = options8.filename || null, this.schema = options8.schema || _default, this.onWarning = options8.onWarning || null, this.legacy = options8.legacy || !1, this.json = options8.json || !1, this.listener = options8.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = input.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  return mark.snippet = snippet(mark), new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  state.onWarning && state.onWarning.call(null, generateError(state, message));
}
var directiveHandlers = {
  YAML: function(state, name, args) {
    var match, major, minor;
    state.version !== null && throwError(state, "duplication of %YAML directive"), args.length !== 1 && throwError(state, "YAML directive accepts exactly one argument"), match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]), match === null && throwError(state, "ill-formed argument of the YAML directive"), major = parseInt(match[1], 10), minor = parseInt(match[2], 10), major !== 1 && throwError(state, "unacceptable YAML version of the document"), state.version = args[0], state.checkLineBreaks = minor < 2, minor !== 1 && minor !== 2 && throwWarning(state, "unsupported YAML version of the document");
  },
  TAG: function(state, name, args) {
    var handle, prefix;
    args.length !== 2 && throwError(state, "TAG directive accepts exactly two arguments"), handle = args[0], prefix = args[1], PATTERN_TAG_HANDLE.test(handle) || throwError(state, "ill-formed tag handle (first argument) of the TAG directive"), _hasOwnProperty$1.call(state.tagMap, handle) && throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle'), PATTERN_TAG_URI.test(prefix) || throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      prefix = decodeURIComponent(prefix);
    } catch {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    if (_result = state.input.slice(start, end), checkJson)
      for (_position = 0, _length = _result.length; _position < _length; _position += 1)
        _character = _result.charCodeAt(_position), _character === 9 || 32 <= _character && _character <= 1114111 || throwError(state, "expected valid JSON character");
    else
      PATTERN_NON_PRINTABLE.test(_result) && throwError(state, "the stream contains non-printable characters");
    state.result += _result;
  }
}
function mergeMappings(state, destination, source2, overridableKeys) {
  var sourceKeys, key2, index, quantity;
  for (common.isObject(source2) || throwError(state, "cannot merge mappings; the provided source object is unacceptable"), sourceKeys = Object.keys(source2), index = 0, quantity = sourceKeys.length; index < quantity; index += 1)
    key2 = sourceKeys[index], _hasOwnProperty$1.call(destination, key2) || (destination[key2] = source2[key2], overridableKeys[key2] = !0);
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode))
    for (keyNode = Array.prototype.slice.call(keyNode), index = 0, quantity = keyNode.length; index < quantity; index += 1)
      Array.isArray(keyNode[index]) && throwError(state, "nested arrays are not supported inside keys"), typeof keyNode == "object" && _class(keyNode[index]) === "[object Object]" && (keyNode[index] = "[object Object]");
  if (typeof keyNode == "object" && _class(keyNode) === "[object Object]" && (keyNode = "[object Object]"), keyNode = String(keyNode), _result === null && (_result = {}), keyTag === "tag:yaml.org,2002:merge")
    if (Array.isArray(valueNode))
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1)
        mergeMappings(state, _result, valueNode[index], overridableKeys);
    else
      mergeMappings(state, _result, valueNode, overridableKeys);
  else
    !state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode) && (state.line = startLine || state.line, state.lineStart = startLineStart || state.lineStart, state.position = startPos || state.position, throwError(state, "duplicated mapping key")), keyNode === "__proto__" ? Object.defineProperty(_result, keyNode, {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: valueNode
    }) : _result[keyNode] = valueNode, delete overridableKeys[keyNode];
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position), ch === 10 ? state.position++ : ch === 13 ? (state.position++, state.input.charCodeAt(state.position) === 10 && state.position++) : throwError(state, "a line break is expected"), state.line += 1, state.lineStart = state.position, state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  for (var lineBreaks = 0, ch = state.input.charCodeAt(state.position); ch !== 0; ) {
    for (; is_WHITE_SPACE(ch); )
      ch === 9 && state.firstTabInLine === -1 && (state.firstTabInLine = state.position), ch = state.input.charCodeAt(++state.position);
    if (allowComments && ch === 35)
      do
        ch = state.input.charCodeAt(++state.position);
      while (ch !== 10 && ch !== 13 && ch !== 0);
    if (is_EOL(ch))
      for (readLineBreak(state), ch = state.input.charCodeAt(state.position), lineBreaks++, state.lineIndent = 0; ch === 32; )
        state.lineIndent++, ch = state.input.charCodeAt(++state.position);
    else
      break;
  }
  return checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent && throwWarning(state, "deficient indentation"), lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  return ch = state.input.charCodeAt(_position), !!((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2) && (_position += 3, ch = state.input.charCodeAt(_position), ch === 0 || is_WS_OR_EOL(ch)));
}
function writeFoldedLines(state, count) {
  count === 1 ? state.result += " " : count > 1 && (state.result += common.repeat(`
`, count - 1));
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  if (ch = state.input.charCodeAt(state.position), is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96 || (ch === 63 || ch === 45) && (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)))
    return !1;
  for (state.kind = "scalar", state.result = "", captureStart = captureEnd = state.position, hasPendingContent = !1; ch !== 0; ) {
    if (ch === 58) {
      if (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following))
        break;
    } else if (ch === 35) {
      if (preceding = state.input.charCodeAt(state.position - 1), is_WS_OR_EOL(preceding))
        break;
    } else {
      if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch))
        break;
      if (is_EOL(ch))
        if (_line = state.line, _lineStart = state.lineStart, _lineIndent = state.lineIndent, skipSeparationSpace(state, !1, -1), state.lineIndent >= nodeIndent) {
          hasPendingContent = !0, ch = state.input.charCodeAt(state.position);
          continue;
        } else {
          state.position = captureEnd, state.line = _line, state.lineStart = _lineStart, state.lineIndent = _lineIndent;
          break;
        }
    }
    hasPendingContent && (captureSegment(state, captureStart, captureEnd, !1), writeFoldedLines(state, state.line - _line), captureStart = captureEnd = state.position, hasPendingContent = !1), is_WHITE_SPACE(ch) || (captureEnd = state.position + 1), ch = state.input.charCodeAt(++state.position);
  }
  return captureSegment(state, captureStart, captureEnd, !1), state.result ? !0 : (state.kind = _kind, state.result = _result, !1);
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  if (ch = state.input.charCodeAt(state.position), ch !== 39)
    return !1;
  for (state.kind = "scalar", state.result = "", state.position++, captureStart = captureEnd = state.position; (ch = state.input.charCodeAt(state.position)) !== 0; )
    if (ch === 39)
      if (captureSegment(state, captureStart, state.position, !0), ch = state.input.charCodeAt(++state.position), ch === 39)
        captureStart = state.position, state.position++, captureEnd = state.position;
      else
        return !0;
    else
      is_EOL(ch) ? (captureSegment(state, captureStart, captureEnd, !0), writeFoldedLines(state, skipSeparationSpace(state, !1, nodeIndent)), captureStart = captureEnd = state.position) : state.position === state.lineStart && testDocumentSeparator(state) ? throwError(state, "unexpected end of the document within a single quoted scalar") : (state.position++, captureEnd = state.position);
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  if (ch = state.input.charCodeAt(state.position), ch !== 34)
    return !1;
  for (state.kind = "scalar", state.result = "", state.position++, captureStart = captureEnd = state.position; (ch = state.input.charCodeAt(state.position)) !== 0; ) {
    if (ch === 34)
      return captureSegment(state, captureStart, state.position, !0), state.position++, !0;
    if (ch === 92) {
      if (captureSegment(state, captureStart, state.position, !0), ch = state.input.charCodeAt(++state.position), is_EOL(ch))
        skipSeparationSpace(state, !1, nodeIndent);
      else if (ch < 256 && simpleEscapeCheck[ch])
        state.result += simpleEscapeMap[ch], state.position++;
      else if ((tmp = escapedHexLen(ch)) > 0) {
        for (hexLength = tmp, hexResult = 0; hexLength > 0; hexLength--)
          ch = state.input.charCodeAt(++state.position), (tmp = fromHexCode(ch)) >= 0 ? hexResult = (hexResult << 4) + tmp : throwError(state, "expected hexadecimal character");
        state.result += charFromCodepoint(hexResult), state.position++;
      } else
        throwError(state, "unknown escape sequence");
      captureStart = captureEnd = state.position;
    } else
      is_EOL(ch) ? (captureSegment(state, captureStart, captureEnd, !0), writeFoldedLines(state, skipSeparationSpace(state, !1, nodeIndent)), captureStart = captureEnd = state.position) : state.position === state.lineStart && testDocumentSeparator(state) ? throwError(state, "unexpected end of the document within a double quoted scalar") : (state.position++, captureEnd = state.position);
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = !0, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  if (ch = state.input.charCodeAt(state.position), ch === 91)
    terminator = 93, isMapping = !1, _result = [];
  else if (ch === 123)
    terminator = 125, isMapping = !0, _result = {};
  else
    return !1;
  for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(++state.position); ch !== 0; ) {
    if (skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), ch === terminator)
      return state.position++, state.tag = _tag, state.anchor = _anchor, state.kind = isMapping ? "mapping" : "sequence", state.result = _result, !0;
    readNext ? ch === 44 && throwError(state, "expected the node content, but found ','") : throwError(state, "missed comma between flow collection entries"), keyTag = keyNode = valueNode = null, isPair = isExplicitPair = !1, ch === 63 && (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) && (isPair = isExplicitPair = !0, state.position++, skipSeparationSpace(state, !0, nodeIndent))), _line = state.line, _lineStart = state.lineStart, _pos = state.position, composeNode(state, nodeIndent, CONTEXT_FLOW_IN, !1, !0), keyTag = state.tag, keyNode = state.result, skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), (isExplicitPair || state.line === _line) && ch === 58 && (isPair = !0, ch = state.input.charCodeAt(++state.position), skipSeparationSpace(state, !0, nodeIndent), composeNode(state, nodeIndent, CONTEXT_FLOW_IN, !1, !0), valueNode = state.result), isMapping ? storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos) : isPair ? _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos)) : _result.push(keyNode), skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), ch === 44 ? (readNext = !0, ch = state.input.charCodeAt(++state.position)) : readNext = !1;
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = !1, detectedIndent = !1, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = !1, tmp, ch;
  if (ch = state.input.charCodeAt(state.position), ch === 124)
    folding = !1;
  else if (ch === 62)
    folding = !0;
  else
    return !1;
  for (state.kind = "scalar", state.result = ""; ch !== 0; )
    if (ch = state.input.charCodeAt(++state.position), ch === 43 || ch === 45)
      CHOMPING_CLIP === chomping ? chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP : throwError(state, "repeat of a chomping mode identifier");
    else if ((tmp = fromDecimalCode(ch)) >= 0)
      tmp === 0 ? throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one") : detectedIndent ? throwError(state, "repeat of an indentation width identifier") : (textIndent = nodeIndent + tmp - 1, detectedIndent = !0);
    else
      break;
  if (is_WHITE_SPACE(ch)) {
    do
      ch = state.input.charCodeAt(++state.position);
    while (is_WHITE_SPACE(ch));
    if (ch === 35)
      do
        ch = state.input.charCodeAt(++state.position);
      while (!is_EOL(ch) && ch !== 0);
  }
  for (; ch !== 0; ) {
    for (readLineBreak(state), state.lineIndent = 0, ch = state.input.charCodeAt(state.position); (!detectedIndent || state.lineIndent < textIndent) && ch === 32; )
      state.lineIndent++, ch = state.input.charCodeAt(++state.position);
    if (!detectedIndent && state.lineIndent > textIndent && (textIndent = state.lineIndent), is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      chomping === CHOMPING_KEEP ? state.result += common.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines) : chomping === CHOMPING_CLIP && didReadContent && (state.result += `
`);
      break;
    }
    for (folding ? is_WHITE_SPACE(ch) ? (atMoreIndented = !0, state.result += common.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines)) : atMoreIndented ? (atMoreIndented = !1, state.result += common.repeat(`
`, emptyLines + 1)) : emptyLines === 0 ? didReadContent && (state.result += " ") : state.result += common.repeat(`
`, emptyLines) : state.result += common.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines), didReadContent = !0, detectedIndent = !0, emptyLines = 0, captureStart = state.position; !is_EOL(ch) && ch !== 0; )
      ch = state.input.charCodeAt(++state.position);
    captureSegment(state, captureStart, state.position, !1);
  }
  return !0;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = !1, ch;
  if (state.firstTabInLine !== -1)
    return !1;
  for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(state.position); ch !== 0 && (state.firstTabInLine !== -1 && (state.position = state.firstTabInLine, throwError(state, "tab characters must not be used in indentation")), !(ch !== 45 || (following = state.input.charCodeAt(state.position + 1), !is_WS_OR_EOL(following)))); ) {
    if (detected = !0, state.position++, skipSeparationSpace(state, !0, -1) && state.lineIndent <= nodeIndent) {
      _result.push(null), ch = state.input.charCodeAt(state.position);
      continue;
    }
    if (_line = state.line, composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, !1, !0), _result.push(state.result), skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position), (state.line === _line || state.lineIndent > nodeIndent) && ch !== 0)
      throwError(state, "bad indentation of a sequence entry");
    else if (state.lineIndent < nodeIndent)
      break;
  }
  return detected ? (state.tag = _tag, state.anchor = _anchor, state.kind = "sequence", state.result = _result, !0) : !1;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = !1, detected = !1, ch;
  if (state.firstTabInLine !== -1)
    return !1;
  for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(state.position); ch !== 0; ) {
    if (!atExplicitKey && state.firstTabInLine !== -1 && (state.position = state.firstTabInLine, throwError(state, "tab characters must not be used in indentation")), following = state.input.charCodeAt(state.position + 1), _line = state.line, (ch === 63 || ch === 58) && is_WS_OR_EOL(following))
      ch === 63 ? (atExplicitKey && (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !0, allowCompact = !0) : atExplicitKey ? (atExplicitKey = !1, allowCompact = !0) : throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), state.position += 1, ch = following;
    else {
      if (_keyLine = state.line, _keyLineStart = state.lineStart, _keyPos = state.position, !composeNode(state, flowIndent, CONTEXT_FLOW_OUT, !1, !0))
        break;
      if (state.line === _line) {
        for (ch = state.input.charCodeAt(state.position); is_WHITE_SPACE(ch); )
          ch = state.input.charCodeAt(++state.position);
        if (ch === 58)
          ch = state.input.charCodeAt(++state.position), is_WS_OR_EOL(ch) || throwError(state, "a whitespace character is expected after the key-value separator within a block mapping"), atExplicitKey && (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !1, allowCompact = !1, keyTag = state.tag, keyNode = state.result;
        else if (detected)
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        else
          return state.tag = _tag, state.anchor = _anchor, !0;
      } else if (detected)
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return state.tag = _tag, state.anchor = _anchor, !0;
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && (atExplicitKey && (_keyLine = state.line, _keyLineStart = state.lineStart, _keyPos = state.position), composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, !0, allowCompact) && (atExplicitKey ? keyNode = state.result : valueNode = state.result), atExplicitKey || (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos), keyTag = keyNode = valueNode = null), skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position)), (state.line === _line || state.lineIndent > nodeIndent) && ch !== 0)
      throwError(state, "bad indentation of a mapping entry");
    else if (state.lineIndent < nodeIndent)
      break;
  }
  return atExplicitKey && storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos), detected && (state.tag = _tag, state.anchor = _anchor, state.kind = "mapping", state.result = _result), detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = !1, isNamed = !1, tagHandle, tagName, ch;
  if (ch = state.input.charCodeAt(state.position), ch !== 33)
    return !1;
  if (state.tag !== null && throwError(state, "duplication of a tag property"), ch = state.input.charCodeAt(++state.position), ch === 60 ? (isVerbatim = !0, ch = state.input.charCodeAt(++state.position)) : ch === 33 ? (isNamed = !0, tagHandle = "!!", ch = state.input.charCodeAt(++state.position)) : tagHandle = "!", _position = state.position, isVerbatim) {
    do
      ch = state.input.charCodeAt(++state.position);
    while (ch !== 0 && ch !== 62);
    state.position < state.length ? (tagName = state.input.slice(_position, state.position), ch = state.input.charCodeAt(++state.position)) : throwError(state, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; ch !== 0 && !is_WS_OR_EOL(ch); )
      ch === 33 && (isNamed ? throwError(state, "tag suffix cannot contain exclamation marks") : (tagHandle = state.input.slice(_position - 1, state.position + 1), PATTERN_TAG_HANDLE.test(tagHandle) || throwError(state, "named tag handle cannot contain such characters"), isNamed = !0, _position = state.position + 1)), ch = state.input.charCodeAt(++state.position);
    tagName = state.input.slice(_position, state.position), PATTERN_FLOW_INDICATORS.test(tagName) && throwError(state, "tag suffix cannot contain flow indicator characters");
  }
  tagName && !PATTERN_TAG_URI.test(tagName) && throwError(state, "tag name cannot contain such characters: " + tagName);
  try {
    tagName = decodeURIComponent(tagName);
  } catch {
    throwError(state, "tag name is malformed: " + tagName);
  }
  return isVerbatim ? state.tag = tagName : _hasOwnProperty$1.call(state.tagMap, tagHandle) ? state.tag = state.tagMap[tagHandle] + tagName : tagHandle === "!" ? state.tag = "!" + tagName : tagHandle === "!!" ? state.tag = "tag:yaml.org,2002:" + tagName : throwError(state, 'undeclared tag handle "' + tagHandle + '"'), !0;
}
function readAnchorProperty(state) {
  var _position, ch;
  if (ch = state.input.charCodeAt(state.position), ch !== 38)
    return !1;
  for (state.anchor !== null && throwError(state, "duplication of an anchor property"), ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch); )
    ch = state.input.charCodeAt(++state.position);
  return state.position === _position && throwError(state, "name of an anchor node must contain at least one character"), state.anchor = state.input.slice(_position, state.position), !0;
}
function readAlias(state) {
  var _position, alias, ch;
  if (ch = state.input.charCodeAt(state.position), ch !== 42)
    return !1;
  for (ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch); )
    ch = state.input.charCodeAt(++state.position);
  return state.position === _position && throwError(state, "name of an alias node must contain at least one character"), alias = state.input.slice(_position, state.position), _hasOwnProperty$1.call(state.anchorMap, alias) || throwError(state, 'unidentified alias "' + alias + '"'), state.result = state.anchorMap[alias], skipSeparationSpace(state, !0, -1), !0;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = !1, hasContent = !1, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null && state.listener("open", state), state.tag = null, state.anchor = null, state.kind = null, state.result = null, allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext, allowToSeek && skipSeparationSpace(state, !0, -1) && (atNewLine = !0, state.lineIndent > parentIndent ? indentStatus = 1 : state.lineIndent === parentIndent ? indentStatus = 0 : state.lineIndent < parentIndent && (indentStatus = -1)), indentStatus === 1)
    for (; readTagProperty(state) || readAnchorProperty(state); )
      skipSeparationSpace(state, !0, -1) ? (atNewLine = !0, allowBlockCollections = allowBlockStyles, state.lineIndent > parentIndent ? indentStatus = 1 : state.lineIndent === parentIndent ? indentStatus = 0 : state.lineIndent < parentIndent && (indentStatus = -1)) : allowBlockCollections = !1;
  if (allowBlockCollections && (allowBlockCollections = atNewLine || allowCompact), (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) && (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext ? flowIndent = parentIndent : flowIndent = parentIndent + 1, blockIndent = state.position - state.lineStart, indentStatus === 1 ? allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent) ? hasContent = !0 : (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent) ? hasContent = !0 : readAlias(state) ? (hasContent = !0, (state.tag !== null || state.anchor !== null) && throwError(state, "alias node should not have any properties")) : readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext) && (hasContent = !0, state.tag === null && (state.tag = "?")), state.anchor !== null && (state.anchorMap[state.anchor] = state.result)) : indentStatus === 0 && (hasContent = allowBlockCollections && readBlockSequence(state, blockIndent))), state.tag === null)
    state.anchor !== null && (state.anchorMap[state.anchor] = state.result);
  else if (state.tag === "?") {
    for (state.result !== null && state.kind !== "scalar" && throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"'), typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1)
      if (type2 = state.implicitTypes[typeIndex], type2.resolve(state.result)) {
        state.result = type2.construct(state.result), state.tag = type2.tag, state.anchor !== null && (state.anchorMap[state.anchor] = state.result);
        break;
      }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag))
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    else
      for (type2 = null, typeList = state.typeMap.multi[state.kind || "fallback"], typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1)
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
    type2 || throwError(state, "unknown tag !<" + state.tag + ">"), state.result !== null && type2.kind !== state.kind && throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"'), type2.resolve(state.result, state.tag) ? (state.result = type2.construct(state.result, state.tag), state.anchor !== null && (state.anchorMap[state.anchor] = state.result)) : throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
  }
  return state.listener !== null && state.listener("close", state), state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = !1, ch;
  for (state.version = null, state.checkLineBreaks = state.legacy, state.tagMap = /* @__PURE__ */ Object.create(null), state.anchorMap = /* @__PURE__ */ Object.create(null); (ch = state.input.charCodeAt(state.position)) !== 0 && (skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position), !(state.lineIndent > 0 || ch !== 37)); ) {
    for (hasDirectives = !0, ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch); )
      ch = state.input.charCodeAt(++state.position);
    for (directiveName = state.input.slice(_position, state.position), directiveArgs = [], directiveName.length < 1 && throwError(state, "directive name must not be less than one character in length"); ch !== 0; ) {
      for (; is_WHITE_SPACE(ch); )
        ch = state.input.charCodeAt(++state.position);
      if (ch === 35) {
        do
          ch = state.input.charCodeAt(++state.position);
        while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      for (_position = state.position; ch !== 0 && !is_WS_OR_EOL(ch); )
        ch = state.input.charCodeAt(++state.position);
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    ch !== 0 && readLineBreak(state), _hasOwnProperty$1.call(directiveHandlers, directiveName) ? directiveHandlers[directiveName](state, directiveName, directiveArgs) : throwWarning(state, 'unknown document directive "' + directiveName + '"');
  }
  if (skipSeparationSpace(state, !0, -1), state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45 ? (state.position += 3, skipSeparationSpace(state, !0, -1)) : hasDirectives && throwError(state, "directives end mark is expected"), composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, !1, !0), skipSeparationSpace(state, !0, -1), state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position)) && throwWarning(state, "non-ASCII line breaks are interpreted as content"), state.documents.push(state.result), state.position === state.lineStart && testDocumentSeparator(state)) {
    state.input.charCodeAt(state.position) === 46 && (state.position += 3, skipSeparationSpace(state, !0, -1));
    return;
  }
  if (state.position < state.length - 1)
    throwError(state, "end of the stream or a document separator is expected");
  else
    return;
}
function loadDocuments(input, options8) {
  input = String(input), options8 = options8 || {}, input.length !== 0 && (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13 && (input += `
`), input.charCodeAt(0) === 65279 && (input = input.slice(1)));
  var state = new State$1(input, options8), nullpos = input.indexOf("\0");
  for (nullpos !== -1 && (state.position = nullpos, throwError(state, "null byte is not allowed in input")), state.input += "\0"; state.input.charCodeAt(state.position) === 32; )
    state.lineIndent += 1, state.position += 1;
  for (; state.position < state.length - 1; )
    readDocument(state);
  return state.documents;
}
function loadAll$1(input, iterator, options8) {
  iterator !== null && typeof iterator == "object" && typeof options8 > "u" && (options8 = iterator, iterator = null);
  var documents = loadDocuments(input, options8);
  if (typeof iterator != "function")
    return documents;
  for (var index = 0, length = documents.length; index < length; index += 1)
    iterator(documents[index]);
}
function load$1(input, options8) {
  var documents = loadDocuments(input, options8);
  if (documents.length !== 0) {
    if (documents.length === 1)
      return documents[0];
    throw new exception("expected a single document in the stream, but found more");
  }
}
var loadAll_1 = loadAll$1, load_1 = load$1, loader = {
  loadAll: loadAll_1,
  load: load_1
}, load = loader.load, Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/, ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/, ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/, unicode = {
  Space_Separator,
  ID_Start,
  ID_Continue
}, util = {
  isSpaceSeparator(c2) {
    return typeof c2 == "string" && unicode.Space_Separator.test(c2);
  },
  isIdStartChar(c2) {
    return typeof c2 == "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 === "$" || c2 === "_" || unicode.ID_Start.test(c2));
  },
  isIdContinueChar(c2) {
    return typeof c2 == "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 >= "0" && c2 <= "9" || c2 === "$" || c2 === "_" || c2 === "\u200C" || c2 === "\u200D" || unicode.ID_Continue.test(c2));
  },
  isDigit(c2) {
    return typeof c2 == "string" && /[0-9]/.test(c2);
  },
  isHexDigit(c2) {
    return typeof c2 == "string" && /[0-9A-Fa-f]/.test(c2);
  }
}, source, parseState, stack, pos, line, column, token, key, root, parse2 = function(text, reviver) {
  source = String(text), parseState = "start", stack = [], pos = 0, line = 1, column = 0, token = void 0, key = void 0, root = void 0;
  do
    token = lex(), parseStates[parseState]();
  while (token.type !== "eof");
  return typeof reviver == "function" ? internalize({ "": root }, "", reviver) : root;
};
function internalize(holder, name, reviver) {
  const value = holder[name];
  if (value != null && typeof value == "object")
    if (Array.isArray(value))
      for (let i2 = 0; i2 < value.length; i2++) {
        const key2 = String(i2), replacement = internalize(value, key2, reviver);
        replacement === void 0 ? delete value[key2] : Object.defineProperty(value, key2, {
          value: replacement,
          writable: !0,
          enumerable: !0,
          configurable: !0
        });
      }
    else
      for (const key2 in value) {
        const replacement = internalize(value, key2, reviver);
        replacement === void 0 ? delete value[key2] : Object.defineProperty(value, key2, {
          value: replacement,
          writable: !0,
          enumerable: !0,
          configurable: !0
        });
      }
  return reviver.call(holder, name, value);
}
var lexState, buffer, doubleQuote, sign, c;
function lex() {
  for (lexState = "default", buffer = "", doubleQuote = !1, sign = 1; ; ) {
    c = peek();
    const token2 = lexStates[lexState]();
    if (token2)
      return token2;
  }
}
function peek() {
  if (source[pos])
    return String.fromCodePoint(source.codePointAt(pos));
}
function read() {
  const c2 = peek();
  return c2 === `
` ? (line++, column = 0) : c2 ? column += c2.length : column++, c2 && (pos += c2.length), c2;
}
var lexStates = {
  default() {
    switch (c) {
      case "	":
      case "\v":
      case "\f":
      case " ":
      case "\xA0":
      case "\uFEFF":
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        read();
        return;
      case "/":
        read(), lexState = "comment";
        return;
      case void 0:
        return read(), newToken("eof");
    }
    if (util.isSpaceSeparator(c)) {
      read();
      return;
    }
    return lexStates[parseState]();
  },
  comment() {
    switch (c) {
      case "*":
        read(), lexState = "multiLineComment";
        return;
      case "/":
        read(), lexState = "singleLineComment";
        return;
    }
    throw invalidChar(read());
  },
  multiLineComment() {
    switch (c) {
      case "*":
        read(), lexState = "multiLineCommentAsterisk";
        return;
      case void 0:
        throw invalidChar(read());
    }
    read();
  },
  multiLineCommentAsterisk() {
    switch (c) {
      case "*":
        read();
        return;
      case "/":
        read(), lexState = "default";
        return;
      case void 0:
        throw invalidChar(read());
    }
    read(), lexState = "multiLineComment";
  },
  singleLineComment() {
    switch (c) {
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        read(), lexState = "default";
        return;
      case void 0:
        return read(), newToken("eof");
    }
    read();
  },
  value() {
    switch (c) {
      case "{":
      case "[":
        return newToken("punctuator", read());
      case "n":
        return read(), literal("ull"), newToken("null", null);
      case "t":
        return read(), literal("rue"), newToken("boolean", !0);
      case "f":
        return read(), literal("alse"), newToken("boolean", !1);
      case "-":
      case "+":
        read() === "-" && (sign = -1), lexState = "sign";
        return;
      case ".":
        buffer = read(), lexState = "decimalPointLeading";
        return;
      case "0":
        buffer = read(), lexState = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        buffer = read(), lexState = "decimalInteger";
        return;
      case "I":
        return read(), literal("nfinity"), newToken("numeric", 1 / 0);
      case "N":
        return read(), literal("aN"), newToken("numeric", NaN);
      case '"':
      case "'":
        doubleQuote = read() === '"', buffer = "", lexState = "string";
        return;
    }
    throw invalidChar(read());
  },
  identifierNameStartEscape() {
    if (c !== "u")
      throw invalidChar(read());
    read();
    const u = unicodeEscape();
    switch (u) {
      case "$":
      case "_":
        break;
      default:
        if (!util.isIdStartChar(u))
          throw invalidIdentifier();
        break;
    }
    buffer += u, lexState = "identifierName";
  },
  identifierName() {
    switch (c) {
      case "$":
      case "_":
      case "\u200C":
      case "\u200D":
        buffer += read();
        return;
      case "\\":
        read(), lexState = "identifierNameEscape";
        return;
    }
    if (util.isIdContinueChar(c)) {
      buffer += read();
      return;
    }
    return newToken("identifier", buffer);
  },
  identifierNameEscape() {
    if (c !== "u")
      throw invalidChar(read());
    read();
    const u = unicodeEscape();
    switch (u) {
      case "$":
      case "_":
      case "\u200C":
      case "\u200D":
        break;
      default:
        if (!util.isIdContinueChar(u))
          throw invalidIdentifier();
        break;
    }
    buffer += u, lexState = "identifierName";
  },
  sign() {
    switch (c) {
      case ".":
        buffer = read(), lexState = "decimalPointLeading";
        return;
      case "0":
        buffer = read(), lexState = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        buffer = read(), lexState = "decimalInteger";
        return;
      case "I":
        return read(), literal("nfinity"), newToken("numeric", sign * (1 / 0));
      case "N":
        return read(), literal("aN"), newToken("numeric", NaN);
    }
    throw invalidChar(read());
  },
  zero() {
    switch (c) {
      case ".":
        buffer += read(), lexState = "decimalPoint";
        return;
      case "e":
      case "E":
        buffer += read(), lexState = "decimalExponent";
        return;
      case "x":
      case "X":
        buffer += read(), lexState = "hexadecimal";
        return;
    }
    return newToken("numeric", sign * 0);
  },
  decimalInteger() {
    switch (c) {
      case ".":
        buffer += read(), lexState = "decimalPoint";
        return;
      case "e":
      case "E":
        buffer += read(), lexState = "decimalExponent";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  decimalPointLeading() {
    if (util.isDigit(c)) {
      buffer += read(), lexState = "decimalFraction";
      return;
    }
    throw invalidChar(read());
  },
  decimalPoint() {
    switch (c) {
      case "e":
      case "E":
        buffer += read(), lexState = "decimalExponent";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read(), lexState = "decimalFraction";
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  decimalFraction() {
    switch (c) {
      case "e":
      case "E":
        buffer += read(), lexState = "decimalExponent";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  decimalExponent() {
    switch (c) {
      case "+":
      case "-":
        buffer += read(), lexState = "decimalExponentSign";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read(), lexState = "decimalExponentInteger";
      return;
    }
    throw invalidChar(read());
  },
  decimalExponentSign() {
    if (util.isDigit(c)) {
      buffer += read(), lexState = "decimalExponentInteger";
      return;
    }
    throw invalidChar(read());
  },
  decimalExponentInteger() {
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  hexadecimal() {
    if (util.isHexDigit(c)) {
      buffer += read(), lexState = "hexadecimalInteger";
      return;
    }
    throw invalidChar(read());
  },
  hexadecimalInteger() {
    if (util.isHexDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  string() {
    switch (c) {
      case "\\":
        read(), buffer += escape();
        return;
      case '"':
        if (doubleQuote)
          return read(), newToken("string", buffer);
        buffer += read();
        return;
      case "'":
        if (!doubleQuote)
          return read(), newToken("string", buffer);
        buffer += read();
        return;
      case `
`:
      case "\r":
        throw invalidChar(read());
      case "\u2028":
      case "\u2029":
        separatorChar(c);
        break;
      case void 0:
        throw invalidChar(read());
    }
    buffer += read();
  },
  start() {
    switch (c) {
      case "{":
      case "[":
        return newToken("punctuator", read());
    }
    lexState = "value";
  },
  beforePropertyName() {
    switch (c) {
      case "$":
      case "_":
        buffer = read(), lexState = "identifierName";
        return;
      case "\\":
        read(), lexState = "identifierNameStartEscape";
        return;
      case "}":
        return newToken("punctuator", read());
      case '"':
      case "'":
        doubleQuote = read() === '"', lexState = "string";
        return;
    }
    if (util.isIdStartChar(c)) {
      buffer += read(), lexState = "identifierName";
      return;
    }
    throw invalidChar(read());
  },
  afterPropertyName() {
    if (c === ":")
      return newToken("punctuator", read());
    throw invalidChar(read());
  },
  beforePropertyValue() {
    lexState = "value";
  },
  afterPropertyValue() {
    switch (c) {
      case ",":
      case "}":
        return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  beforeArrayValue() {
    if (c === "]")
      return newToken("punctuator", read());
    lexState = "value";
  },
  afterArrayValue() {
    switch (c) {
      case ",":
      case "]":
        return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  end() {
    throw invalidChar(read());
  }
};
function newToken(type2, value) {
  return {
    type: type2,
    value,
    line,
    column
  };
}
function literal(s) {
  for (const c2 of s) {
    if (peek() !== c2)
      throw invalidChar(read());
    read();
  }
}
function escape() {
  switch (peek()) {
    case "b":
      return read(), "\b";
    case "f":
      return read(), "\f";
    case "n":
      return read(), `
`;
    case "r":
      return read(), "\r";
    case "t":
      return read(), "	";
    case "v":
      return read(), "\v";
    case "0":
      if (read(), util.isDigit(peek()))
        throw invalidChar(read());
      return "\0";
    case "x":
      return read(), hexEscape();
    case "u":
      return read(), unicodeEscape();
    case `
`:
    case "\u2028":
    case "\u2029":
      return read(), "";
    case "\r":
      return read(), peek() === `
` && read(), "";
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7":
    case "8":
    case "9":
      throw invalidChar(read());
    case void 0:
      throw invalidChar(read());
  }
  return read();
}
function hexEscape() {
  let buffer2 = "", c2 = peek();
  if (!util.isHexDigit(c2) || (buffer2 += read(), c2 = peek(), !util.isHexDigit(c2)))
    throw invalidChar(read());
  return buffer2 += read(), String.fromCodePoint(parseInt(buffer2, 16));
}
function unicodeEscape() {
  let buffer2 = "", count = 4;
  for (; count-- > 0; ) {
    const c2 = peek();
    if (!util.isHexDigit(c2))
      throw invalidChar(read());
    buffer2 += read();
  }
  return String.fromCodePoint(parseInt(buffer2, 16));
}
var parseStates = {
  start() {
    if (token.type === "eof")
      throw invalidEOF();
    push();
  },
  beforePropertyName() {
    switch (token.type) {
      case "identifier":
      case "string":
        key = token.value, parseState = "afterPropertyName";
        return;
      case "punctuator":
        pop();
        return;
      case "eof":
        throw invalidEOF();
    }
  },
  afterPropertyName() {
    if (token.type === "eof")
      throw invalidEOF();
    parseState = "beforePropertyValue";
  },
  beforePropertyValue() {
    if (token.type === "eof")
      throw invalidEOF();
    push();
  },
  beforeArrayValue() {
    if (token.type === "eof")
      throw invalidEOF();
    if (token.type === "punctuator" && token.value === "]") {
      pop();
      return;
    }
    push();
  },
  afterPropertyValue() {
    if (token.type === "eof")
      throw invalidEOF();
    switch (token.value) {
      case ",":
        parseState = "beforePropertyName";
        return;
      case "}":
        pop();
    }
  },
  afterArrayValue() {
    if (token.type === "eof")
      throw invalidEOF();
    switch (token.value) {
      case ",":
        parseState = "beforeArrayValue";
        return;
      case "]":
        pop();
    }
  },
  end() {
  }
};
function push() {
  let value;
  switch (token.type) {
    case "punctuator":
      switch (token.value) {
        case "{":
          value = {};
          break;
        case "[":
          value = [];
          break;
      }
      break;
    case "null":
    case "boolean":
    case "numeric":
    case "string":
      value = token.value;
      break;
  }
  if (root === void 0)
    root = value;
  else {
    const parent = stack[stack.length - 1];
    Array.isArray(parent) ? parent.push(value) : Object.defineProperty(parent, key, {
      value,
      writable: !0,
      enumerable: !0,
      configurable: !0
    });
  }
  if (value !== null && typeof value == "object")
    stack.push(value), Array.isArray(value) ? parseState = "beforeArrayValue" : parseState = "beforePropertyName";
  else {
    const current = stack[stack.length - 1];
    current == null ? parseState = "end" : Array.isArray(current) ? parseState = "afterArrayValue" : parseState = "afterPropertyValue";
  }
}
function pop() {
  stack.pop();
  const current = stack[stack.length - 1];
  current == null ? parseState = "end" : Array.isArray(current) ? parseState = "afterArrayValue" : parseState = "afterPropertyValue";
}
function invalidChar(c2) {
  return syntaxError(c2 === void 0 ? `JSON5: invalid end of input at ${line}:${column}` : `JSON5: invalid character '${formatChar(c2)}' at ${line}:${column}`);
}
function invalidEOF() {
  return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
}
function invalidIdentifier() {
  return column -= 5, syntaxError(`JSON5: invalid identifier character at ${line}:${column}`);
}
function separatorChar(c2) {
  console.warn(`JSON5: '${formatChar(c2)}' in strings is not valid ECMAScript; consider escaping`);
}
function formatChar(c2) {
  const replacements = {
    "'": "\\'",
    '"': '\\"',
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "\v": "\\v",
    "\0": "\\0",
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
  };
  if (replacements[c2])
    return replacements[c2];
  if (c2 < " ") {
    const hexString = c2.charCodeAt(0).toString(16);
    return "\\x" + ("00" + hexString).substring(hexString.length);
  }
  return c2;
}
function syntaxError(message) {
  const err = new SyntaxError(message);
  return err.lineNumber = line, err.columnNumber = column, err;
}
var dist_default = { parse: parse2 }, import_code_frame = __toESM(require_lib3(), 1), safeLastIndexOf = (string, searchString, index) => index < 0 ? -1 : string.lastIndexOf(searchString, index);
function getPosition(text, textIndex) {
  const lineBreakBefore = safeLastIndexOf(text, `
`, textIndex - 1), column2 = textIndex - lineBreakBefore - 1;
  let line3 = 0;
  for (let index = lineBreakBefore; index >= 0; index = safeLastIndexOf(text, `
`, index - 1))
    line3++;
  return { line: line3, column: column2 };
}
function indexToLineColumn(text, textIndex, { oneBased = !1 } = {}) {
  if (textIndex < 0 || textIndex >= text.length && text.length > 0)
    throw new RangeError("Index out of bounds");
  const position = getPosition(text, textIndex);
  return oneBased ? { line: position.line + 1, column: position.column + 1 } : position;
}
var getCodePoint = (character) => `\\u{${character.codePointAt(0).toString(16)}}`, _message, _JSONError = class _JSONError2 extends Error {
  constructor(message) {
    var _a;
    super(), __publicField(this, "name", "JSONError"), __publicField(this, "fileName"), __publicField(this, "codeFrame"), __publicField(this, "rawCodeFrame"), __privateAdd(this, _message, void 0), __privateSet(this, _message, message), (_a = Error.captureStackTrace) == null || _a.call(Error, this, _JSONError2);
  }
  get message() {
    const { fileName, codeFrame } = this;
    return `${__privateGet(this, _message)}${fileName ? ` in ${fileName}` : ""}${codeFrame ? `

${codeFrame}
` : ""}`;
  }
  set message(message) {
    __privateSet(this, _message, message);
  }
};
_message = /* @__PURE__ */ new WeakMap();
var JSONError = _JSONError, generateCodeFrame = (string, location, highlightCode = !0) => (0, import_code_frame.codeFrameColumns)(string, { start: location }, { highlightCode }), getErrorLocation = (string, message) => {
  const match = message.match(/in JSON at position (?<index>\d+)(?: \(line (?<line>\d+) column (?<column>\d+)\))?$/);
  if (!match)
    return;
  let { index, line: line3, column: column2 } = match.groups;
  if (line3 && column2)
    return { line: Number(line3), column: Number(column2) };
  if (index = Number(index), index === string.length) {
    const { line: line4, column: column3 } = indexToLineColumn(string, string.length - 1, { oneBased: !0 });
    return { line: line4, column: column3 + 1 };
  }
  return indexToLineColumn(string, index, { oneBased: !0 });
}, addCodePointToUnexpectedToken = (message) => message.replace(
  // TODO[engine:node@>=20]: The token always quoted after Node.js 20
  /(?<=^Unexpected token )(?<quote>')?(.)\k<quote>/,
  (_, _quote, token2) => `"${token2}"(${getCodePoint(token2)})`
);
function parseJson(string, reviver, fileName) {
  typeof reviver == "string" && (fileName = reviver, reviver = void 0);
  let message;
  try {
    return JSON.parse(string, reviver);
  } catch (error) {
    message = error.message;
  }
  let location;
  string ? (location = getErrorLocation(string, message), message = addCodePointToUnexpectedToken(message)) : message += " while parsing empty string";
  const jsonError = new JSONError(message);
  throw jsonError.fileName = fileName, location && (jsonError.codeFrame = generateCodeFrame(string, location), jsonError.rawCodeFrame = generateCodeFrame(
    string,
    location,
    /* highlightCode */
    !1
  )), jsonError;
}
async function readFile(file) {
  isUrlString(file) && (file = new URL(file));
  try {
    return await fs__default.default.readFile(file, "utf8");
  } catch (error) {
    if (error.code === "ENOENT")
      return;
    throw new Error(`Unable to read '${file}': ${error.message}`);
  }
}
var read_file_default = readFile;
async function readJson(file) {
  const content = await read_file_default(file);
  try {
    return parseJson(content);
  } catch (error) {
    throw error.message = `JSON Error in ${file}:
${error.message}`, error;
  }
}
async function loadJs(file) {
  return (await import(require$$0.pathToFileURL(file).href)).default;
}
async function loadConfigFromPackageJson(file) {
  const { prettier } = await readJson(file);
  return prettier;
}
async function loadYaml(file) {
  const content = await read_file_default(file);
  try {
    return load(content);
  } catch (error) {
    throw error.message = `YAML Error in ${file}:
${error.message}`, error;
  }
}
var loaders = {
  async ".toml"(file) {
    const content = await read_file_default(file);
    try {
      return await (0, import_parse_async.default)(content);
    } catch (error) {
      throw error.message = `TOML Error in ${file}:
${error.message}`, error;
    }
  },
  async ".json5"(file) {
    const content = await read_file_default(file);
    try {
      return dist_default.parse(content);
    } catch (error) {
      throw error.message = `JSON5 Error in ${file}:
${error.message}`, error;
    }
  },
  ".json": readJson,
  ".js": loadJs,
  ".mjs": loadJs,
  ".cjs": loadJs,
  ".yaml": loadYaml,
  ".yml": loadYaml,
  // No extension
  "": loadYaml
}, loaders_default = loaders, CONFIG_FILE_NAMES = [
  "package.json",
  ".prettierrc",
  ".prettierrc.json",
  ".prettierrc.yaml",
  ".prettierrc.yml",
  ".prettierrc.json5",
  ".prettierrc.js",
  ".prettierrc.mjs",
  ".prettierrc.cjs",
  "prettier.config.js",
  "prettier.config.mjs",
  "prettier.config.cjs",
  ".prettierrc.toml"
];
async function filter({ name, path: file }) {
  if (!await is_file_default(file))
    return !1;
  if (name === "package.json")
    try {
      return !!await loadConfigFromPackageJson(file);
    } catch {
      return !1;
    }
  return !0;
}
function getSearcher(stopDirectory) {
  return new searcher_default({ names: CONFIG_FILE_NAMES, filter, stopDirectory });
}
var config_searcher_default = getSearcher, own = {}.hasOwnProperty, classRegExp = /^([A-Z][a-z\d]*)+$/, kTypes = /* @__PURE__ */ new Set([
  "string",
  "function",
  "number",
  "object",
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
]), codes = {};
function formatList(array2, type2 = "and") {
  return array2.length < 3 ? array2.join(` ${type2} `) : `${array2.slice(0, -1).join(", ")}, ${type2} ${array2[array2.length - 1]}`;
}
var messages = /* @__PURE__ */ new Map(), nodeInternalPrefix = "__node_internal_", userStackTraceLimit;
codes.ERR_INVALID_ARG_TYPE = createError(
  "ERR_INVALID_ARG_TYPE",
  /**
   * @param {string} name
   * @param {Array<string> | string} expected
   * @param {unknown} actual
   */
  (name, expected, actual) => {
    require$$1__default.default(typeof name == "string", "'name' must be a string"), Array.isArray(expected) || (expected = [expected]);
    let message = "The ";
    if (name.endsWith(" argument"))
      message += `${name} `;
    else {
      const type2 = name.includes(".") ? "property" : "argument";
      message += `"${name}" ${type2} `;
    }
    message += "must be ";
    const types = [], instances = [], other = [];
    for (const value of expected)
      require$$1__default.default(
        typeof value == "string",
        "All expected entries have to be of type string"
      ), kTypes.has(value) ? types.push(value.toLowerCase()) : classRegExp.exec(value) === null ? (require$$1__default.default(
        value !== "object",
        'The value "object" should be written as "Object"'
      ), other.push(value)) : instances.push(value);
    if (instances.length > 0) {
      const pos2 = types.indexOf("object");
      pos2 !== -1 && (types.slice(pos2, 1), instances.push("Object"));
    }
    return types.length > 0 && (message += `${types.length > 1 ? "one of type" : "of type"} ${formatList(
      types,
      "or"
    )}`, (instances.length > 0 || other.length > 0) && (message += " or ")), instances.length > 0 && (message += `an instance of ${formatList(instances, "or")}`, other.length > 0 && (message += " or ")), other.length > 0 && (other.length > 1 ? message += `one of ${formatList(other, "or")}` : (other[0].toLowerCase() !== other[0] && (message += "an "), message += `${other[0]}`)), message += `. Received ${determineSpecificType(actual)}`, message;
  },
  TypeError
);
codes.ERR_INVALID_MODULE_SPECIFIER = createError(
  "ERR_INVALID_MODULE_SPECIFIER",
  /**
   * @param {string} request
   * @param {string} reason
   * @param {string} [base]
   */
  (request, reason, base = void 0) => `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ""}`,
  TypeError
);
codes.ERR_INVALID_PACKAGE_CONFIG = createError(
  "ERR_INVALID_PACKAGE_CONFIG",
  /**
   * @param {string} path
   * @param {string} [base]
   * @param {string} [message]
   */
  (path13, base, message) => `Invalid package config ${path13}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`,
  Error
);
codes.ERR_INVALID_PACKAGE_TARGET = createError(
  "ERR_INVALID_PACKAGE_TARGET",
  /**
   * @param {string} pkgPath
   * @param {string} key
   * @param {unknown} target
   * @param {boolean} [isImport=false]
   * @param {string} [base]
   */
  (pkgPath, key2, target, isImport = !1, base = void 0) => {
    const relError = typeof target == "string" && !isImport && target.length > 0 && !target.startsWith("./");
    return key2 === "." ? (require$$1__default.default(isImport === !1), `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ""}${relError ? '; targets must start with "./"' : ""}`) : `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(
      target
    )} defined for '${key2}' in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ""}${relError ? '; targets must start with "./"' : ""}`;
  },
  Error
);
codes.ERR_MODULE_NOT_FOUND = createError(
  "ERR_MODULE_NOT_FOUND",
  /**
   * @param {string} path
   * @param {string} base
   * @param {boolean} [exactUrl]
   */
  (path13, base, exactUrl = !1) => `Cannot find ${exactUrl ? "module" : "package"} '${path13}' imported from ${base}`,
  Error
);
codes.ERR_NETWORK_IMPORT_DISALLOWED = createError(
  "ERR_NETWORK_IMPORT_DISALLOWED",
  "import of '%s' by %s is not supported: %s",
  Error
);
codes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError(
  "ERR_PACKAGE_IMPORT_NOT_DEFINED",
  /**
   * @param {string} specifier
   * @param {string} packagePath
   * @param {string} base
   */
  (specifier, packagePath, base) => `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base}`,
  TypeError
);
codes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError(
  "ERR_PACKAGE_PATH_NOT_EXPORTED",
  /**
   * @param {string} pkgPath
   * @param {string} subpath
   * @param {string} [base]
   */
  (pkgPath, subpath, base = void 0) => subpath === "." ? `No "exports" main defined in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}` : `Package subpath '${subpath}' is not defined by "exports" in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}`,
  Error
);
codes.ERR_UNSUPPORTED_DIR_IMPORT = createError(
  "ERR_UNSUPPORTED_DIR_IMPORT",
  "Directory import '%s' is not supported resolving ES modules imported from %s",
  Error
);
codes.ERR_UNKNOWN_FILE_EXTENSION = createError(
  "ERR_UNKNOWN_FILE_EXTENSION",
  /**
   * @param {string} ext
   * @param {string} path
   */
  (ext, path13) => `Unknown file extension "${ext}" for ${path13}`,
  TypeError
);
codes.ERR_INVALID_ARG_VALUE = createError(
  "ERR_INVALID_ARG_VALUE",
  /**
   * @param {string} name
   * @param {unknown} value
   * @param {string} [reason='is invalid']
   */
  (name, value, reason = "is invalid") => {
    let inspected = require$$0$1.inspect(value);
    return inspected.length > 128 && (inspected = `${inspected.slice(0, 128)}...`), `The ${name.includes(".") ? "property" : "argument"} '${name}' ${reason}. Received ${inspected}`;
  },
  TypeError
  // Note: extra classes have been shaken out.
  // , RangeError
);
function createError(sym, value, def) {
  return messages.set(sym, value), makeNodeErrorWithCode(def, sym);
}
function makeNodeErrorWithCode(Base, key2) {
  return NodeError;
  function NodeError(...args) {
    const limit = Error.stackTraceLimit;
    isErrorStackTraceLimitWritable() && (Error.stackTraceLimit = 0);
    const error = new Base();
    isErrorStackTraceLimitWritable() && (Error.stackTraceLimit = limit);
    const message = getMessage(key2, args, error);
    return Object.defineProperties(error, {
      // Note: no need to implement `kIsNodeError` symbol, would be hard,
      // probably.
      message: {
        value: message,
        enumerable: !1,
        writable: !0,
        configurable: !0
      },
      toString: {
        /** @this {Error} */
        value() {
          return `${this.name} [${key2}]: ${this.message}`;
        },
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), captureLargerStackTrace(error), error.code = key2, error;
  }
}
function isErrorStackTraceLimitWritable() {
  try {
    if (v8__default.default.startupSnapshot.isBuildingSnapshot())
      return !1;
  } catch {
  }
  const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
  return desc === void 0 ? Object.isExtensible(Error) : own.call(desc, "writable") && desc.writable !== void 0 ? desc.writable : desc.set !== void 0;
}
function hideStackFrames(fn) {
  const hidden = nodeInternalPrefix + fn.name;
  return Object.defineProperty(fn, "name", { value: hidden }), fn;
}
var captureLargerStackTrace = hideStackFrames(
  /**
   * @param {Error} error
   * @returns {Error}
   */
  // @ts-expect-error: fine
  function(error) {
    const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
    return stackTraceLimitIsWritable && (userStackTraceLimit = Error.stackTraceLimit, Error.stackTraceLimit = Number.POSITIVE_INFINITY), Error.captureStackTrace(error), stackTraceLimitIsWritable && (Error.stackTraceLimit = userStackTraceLimit), error;
  }
);
function getMessage(key2, args, self) {
  const message = messages.get(key2);
  if (require$$1__default.default(message !== void 0, "expected `message` to be found"), typeof message == "function")
    return require$$1__default.default(
      message.length <= args.length,
      // Default options do not count.
      `Code: ${key2}; The provided arguments length (${args.length}) does not match the required ones (${message.length}).`
    ), Reflect.apply(message, self, args);
  const regex = /%[dfijoOs]/g;
  let expectedLength = 0;
  for (; regex.exec(message) !== null; )
    expectedLength++;
  return require$$1__default.default(
    expectedLength === args.length,
    `Code: ${key2}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
  ), args.length === 0 ? message : (args.unshift(message), Reflect.apply(require$$0$1.format, null, args));
}
function determineSpecificType(value) {
  if (value == null)
    return String(value);
  if (typeof value == "function" && value.name)
    return `function ${value.name}`;
  if (typeof value == "object")
    return value.constructor && value.constructor.name ? `an instance of ${value.constructor.name}` : `${require$$0$1.inspect(value, { depth: -1 })}`;
  let inspected = require$$0$1.inspect(value, { colors: !1 });
  return inspected.length > 28 && (inspected = `${inspected.slice(0, 25)}...`), `type ${typeof value} (${inspected})`;
}
var hasOwnProperty = {}.hasOwnProperty, { ERR_INVALID_PACKAGE_CONFIG } = codes, cache = /* @__PURE__ */ new Map(), reader = { read: read2 }, package_json_reader_default = reader;
function read2(jsonPath, { base, specifier }) {
  const existing = cache.get(jsonPath);
  if (existing)
    return existing;
  let string;
  try {
    string = require$$0__default$2.default.readFileSync(path__namespace.default.toNamespacedPath(jsonPath), "utf8");
  } catch (error) {
    const exception2 = (
      /** @type {ErrnoException} */
      error
    );
    if (exception2.code !== "ENOENT")
      throw exception2;
  }
  const result = {
    exists: !1,
    pjsonPath: jsonPath,
    main: void 0,
    name: void 0,
    type: "none",
    // Ignore unknown types for forwards compatibility
    exports: void 0,
    imports: void 0
  };
  if (string !== void 0) {
    let parsed;
    try {
      parsed = JSON.parse(string);
    } catch (error_) {
      const cause = (
        /** @type {ErrnoException} */
        error_
      ), error = new ERR_INVALID_PACKAGE_CONFIG(
        jsonPath,
        (base ? `"${specifier}" from ` : "") + require$$0.fileURLToPath(base || specifier),
        cause.message
      );
      throw error.cause = cause, error;
    }
    result.exists = !0, hasOwnProperty.call(parsed, "name") && typeof parsed.name == "string" && (result.name = parsed.name), hasOwnProperty.call(parsed, "main") && typeof parsed.main == "string" && (result.main = parsed.main), hasOwnProperty.call(parsed, "exports") && (result.exports = parsed.exports), hasOwnProperty.call(parsed, "imports") && (result.imports = parsed.imports), hasOwnProperty.call(parsed, "type") && (parsed.type === "commonjs" || parsed.type === "module") && (result.type = parsed.type);
  }
  return cache.set(jsonPath, result), result;
}
function getPackageScopeConfig(resolved) {
  let packageJSONUrl = new require$$0.URL("package.json", resolved);
  for (; !packageJSONUrl.pathname.endsWith("node_modules/package.json"); ) {
    const packageConfig = package_json_reader_default.read(
      require$$0.fileURLToPath(packageJSONUrl),
      { specifier: resolved }
    );
    if (packageConfig.exists)
      return packageConfig;
    const lastPackageJSONUrl = packageJSONUrl;
    if (packageJSONUrl = new require$$0.URL("../package.json", packageJSONUrl), packageJSONUrl.pathname === lastPackageJSONUrl.pathname)
      break;
  }
  return {
    pjsonPath: require$$0.fileURLToPath(packageJSONUrl),
    exists: !1,
    main: void 0,
    name: void 0,
    type: "none",
    exports: void 0,
    imports: void 0
  };
}
function getPackageType(url2) {
  return getPackageScopeConfig(url2).type;
}
var { ERR_UNKNOWN_FILE_EXTENSION } = codes, hasOwnProperty2 = {}.hasOwnProperty, extensionFormatMap = {
  // @ts-expect-error: hush.
  __proto__: null,
  ".cjs": "commonjs",
  ".js": "module",
  ".json": "json",
  ".mjs": "module"
};
function mimeToFormat(mime) {
  return mime && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime) ? "module" : mime === "application/json" ? "json" : null;
}
var protocolHandlers = {
  // @ts-expect-error: hush.
  __proto__: null,
  "data:": getDataProtocolModuleFormat,
  "file:": getFileProtocolModuleFormat,
  "http:": getHttpProtocolModuleFormat,
  "https:": getHttpProtocolModuleFormat,
  "node:"() {
    return "builtin";
  }
};
function getDataProtocolModuleFormat(parsed) {
  const { 1: mime } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(
    parsed.pathname
  ) || [null, null, null];
  return mimeToFormat(mime);
}
function extname(url2) {
  const pathname = url2.pathname;
  let index = pathname.length;
  for (; index--; ) {
    const code = pathname.codePointAt(index);
    if (code === 47)
      return "";
    if (code === 46)
      return pathname.codePointAt(index - 1) === 47 ? "" : pathname.slice(index);
  }
  return "";
}
function getFileProtocolModuleFormat(url2, _context, ignoreErrors) {
  const ext = extname(url2);
  if (ext === ".js") {
    const packageType = getPackageType(url2);
    return packageType !== "none" ? packageType : "commonjs";
  }
  if (ext === "") {
    const packageType = getPackageType(url2);
    return packageType === "none" || packageType === "commonjs" ? "commonjs" : "module";
  }
  const format3 = extensionFormatMap[ext];
  if (format3)
    return format3;
  if (ignoreErrors)
    return;
  const filepath = require$$0.fileURLToPath(url2);
  throw new ERR_UNKNOWN_FILE_EXTENSION(ext, filepath);
}
function getHttpProtocolModuleFormat() {
}
function defaultGetFormatWithoutErrors(url2, context) {
  const protocol = url2.protocol;
  return hasOwnProperty2.call(protocolHandlers, protocol) && protocolHandlers[protocol](url2, context, !0) || null;
}
var { ERR_INVALID_ARG_VALUE } = codes, DEFAULT_CONDITIONS = Object.freeze(["node", "import"]), DEFAULT_CONDITIONS_SET = new Set(DEFAULT_CONDITIONS);
function getDefaultConditions() {
  return DEFAULT_CONDITIONS;
}
function getDefaultConditionsSet() {
  return DEFAULT_CONDITIONS_SET;
}
function getConditionsSet(conditions) {
  if (conditions !== void 0 && conditions !== getDefaultConditions()) {
    if (!Array.isArray(conditions))
      throw new ERR_INVALID_ARG_VALUE(
        "conditions",
        conditions,
        "expected an array"
      );
    return new Set(conditions);
  }
  return getDefaultConditionsSet();
}
var RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace], {
  ERR_NETWORK_IMPORT_DISALLOWED,
  ERR_INVALID_MODULE_SPECIFIER,
  ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG2,
  ERR_INVALID_PACKAGE_TARGET,
  ERR_MODULE_NOT_FOUND,
  ERR_PACKAGE_IMPORT_NOT_DEFINED,
  ERR_PACKAGE_PATH_NOT_EXPORTED,
  ERR_UNSUPPORTED_DIR_IMPORT
} = codes, own2 = {}.hasOwnProperty, invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i, deprecatedInvalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i, invalidPackageNameRegEx = /^\.|%|\\/, patternRegEx = /\*/g, encodedSepRegEx = /%2f|%5c/i, emittedPackageWarnings = /* @__PURE__ */ new Set(), doubleSlashRegEx = /[/\\]{2}/;
function emitInvalidSegmentDeprecation(target, request, match, packageJsonUrl, internal, base, isTarget) {
  if (process3__default.default.noDeprecation)
    return;
  const pjsonPath = require$$0.fileURLToPath(packageJsonUrl), double = doubleSlashRegEx.exec(isTarget ? target : request) !== null;
  process3__default.default.emitWarning(
    `Use of deprecated ${double ? "double slash" : "leading or trailing slash matching"} resolving "${target}" for module request "${request}" ${request === match ? "" : `matched to "${match}" `}in the "${internal ? "imports" : "exports"}" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${require$$0.fileURLToPath(base)}` : ""}.`,
    "DeprecationWarning",
    "DEP0166"
  );
}
function emitLegacyIndexDeprecation(url2, packageJsonUrl, base, main) {
  if (process3__default.default.noDeprecation || defaultGetFormatWithoutErrors(url2, { parentURL: base.href }) !== "module")
    return;
  const urlPath = require$$0.fileURLToPath(url2.href), pkgPath = require$$0.fileURLToPath(new require$$0.URL(".", packageJsonUrl)), basePath = require$$0.fileURLToPath(base);
  main ? path__namespace.default.resolve(pkgPath, main) !== urlPath && process3__default.default.emitWarning(
    `Package ${pkgPath} has a "main" field set to "${main}", excluding the full filename and extension to the resolved file at "${urlPath.slice(
      pkgPath.length
    )}", imported from ${basePath}.
 Automatic extension resolution of the "main" field is deprecated for ES modules.`,
    "DeprecationWarning",
    "DEP0151"
  ) : process3__default.default.emitWarning(
    `No "main" or "exports" field defined in the package.json for ${pkgPath} resolving the main entry point "${urlPath.slice(
      pkgPath.length
    )}", imported from ${basePath}.
Default "index" lookups for the main are deprecated for ES modules.`,
    "DeprecationWarning",
    "DEP0151"
  );
}
function tryStatSync(path13) {
  try {
    return require$$0$3.statSync(path13);
  } catch {
    return new require$$0$3.Stats();
  }
}
function fileExists(url2) {
  const stats = require$$0$3.statSync(url2, { throwIfNoEntry: !1 }), isFile2 = stats ? stats.isFile() : void 0;
  return isFile2 ?? !1;
}
function legacyMainResolve(packageJsonUrl, packageConfig, base) {
  let guess;
  if (packageConfig.main !== void 0) {
    if (guess = new require$$0.URL(packageConfig.main, packageJsonUrl), fileExists(guess))
      return guess;
    const tries2 = [
      `./${packageConfig.main}.js`,
      `./${packageConfig.main}.json`,
      `./${packageConfig.main}.node`,
      `./${packageConfig.main}/index.js`,
      `./${packageConfig.main}/index.json`,
      `./${packageConfig.main}/index.node`
    ];
    let i22 = -1;
    for (; ++i22 < tries2.length && (guess = new require$$0.URL(tries2[i22], packageJsonUrl), !fileExists(guess)); )
      guess = void 0;
    if (guess)
      return emitLegacyIndexDeprecation(
        guess,
        packageJsonUrl,
        base,
        packageConfig.main
      ), guess;
  }
  const tries = ["./index.js", "./index.json", "./index.node"];
  let i2 = -1;
  for (; ++i2 < tries.length && (guess = new require$$0.URL(tries[i2], packageJsonUrl), !fileExists(guess)); )
    guess = void 0;
  if (guess)
    return emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main), guess;
  throw new ERR_MODULE_NOT_FOUND(
    require$$0.fileURLToPath(new require$$0.URL(".", packageJsonUrl)),
    require$$0.fileURLToPath(base)
  );
}
function finalizeResolution(resolved, base, preserveSymlinks) {
  if (encodedSepRegEx.exec(resolved.pathname) !== null)
    throw new ERR_INVALID_MODULE_SPECIFIER(
      resolved.pathname,
      'must not include encoded "/" or "\\" characters',
      require$$0.fileURLToPath(base)
    );
  let filePath;
  try {
    filePath = require$$0.fileURLToPath(resolved);
  } catch (error) {
    const cause = (
      /** @type {ErrnoException} */
      error
    );
    throw Object.defineProperty(cause, "input", { value: String(resolved) }), Object.defineProperty(cause, "module", { value: String(base) }), cause;
  }
  const stats = tryStatSync(
    filePath.endsWith("/") ? filePath.slice(-1) : filePath
  );
  if (stats.isDirectory()) {
    const error = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, require$$0.fileURLToPath(base));
    throw error.url = String(resolved), error;
  }
  if (!stats.isFile()) {
    const error = new ERR_MODULE_NOT_FOUND(
      filePath || resolved.pathname,
      base && require$$0.fileURLToPath(base),
      !0
    );
    throw error.url = String(resolved), error;
  }
  if (!preserveSymlinks) {
    const real = require$$0$3.realpathSync(filePath), { search, hash } = resolved;
    resolved = require$$0.pathToFileURL(real + (filePath.endsWith(path__namespace.default.sep) ? "/" : "")), resolved.search = search, resolved.hash = hash;
  }
  return resolved;
}
function importNotDefined(specifier, packageJsonUrl, base) {
  return new ERR_PACKAGE_IMPORT_NOT_DEFINED(
    specifier,
    packageJsonUrl && require$$0.fileURLToPath(new require$$0.URL(".", packageJsonUrl)),
    require$$0.fileURLToPath(base)
  );
}
function exportsNotFound(subpath, packageJsonUrl, base) {
  return new ERR_PACKAGE_PATH_NOT_EXPORTED(
    require$$0.fileURLToPath(new require$$0.URL(".", packageJsonUrl)),
    subpath,
    base && require$$0.fileURLToPath(base)
  );
}
function throwInvalidSubpath(request, match, packageJsonUrl, internal, base) {
  const reason = `request is not a valid match in pattern "${match}" for the "${internal ? "imports" : "exports"}" resolution of ${require$$0.fileURLToPath(packageJsonUrl)}`;
  throw new ERR_INVALID_MODULE_SPECIFIER(
    request,
    reason,
    base && require$$0.fileURLToPath(base)
  );
}
function invalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {
  return target = typeof target == "object" && target !== null ? JSON.stringify(target, null, "") : `${target}`, new ERR_INVALID_PACKAGE_TARGET(
    require$$0.fileURLToPath(new require$$0.URL(".", packageJsonUrl)),
    subpath,
    target,
    internal,
    base && require$$0.fileURLToPath(base)
  );
}
function resolvePackageTargetString(target, subpath, match, packageJsonUrl, base, pattern, internal, isPathMap, conditions) {
  if (subpath !== "" && !pattern && target[target.length - 1] !== "/")
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  if (!target.startsWith("./")) {
    if (internal && !target.startsWith("../") && !target.startsWith("/")) {
      let isURL2 = !1;
      try {
        new require$$0.URL(target), isURL2 = !0;
      } catch {
      }
      if (!isURL2) {
        const exportTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target + subpath;
        return packageResolve(exportTarget, packageJsonUrl, conditions);
      }
    }
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  }
  if (invalidSegmentRegEx.exec(target.slice(2)) !== null)
    if (deprecatedInvalidSegmentRegEx.exec(target.slice(2)) === null) {
      if (!isPathMap) {
        const request = pattern ? match.replace("*", () => subpath) : match + subpath, resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target;
        emitInvalidSegmentDeprecation(
          resolvedTarget,
          request,
          match,
          packageJsonUrl,
          internal,
          base,
          !0
        );
      }
    } else
      throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  const resolved = new require$$0.URL(target, packageJsonUrl), resolvedPath = resolved.pathname, packagePath = new require$$0.URL(".", packageJsonUrl).pathname;
  if (!resolvedPath.startsWith(packagePath))
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  if (subpath === "")
    return resolved;
  if (invalidSegmentRegEx.exec(subpath) !== null) {
    const request = pattern ? match.replace("*", () => subpath) : match + subpath;
    if (deprecatedInvalidSegmentRegEx.exec(subpath) === null) {
      if (!isPathMap) {
        const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target;
        emitInvalidSegmentDeprecation(
          resolvedTarget,
          request,
          match,
          packageJsonUrl,
          internal,
          base,
          !1
        );
      }
    } else
      throwInvalidSubpath(request, match, packageJsonUrl, internal, base);
  }
  return pattern ? new require$$0.URL(
    RegExpPrototypeSymbolReplace.call(
      patternRegEx,
      resolved.href,
      () => subpath
    )
  ) : new require$$0.URL(subpath, resolved);
}
function isArrayIndex(key2) {
  const keyNumber = Number(key2);
  return `${keyNumber}` !== key2 ? !1 : keyNumber >= 0 && keyNumber < 4294967295;
}
function resolvePackageTarget(packageJsonUrl, target, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions) {
  if (typeof target == "string")
    return resolvePackageTargetString(
      target,
      subpath,
      packageSubpath,
      packageJsonUrl,
      base,
      pattern,
      internal,
      isPathMap,
      conditions
    );
  if (Array.isArray(target)) {
    const targetList = target;
    if (targetList.length === 0)
      return null;
    let lastException, i2 = -1;
    for (; ++i2 < targetList.length; ) {
      const targetItem = targetList[i2];
      let resolveResult;
      try {
        resolveResult = resolvePackageTarget(
          packageJsonUrl,
          targetItem,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          isPathMap,
          conditions
        );
      } catch (error) {
        const exception2 = (
          /** @type {ErrnoException} */
          error
        );
        if (lastException = exception2, exception2.code === "ERR_INVALID_PACKAGE_TARGET")
          continue;
        throw error;
      }
      if (resolveResult !== void 0) {
        if (resolveResult === null) {
          lastException = null;
          continue;
        }
        return resolveResult;
      }
    }
    if (lastException == null)
      return null;
    throw lastException;
  }
  if (typeof target == "object" && target !== null) {
    const keys = Object.getOwnPropertyNames(target);
    let i2 = -1;
    for (; ++i2 < keys.length; ) {
      const key2 = keys[i2];
      if (isArrayIndex(key2))
        throw new ERR_INVALID_PACKAGE_CONFIG2(
          require$$0.fileURLToPath(packageJsonUrl),
          base,
          '"exports" cannot contain numeric property keys.'
        );
    }
    for (i2 = -1; ++i2 < keys.length; ) {
      const key2 = keys[i2];
      if (key2 === "default" || conditions && conditions.has(key2)) {
        const conditionalTarget = (
          /** @type {unknown} */
          target[key2]
        ), resolveResult = resolvePackageTarget(
          packageJsonUrl,
          conditionalTarget,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          isPathMap,
          conditions
        );
        if (resolveResult === void 0)
          continue;
        return resolveResult;
      }
    }
    return null;
  }
  if (target === null)
    return null;
  throw invalidPackageTarget(
    packageSubpath,
    target,
    packageJsonUrl,
    internal,
    base
  );
}
function isConditionalExportsMainSugar(exports2, packageJsonUrl, base) {
  if (typeof exports2 == "string" || Array.isArray(exports2))
    return !0;
  if (typeof exports2 != "object" || exports2 === null)
    return !1;
  const keys = Object.getOwnPropertyNames(exports2);
  let isConditionalSugar = !1, i2 = 0, j = -1;
  for (; ++j < keys.length; ) {
    const key2 = keys[j], curIsConditionalSugar = key2 === "" || key2[0] !== ".";
    if (i2++ === 0)
      isConditionalSugar = curIsConditionalSugar;
    else if (isConditionalSugar !== curIsConditionalSugar)
      throw new ERR_INVALID_PACKAGE_CONFIG2(
        require$$0.fileURLToPath(packageJsonUrl),
        base,
        `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`
      );
  }
  return isConditionalSugar;
}
function emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {
  if (process3__default.default.noDeprecation)
    return;
  const pjsonPath = require$$0.fileURLToPath(pjsonUrl);
  emittedPackageWarnings.has(pjsonPath + "|" + match) || (emittedPackageWarnings.add(pjsonPath + "|" + match), process3__default.default.emitWarning(
    `Use of deprecated trailing slash pattern mapping "${match}" in the "exports" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${require$$0.fileURLToPath(base)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`,
    "DeprecationWarning",
    "DEP0155"
  ));
}
function packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
  let exports2 = packageConfig.exports;
  if (isConditionalExportsMainSugar(exports2, packageJsonUrl, base) && (exports2 = { ".": exports2 }), own2.call(exports2, packageSubpath) && !packageSubpath.includes("*") && !packageSubpath.endsWith("/")) {
    const target = exports2[packageSubpath], resolveResult = resolvePackageTarget(
      packageJsonUrl,
      target,
      "",
      packageSubpath,
      base,
      !1,
      !1,
      !1,
      conditions
    );
    if (resolveResult == null)
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    return resolveResult;
  }
  let bestMatch = "", bestMatchSubpath = "";
  const keys = Object.getOwnPropertyNames(exports2);
  let i2 = -1;
  for (; ++i2 < keys.length; ) {
    const key2 = keys[i2], patternIndex = key2.indexOf("*");
    if (patternIndex !== -1 && packageSubpath.startsWith(key2.slice(0, patternIndex))) {
      packageSubpath.endsWith("/") && emitTrailingSlashPatternDeprecation(
        packageSubpath,
        packageJsonUrl,
        base
      );
      const patternTrailer = key2.slice(patternIndex + 1);
      packageSubpath.length >= key2.length && packageSubpath.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key2) === 1 && key2.lastIndexOf("*") === patternIndex && (bestMatch = key2, bestMatchSubpath = packageSubpath.slice(
        patternIndex,
        packageSubpath.length - patternTrailer.length
      ));
    }
  }
  if (bestMatch) {
    const target = (
      /** @type {unknown} */
      exports2[bestMatch]
    ), resolveResult = resolvePackageTarget(
      packageJsonUrl,
      target,
      bestMatchSubpath,
      bestMatch,
      base,
      !0,
      !1,
      packageSubpath.endsWith("/"),
      conditions
    );
    if (resolveResult == null)
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    return resolveResult;
  }
  throw exportsNotFound(packageSubpath, packageJsonUrl, base);
}
function patternKeyCompare(a, b) {
  const aPatternIndex = a.indexOf("*"), bPatternIndex = b.indexOf("*"), baseLengthA = aPatternIndex === -1 ? a.length : aPatternIndex + 1, baseLengthB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
  return baseLengthA > baseLengthB ? -1 : baseLengthB > baseLengthA || aPatternIndex === -1 ? 1 : bPatternIndex === -1 || a.length > b.length ? -1 : b.length > a.length ? 1 : 0;
}
function packageImportsResolve(name, base, conditions) {
  if (name === "#" || name.startsWith("#/") || name.endsWith("/")) {
    const reason = "is not a valid internal imports specifier name";
    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, require$$0.fileURLToPath(base));
  }
  let packageJsonUrl;
  const packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    packageJsonUrl = require$$0.pathToFileURL(packageConfig.pjsonPath);
    const imports = packageConfig.imports;
    if (imports)
      if (own2.call(imports, name) && !name.includes("*")) {
        const resolveResult = resolvePackageTarget(
          packageJsonUrl,
          imports[name],
          "",
          name,
          base,
          !1,
          !0,
          !1,
          conditions
        );
        if (resolveResult != null)
          return resolveResult;
      } else {
        let bestMatch = "", bestMatchSubpath = "";
        const keys = Object.getOwnPropertyNames(imports);
        let i2 = -1;
        for (; ++i2 < keys.length; ) {
          const key2 = keys[i2], patternIndex = key2.indexOf("*");
          if (patternIndex !== -1 && name.startsWith(key2.slice(0, -1))) {
            const patternTrailer = key2.slice(patternIndex + 1);
            name.length >= key2.length && name.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key2) === 1 && key2.lastIndexOf("*") === patternIndex && (bestMatch = key2, bestMatchSubpath = name.slice(
              patternIndex,
              name.length - patternTrailer.length
            ));
          }
        }
        if (bestMatch) {
          const target = imports[bestMatch], resolveResult = resolvePackageTarget(
            packageJsonUrl,
            target,
            bestMatchSubpath,
            bestMatch,
            base,
            !0,
            !0,
            !1,
            conditions
          );
          if (resolveResult != null)
            return resolveResult;
        }
      }
  }
  throw importNotDefined(name, packageJsonUrl, base);
}
function parsePackageName(specifier, base) {
  let separatorIndex = specifier.indexOf("/"), validPackageName = !0, isScoped = !1;
  specifier[0] === "@" && (isScoped = !0, separatorIndex === -1 || specifier.length === 0 ? validPackageName = !1 : separatorIndex = specifier.indexOf("/", separatorIndex + 1));
  const packageName = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);
  if (invalidPackageNameRegEx.exec(packageName) !== null && (validPackageName = !1), !validPackageName)
    throw new ERR_INVALID_MODULE_SPECIFIER(
      specifier,
      "is not a valid package name",
      require$$0.fileURLToPath(base)
    );
  const packageSubpath = "." + (separatorIndex === -1 ? "" : specifier.slice(separatorIndex));
  return { packageName, packageSubpath, isScoped };
}
function packageResolve(specifier, base, conditions) {
  if (require$$1.builtinModules.includes(specifier))
    return new require$$0.URL("node:" + specifier);
  const { packageName, packageSubpath, isScoped } = parsePackageName(
    specifier,
    base
  ), packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    const packageJsonUrl2 = require$$0.pathToFileURL(packageConfig.pjsonPath);
    if (packageConfig.name === packageName && packageConfig.exports !== void 0 && packageConfig.exports !== null)
      return packageExportsResolve(
        packageJsonUrl2,
        packageSubpath,
        packageConfig,
        base,
        conditions
      );
  }
  let packageJsonUrl = new require$$0.URL(
    "./node_modules/" + packageName + "/package.json",
    base
  ), packageJsonPath = require$$0.fileURLToPath(packageJsonUrl), lastPath;
  do {
    if (!tryStatSync(packageJsonPath.slice(0, -13)).isDirectory()) {
      lastPath = packageJsonPath, packageJsonUrl = new require$$0.URL(
        (isScoped ? "../../../../node_modules/" : "../../../node_modules/") + packageName + "/package.json",
        packageJsonUrl
      ), packageJsonPath = require$$0.fileURLToPath(packageJsonUrl);
      continue;
    }
    const packageConfig2 = package_json_reader_default.read(packageJsonPath, {
      base,
      specifier
    });
    return packageConfig2.exports !== void 0 && packageConfig2.exports !== null ? packageExportsResolve(
      packageJsonUrl,
      packageSubpath,
      packageConfig2,
      base,
      conditions
    ) : packageSubpath === "." ? legacyMainResolve(packageJsonUrl, packageConfig2, base) : new require$$0.URL(packageSubpath, packageJsonUrl);
  } while (packageJsonPath.length !== lastPath.length);
  throw new ERR_MODULE_NOT_FOUND(packageName, require$$0.fileURLToPath(base), !1);
}
function isRelativeSpecifier(specifier) {
  return specifier[0] === "." && (specifier.length === 1 || specifier[1] === "/" || specifier[1] === "." && (specifier.length === 2 || specifier[2] === "/"));
}
function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
  return specifier === "" ? !1 : specifier[0] === "/" ? !0 : isRelativeSpecifier(specifier);
}
function moduleResolve(specifier, base, conditions, preserveSymlinks) {
  const protocol = base.protocol, isRemote = protocol === "http:" || protocol === "https:";
  let resolved;
  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier))
    resolved = new require$$0.URL(specifier, base);
  else if (!isRemote && specifier[0] === "#")
    resolved = packageImportsResolve(specifier, base, conditions);
  else
    try {
      resolved = new require$$0.URL(specifier);
    } catch {
      isRemote || (resolved = packageResolve(specifier, base, conditions));
    }
  return require$$1__default.default(resolved !== void 0, "expected to be defined"), resolved.protocol !== "file:" ? resolved : finalizeResolution(resolved, base, preserveSymlinks);
}
function checkIfDisallowedImport(specifier, parsed, parsedParentURL) {
  if (parsedParentURL) {
    const parentProtocol = parsedParentURL.protocol;
    if (parentProtocol === "http:" || parentProtocol === "https:") {
      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
        const parsedProtocol = parsed?.protocol;
        if (parsedProtocol && parsedProtocol !== "https:" && parsedProtocol !== "http:")
          throw new ERR_NETWORK_IMPORT_DISALLOWED(
            specifier,
            parsedParentURL,
            "remote imports cannot import from a local location."
          );
        return { url: parsed?.href || "" };
      }
      throw require$$1.builtinModules.includes(specifier) ? new ERR_NETWORK_IMPORT_DISALLOWED(
        specifier,
        parsedParentURL,
        "remote imports cannot import from a local location."
      ) : new ERR_NETWORK_IMPORT_DISALLOWED(
        specifier,
        parsedParentURL,
        "only relative and absolute specifiers are supported."
      );
    }
  }
}
function isURL(self) {
  return !!(self && typeof self == "object" && "href" in self && typeof self.href == "string" && "protocol" in self && typeof self.protocol == "string" && self.href && self.protocol);
}
function throwIfInvalidParentURL(parentURL) {
  if (parentURL !== void 0 && typeof parentURL != "string" && !isURL(parentURL))
    throw new codes.ERR_INVALID_ARG_TYPE(
      "parentURL",
      ["string", "URL"],
      parentURL
    );
}
function defaultResolve(specifier, context = {}) {
  const { parentURL } = context;
  require$$1__default.default(parentURL !== void 0, "expected `parentURL` to be defined"), throwIfInvalidParentURL(parentURL);
  let parsedParentURL;
  if (parentURL)
    try {
      parsedParentURL = new require$$0.URL(parentURL);
    } catch {
    }
  let parsed;
  try {
    if (parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier) ? new require$$0.URL(specifier, parsedParentURL) : new require$$0.URL(specifier), parsed.protocol === "data:")
      return { url: parsed.href, format: null };
  } catch {
  }
  const maybeReturn = checkIfDisallowedImport(
    specifier,
    parsed,
    parsedParentURL
  );
  if (maybeReturn)
    return maybeReturn;
  if (parsed && parsed.protocol === "node:")
    return { url: specifier };
  const conditions = getConditionsSet(context.conditions), url2 = moduleResolve(specifier, new require$$0.URL(parentURL), conditions, !1);
  return {
    // Do NOT cast `url` to a string: that will work even when there are real
    // problems, silencing them
    url: url2.href,
    format: defaultGetFormatWithoutErrors(url2, { parentURL })
  };
}
function resolve2(specifier, parent) {
  if (!parent)
    throw new Error(
      "Please pass `parent`: `import-meta-resolve` cannot ponyfill that"
    );
  try {
    return defaultResolve(specifier, { parentURL: parent }).url;
  } catch (error) {
    const exception2 = (
      /** @type {ErrnoException} */
      error
    );
    if ((exception2.code === "ERR_UNSUPPORTED_DIR_IMPORT" || exception2.code === "ERR_MODULE_NOT_FOUND") && typeof exception2.url == "string")
      return exception2.url;
    throw error;
  }
}
function importFromFile(specifier, parent) {
  return import(resolve2(specifier, require$$0.pathToFileURL(parent).href));
}
var import_from_file_default = importFromFile;
function requireFromFile(id, parent) {
  return require$$1.createRequire(parent)(id);
}
var require_from_file_default = requireFromFile, requireErrorCodesShouldBeIgnored = /* @__PURE__ */ new Set([
  "MODULE_NOT_FOUND",
  "ERR_REQUIRE_ESM",
  "ERR_PACKAGE_PATH_NOT_EXPORTED"
]);
async function loadExternalConfig(externalConfig, configFile) {
  try {
    return require_from_file_default(externalConfig, configFile);
  } catch (error) {
    if (!requireErrorCodesShouldBeIgnored.has(error?.code))
      throw error;
  }
  return (await import_from_file_default(externalConfig, configFile)).default;
}
var load_external_config_default = loadExternalConfig;
async function loadConfig(configFile) {
  const { base: fileName, ext: extension } = path__namespace.default.parse(configFile), load2 = fileName === "package.json" ? loadConfigFromPackageJson : loaders_default[extension];
  if (!load2)
    throw new Error(
      `No loader specified for extension "${extension || "noExt"}"`
    );
  let config = await load2(configFile);
  if (config) {
    if (typeof config == "string" && (config = await load_external_config_default(config, configFile)), typeof config != "object")
      throw new TypeError(
        `Config is only allowed to be an object, but received ${typeof config} in "${configFile}"`
      );
    return delete config.$schema, config;
  }
}
var load_config_default = loadConfig, loadCache = /* @__PURE__ */ new Map(), searchCache = /* @__PURE__ */ new Map();
function clearPrettierConfigCache() {
  loadCache.clear(), searchCache.clear();
}
function loadPrettierConfig(configFile, { shouldCache }) {
  return configFile = path__namespace.default.resolve(configFile), (!shouldCache || !loadCache.has(configFile)) && loadCache.set(configFile, load_config_default(configFile)), loadCache.get(configFile);
}
function getSearchFunction(stopDirectory) {
  if (stopDirectory = stopDirectory ? path__namespace.default.resolve(stopDirectory) : void 0, !searchCache.has(stopDirectory)) {
    const searcher2 = config_searcher_default(stopDirectory), searchFunction = searcher2.search.bind(searcher2);
    searchCache.set(stopDirectory, searchFunction);
  }
  return searchCache.get(stopDirectory);
}
function searchPrettierConfig(startDirectory, options8 = {}) {
  startDirectory = startDirectory ? path__namespace.default.resolve(startDirectory) : process.cwd();
  const stopDirectory = mockable_default.getPrettierConfigSearchStopDirectory();
  return getSearchFunction(stopDirectory)(startDirectory, { shouldCache: options8.shouldCache });
}
function clearCache() {
  clearPrettierConfigCache(), clearEditorconfigCache();
}
function loadEditorconfig2(file, options8) {
  if (!file || !options8.editorconfig)
    return;
  const shouldCache = options8.useCache;
  return loadEditorconfig(file, { shouldCache });
}
async function loadPrettierConfig2(file, options8) {
  const shouldCache = options8.useCache;
  let configFile = options8.config;
  if (!configFile) {
    const directory = file ? path__namespace.default.dirname(path__namespace.default.resolve(file)) : void 0;
    configFile = await searchPrettierConfig(directory, { shouldCache });
  }
  return configFile ? { config: await loadPrettierConfig(configFile, { shouldCache }), configFile } : void 0;
}
async function resolveConfig(fileUrlOrPath, options8) {
  options8 = { useCache: !0, ...options8 };
  const filePath = toPath(fileUrlOrPath), [result, editorConfigured] = await Promise.all([
    loadPrettierConfig2(filePath, options8),
    loadEditorconfig2(filePath, options8)
  ]);
  if (!result && !editorConfigured)
    return null;
  const merged = {
    ...editorConfigured,
    ...mergeOverrides(result, filePath)
  };
  return Array.isArray(merged.plugins) && (merged.plugins = merged.plugins.map(
    (value) => typeof value == "string" && value.startsWith(".") ? path__namespace.default.resolve(path__namespace.default.dirname(result.configFile), value) : value
  )), merged;
}
async function resolveConfigFile(fileUrlOrPath) {
  const directory = fileUrlOrPath ? path__namespace.default.dirname(path__namespace.default.resolve(toPath(fileUrlOrPath))) : void 0;
  return await searchPrettierConfig(directory, { shouldCache: !1 }) ?? null;
}
function mergeOverrides(configResult, filePath) {
  const { config, configFile } = configResult || {}, { overrides, ...options8 } = config || {};
  if (filePath && overrides) {
    const relativeFilePath = path__namespace.default.relative(path__namespace.default.dirname(configFile), filePath);
    for (const override of overrides)
      pathMatchesGlobs(
        relativeFilePath,
        override.files,
        override.excludeFiles
      ) && Object.assign(options8, override.options);
  }
  return options8;
}
function pathMatchesGlobs(filePath, patterns, excludedPatterns) {
  const patternList = Array.isArray(patterns) ? patterns : [patterns], [withSlashes, withoutSlashes] = partition_default(
    patternList,
    (pattern) => pattern.includes("/")
  );
  return import_micromatch.default.isMatch(filePath, withoutSlashes, {
    ignore: excludedPatterns,
    basename: !0,
    dot: !0
  }) || import_micromatch.default.isMatch(filePath, withSlashes, {
    ignore: excludedPatterns,
    basename: !1,
    dot: !0
  });
}
var stringReplaceAll2 = (isOptionalObject, original, pattern, replacement) => {
  if (!(isOptionalObject && original == null))
    return original.replaceAll ? original.replaceAll(pattern, replacement) : pattern.global ? original.replace(pattern, replacement) : original.split(pattern).join(replacement);
}, string_replace_all_default = stringReplaceAll2, import_ignore = __toESM(require_ignore(), 1), createIgnore = import_ignore.default.default, slash = path__namespace.default.sep === "\\" ? (filePath) => string_replace_all_default(
  /* isOptionalObject*/
  !1,
  filePath,
  "\\",
  "/"
) : (filePath) => filePath;
function getRelativePath(file, ignoreFile) {
  const ignoreFilePath = toPath(ignoreFile), filePath = isUrl(file) ? require$$0__default$1.default.fileURLToPath(file) : path__namespace.default.resolve(file);
  return path__namespace.default.relative(
    // If there's an ignore-path set, the filename must be relative to the
    // ignore path, not the current working directory.
    ignoreFilePath ? path__namespace.default.dirname(ignoreFilePath) : process.cwd(),
    filePath
  );
}
async function createSingleIsIgnoredFunction(ignoreFile, withNodeModules) {
  let content = "";
  if (ignoreFile && (content += await read_file_default(ignoreFile) ?? ""), withNodeModules || (content += `
node_modules`), !content)
    return;
  const ignore = createIgnore({
    allowRelativePaths: !0
  }).add(content);
  return (file) => ignore.ignores(slash(getRelativePath(file, ignoreFile)));
}
async function createIsIgnoredFunction(ignoreFiles, withNodeModules) {
  ignoreFiles.length === 0 && !withNodeModules && (ignoreFiles = [void 0]);
  const isIgnoredFunctions = (await Promise.all(ignoreFiles.map((ignoreFile) => createSingleIsIgnoredFunction(ignoreFile, withNodeModules)))).filter(Boolean);
  return (file) => isIgnoredFunctions.some((isIgnored2) => isIgnored2(file));
}
async function isIgnored(file, options8) {
  const {
    ignorePath: ignoreFiles,
    withNodeModules
  } = options8;
  return (await createIsIgnoredFunction(ignoreFiles, withNodeModules))(file);
}
var import_n_readlines = __toESM(require_readlines(), 1);
function getInterpreter(file) {
  let fd;
  try {
    fd = require$$0__default$2.default.openSync(file, "r");
  } catch {
    return;
  }
  try {
    const firstLine = new import_n_readlines.default(fd).next().toString("utf8"), m1 = firstLine.match(/^#!\/(?:usr\/)?bin\/env\s+(\S+)/);
    if (m1)
      return m1[1];
    const m2 = firstLine.match(/^#!\/(?:usr\/(?:local\/)?)?bin\/(\S+)/);
    if (m2)
      return m2[1];
  } finally {
    try {
      require$$0__default$2.default.closeSync(fd);
    } catch {
    }
  }
}
var get_interpreter_default = getInterpreter, getFileBasename = (file) => String(file).split(/[/\\]/).pop();
function getLanguageByFileName(languages2, file) {
  if (!file)
    return;
  const basename = getFileBasename(file).toLowerCase();
  return languages2.find(
    ({ filenames }) => filenames?.some((name) => name.toLowerCase() === basename)
  ) ?? languages2.find(
    ({ extensions }) => extensions?.some((extension) => basename.endsWith(extension))
  );
}
function getLanguageByLanguageName(languages2, languageName) {
  if (languageName)
    return languages2.find(({ name }) => name.toLowerCase() === languageName) ?? languages2.find(({ aliases }) => aliases?.includes(languageName)) ?? languages2.find(({ extensions }) => extensions?.includes(`.${languageName}`));
}
function getLanguageByInterpreter(languages2, file) {
  if (!file || getFileBasename(file).includes("."))
    return;
  const interpreter = get_interpreter_default(file);
  if (interpreter)
    return languages2.find(
      ({ interpreters }) => interpreters?.includes(interpreter)
    );
}
function inferParser(options8, fileInfo) {
  const languages2 = options8.plugins.flatMap(
    (plugin) => (
      // @ts-expect-error -- Safe
      plugin.languages ?? []
    )
  ), language = getLanguageByLanguageName(languages2, fileInfo.language) ?? getLanguageByFileName(languages2, fileInfo.physicalFile) ?? getLanguageByFileName(languages2, fileInfo.file) ?? getLanguageByInterpreter(languages2, fileInfo.physicalFile);
  return language?.parsers[0];
}
var infer_parser_default = inferParser;
async function getFileInfo(file, options8) {
  if (typeof file != "string" && !(file instanceof URL))
    throw new TypeError(
      `expect \`file\` to be a string or URL, got \`${typeof file}\``
    );
  let { ignorePath, withNodeModules } = options8;
  Array.isArray(ignorePath) || (ignorePath = [ignorePath]);
  const ignored = await isIgnored(file, { ignorePath, withNodeModules });
  let inferredParser;
  return ignored || (inferredParser = await getParser(file, options8)), {
    ignored,
    inferredParser: inferredParser ?? null
  };
}
async function getParser(file, options8) {
  let config;
  return options8.resolveConfig !== !1 && (config = await resolveConfig(file)), config?.parser ?? infer_parser_default(options8, { physicalFile: file });
}
var get_file_info_default = getFileInfo, import_diff = __toESM(require_array2(), 1);
function guessEndOfLine(text) {
  const index = text.indexOf("\r");
  return index >= 0 ? text.charAt(index + 1) === `
` ? "crlf" : "cr" : "lf";
}
function convertEndOfLineToChars(value) {
  switch (value) {
    case "cr":
      return "\r";
    case "crlf":
      return `\r
`;
    default:
      return `
`;
  }
}
function countEndOfLineChars(text, eol) {
  let regex;
  switch (eol) {
    case `
`:
      regex = /\n/g;
      break;
    case "\r":
      regex = /\r/g;
      break;
    case `\r
`:
      regex = /\r\n/g;
      break;
    default:
      throw new Error(`Unexpected "eol" ${JSON.stringify(eol)}.`);
  }
  const endOfLines = text.match(regex);
  return endOfLines ? endOfLines.length : 0;
}
function normalizeEndOfLine(text) {
  return string_replace_all_default(
    /* isOptionalObject*/
    !1,
    text,
    /\r\n?/g,
    `
`
  );
}
var DOC_TYPE_STRING = "string", DOC_TYPE_ARRAY = "array", DOC_TYPE_CURSOR = "cursor", DOC_TYPE_INDENT = "indent", DOC_TYPE_ALIGN = "align", DOC_TYPE_TRIM = "trim", DOC_TYPE_GROUP = "group", DOC_TYPE_FILL = "fill", DOC_TYPE_IF_BREAK = "if-break", DOC_TYPE_INDENT_IF_BREAK = "indent-if-break", DOC_TYPE_LINE_SUFFIX = "line-suffix", DOC_TYPE_LINE_SUFFIX_BOUNDARY = "line-suffix-boundary", DOC_TYPE_LINE = "line", DOC_TYPE_LABEL = "label", DOC_TYPE_BREAK_PARENT = "break-parent", VALID_OBJECT_DOC_TYPES = /* @__PURE__ */ new Set([
  DOC_TYPE_CURSOR,
  DOC_TYPE_INDENT,
  DOC_TYPE_ALIGN,
  DOC_TYPE_TRIM,
  DOC_TYPE_GROUP,
  DOC_TYPE_FILL,
  DOC_TYPE_IF_BREAK,
  DOC_TYPE_INDENT_IF_BREAK,
  DOC_TYPE_LINE_SUFFIX,
  DOC_TYPE_LINE_SUFFIX_BOUNDARY,
  DOC_TYPE_LINE,
  DOC_TYPE_LABEL,
  DOC_TYPE_BREAK_PARENT
]);
function getDocType(doc2) {
  if (typeof doc2 == "string")
    return DOC_TYPE_STRING;
  if (Array.isArray(doc2))
    return DOC_TYPE_ARRAY;
  if (!doc2)
    return;
  const { type: type2 } = doc2;
  if (VALID_OBJECT_DOC_TYPES.has(type2))
    return type2;
}
var get_doc_type_default = getDocType, disjunctionListFormat = (list) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(list);
function getDocErrorMessage(doc2) {
  const type2 = doc2 === null ? "null" : typeof doc2;
  if (type2 !== "string" && type2 !== "object")
    return `Unexpected doc '${type2}', 
Expected it to be 'string' or 'object'.`;
  if (get_doc_type_default(doc2))
    throw new Error("doc is valid.");
  const objectType = Object.prototype.toString.call(doc2);
  if (objectType !== "[object Object]")
    return `Unexpected doc '${objectType}'.`;
  const EXPECTED_TYPE_VALUES = disjunctionListFormat(
    [...VALID_OBJECT_DOC_TYPES].map((type3) => `'${type3}'`)
  );
  return `Unexpected doc.type '${doc2.type}'.
Expected it to be ${EXPECTED_TYPE_VALUES}.`;
}
var InvalidDocError2 = class extends Error {
  name = "InvalidDocError";
  constructor(doc2) {
    super(getDocErrorMessage(doc2)), this.doc = doc2;
  }
}, invalid_doc_error_default = InvalidDocError2, traverseDocOnExitStackMarker = {};
function traverseDoc(doc2, onEnter, onExit, shouldTraverseConditionalGroups) {
  const docsStack = [doc2];
  for (; docsStack.length > 0; ) {
    const doc3 = docsStack.pop();
    if (doc3 === traverseDocOnExitStackMarker) {
      onExit(docsStack.pop());
      continue;
    }
    onExit && docsStack.push(doc3, traverseDocOnExitStackMarker);
    const docType = get_doc_type_default(doc3);
    if (!docType)
      throw new invalid_doc_error_default(doc3);
    if (onEnter?.(doc3) !== !1)
      switch (docType) {
        case DOC_TYPE_ARRAY:
        case DOC_TYPE_FILL: {
          const parts = docType === DOC_TYPE_ARRAY ? doc3 : doc3.parts;
          for (let ic = parts.length, i2 = ic - 1; i2 >= 0; --i2)
            docsStack.push(parts[i2]);
          break;
        }
        case DOC_TYPE_IF_BREAK:
          docsStack.push(doc3.flatContents, doc3.breakContents);
          break;
        case DOC_TYPE_GROUP:
          if (shouldTraverseConditionalGroups && doc3.expandedStates)
            for (let ic = doc3.expandedStates.length, i2 = ic - 1; i2 >= 0; --i2)
              docsStack.push(doc3.expandedStates[i2]);
          else
            docsStack.push(doc3.contents);
          break;
        case DOC_TYPE_ALIGN:
        case DOC_TYPE_INDENT:
        case DOC_TYPE_INDENT_IF_BREAK:
        case DOC_TYPE_LABEL:
        case DOC_TYPE_LINE_SUFFIX:
          docsStack.push(doc3.contents);
          break;
        case DOC_TYPE_STRING:
        case DOC_TYPE_CURSOR:
        case DOC_TYPE_TRIM:
        case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
        case DOC_TYPE_LINE:
        case DOC_TYPE_BREAK_PARENT:
          break;
        default:
          throw new invalid_doc_error_default(doc3);
      }
  }
}
var traverse_doc_default = traverseDoc;
function indent(contents) {
  return { type: DOC_TYPE_INDENT, contents };
}
function align(widthOrString, contents) {
  return { type: DOC_TYPE_ALIGN, contents, n: widthOrString };
}
function fill(parts) {
  return { type: DOC_TYPE_FILL, parts };
}
function lineSuffix(contents) {
  return { type: DOC_TYPE_LINE_SUFFIX, contents };
}
var breakParent = { type: DOC_TYPE_BREAK_PARENT }, hardlineWithoutBreakParent = { type: DOC_TYPE_LINE, hard: !0 }, line2 = { type: DOC_TYPE_LINE }, hardline = [hardlineWithoutBreakParent, breakParent], cursor = { type: DOC_TYPE_CURSOR };
function addAlignmentToDoc(doc2, size, tabWidth) {
  let aligned = doc2;
  if (size > 0) {
    for (let i2 = 0; i2 < Math.floor(size / tabWidth); ++i2)
      aligned = indent(aligned);
    aligned = align(size % tabWidth, aligned), aligned = align(Number.NEGATIVE_INFINITY, aligned);
  }
  return aligned;
}
function flattenDoc(doc2) {
  var _a;
  if (!doc2)
    return "";
  if (Array.isArray(doc2)) {
    const res = [];
    for (const part of doc2)
      if (Array.isArray(part))
        res.push(...flattenDoc(part));
      else {
        const flattened = flattenDoc(part);
        flattened !== "" && res.push(flattened);
      }
    return res;
  }
  return doc2.type === DOC_TYPE_IF_BREAK ? {
    ...doc2,
    breakContents: flattenDoc(doc2.breakContents),
    flatContents: flattenDoc(doc2.flatContents)
  } : doc2.type === DOC_TYPE_GROUP ? {
    ...doc2,
    contents: flattenDoc(doc2.contents),
    expandedStates: (_a = doc2.expandedStates) == null ? void 0 : _a.map(flattenDoc)
  } : doc2.type === DOC_TYPE_FILL ? { type: "fill", parts: doc2.parts.map(flattenDoc) } : doc2.contents ? { ...doc2, contents: flattenDoc(doc2.contents) } : doc2;
}
function printDocToDebug(doc2) {
  const printedSymbols = /* @__PURE__ */ Object.create(null), usedKeysForSymbols = /* @__PURE__ */ new Set();
  return printDoc(flattenDoc(doc2));
  function printDoc(doc3, index, parentParts) {
    var _a, _b;
    if (typeof doc3 == "string")
      return JSON.stringify(doc3);
    if (Array.isArray(doc3)) {
      const printed = doc3.map(printDoc).filter(Boolean);
      return printed.length === 1 ? printed[0] : `[${printed.join(", ")}]`;
    }
    if (doc3.type === DOC_TYPE_LINE) {
      const withBreakParent = ((_a = parentParts?.[index + 1]) == null ? void 0 : _a.type) === DOC_TYPE_BREAK_PARENT;
      return doc3.literal ? withBreakParent ? "literalline" : "literallineWithoutBreakParent" : doc3.hard ? withBreakParent ? "hardline" : "hardlineWithoutBreakParent" : doc3.soft ? "softline" : "line";
    }
    if (doc3.type === DOC_TYPE_BREAK_PARENT)
      return ((_b = parentParts?.[index - 1]) == null ? void 0 : _b.type) === DOC_TYPE_LINE && parentParts[index - 1].hard ? void 0 : "breakParent";
    if (doc3.type === DOC_TYPE_TRIM)
      return "trim";
    if (doc3.type === DOC_TYPE_INDENT)
      return "indent(" + printDoc(doc3.contents) + ")";
    if (doc3.type === DOC_TYPE_ALIGN)
      return doc3.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + printDoc(doc3.contents) + ")" : doc3.n < 0 ? "dedent(" + printDoc(doc3.contents) + ")" : doc3.n.type === "root" ? "markAsRoot(" + printDoc(doc3.contents) + ")" : "align(" + JSON.stringify(doc3.n) + ", " + printDoc(doc3.contents) + ")";
    if (doc3.type === DOC_TYPE_IF_BREAK)
      return "ifBreak(" + printDoc(doc3.breakContents) + (doc3.flatContents ? ", " + printDoc(doc3.flatContents) : "") + (doc3.groupId ? (doc3.flatContents ? "" : ', ""') + `, { groupId: ${printGroupId(doc3.groupId)} }` : "") + ")";
    if (doc3.type === DOC_TYPE_INDENT_IF_BREAK) {
      const optionsParts = [];
      doc3.negate && optionsParts.push("negate: true"), doc3.groupId && optionsParts.push(`groupId: ${printGroupId(doc3.groupId)}`);
      const options8 = optionsParts.length > 0 ? `, { ${optionsParts.join(", ")} }` : "";
      return `indentIfBreak(${printDoc(doc3.contents)}${options8})`;
    }
    if (doc3.type === DOC_TYPE_GROUP) {
      const optionsParts = [];
      doc3.break && doc3.break !== "propagated" && optionsParts.push("shouldBreak: true"), doc3.id && optionsParts.push(`id: ${printGroupId(doc3.id)}`);
      const options8 = optionsParts.length > 0 ? `, { ${optionsParts.join(", ")} }` : "";
      return doc3.expandedStates ? `conditionalGroup([${doc3.expandedStates.map((part) => printDoc(part)).join(",")}]${options8})` : `group(${printDoc(doc3.contents)}${options8})`;
    }
    if (doc3.type === DOC_TYPE_FILL)
      return `fill([${doc3.parts.map((part) => printDoc(part)).join(", ")}])`;
    if (doc3.type === DOC_TYPE_LINE_SUFFIX)
      return "lineSuffix(" + printDoc(doc3.contents) + ")";
    if (doc3.type === DOC_TYPE_LINE_SUFFIX_BOUNDARY)
      return "lineSuffixBoundary";
    if (doc3.type === DOC_TYPE_LABEL)
      return `label(${JSON.stringify(doc3.label)}, ${printDoc(doc3.contents)})`;
    throw new Error("Unknown doc type " + doc3.type);
  }
  function printGroupId(id) {
    if (typeof id != "symbol")
      return JSON.stringify(String(id));
    if (id in printedSymbols)
      return printedSymbols[id];
    const prefix = id.description || "symbol";
    for (let counter = 0; ; counter++) {
      const key2 = prefix + (counter > 0 ? ` #${counter}` : "");
      if (!usedKeysForSymbols.has(key2))
        return usedKeysForSymbols.add(key2), printedSymbols[id] = `Symbol.for(${JSON.stringify(key2)})`;
    }
  }
}
var at = (isOptionalObject, object, index) => {
  if (!(isOptionalObject && object == null))
    return Array.isArray(object) || typeof object == "string" ? object[index < 0 ? object.length + index : index] : object.at(index);
}, at_default = at, emoji_regex_default = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
function isFullWidth(x) {
  return x === 12288 || x >= 65281 && x <= 65376 || x >= 65504 && x <= 65510;
}
function isWide(x) {
  return x >= 4352 && x <= 4447 || x === 8986 || x === 8987 || x === 9001 || x === 9002 || x >= 9193 && x <= 9196 || x === 9200 || x === 9203 || x === 9725 || x === 9726 || x === 9748 || x === 9749 || x >= 9800 && x <= 9811 || x === 9855 || x === 9875 || x === 9889 || x === 9898 || x === 9899 || x === 9917 || x === 9918 || x === 9924 || x === 9925 || x === 9934 || x === 9940 || x === 9962 || x === 9970 || x === 9971 || x === 9973 || x === 9978 || x === 9981 || x === 9989 || x === 9994 || x === 9995 || x === 10024 || x === 10060 || x === 10062 || x >= 10067 && x <= 10069 || x === 10071 || x >= 10133 && x <= 10135 || x === 10160 || x === 10175 || x === 11035 || x === 11036 || x === 11088 || x === 11093 || x >= 11904 && x <= 11929 || x >= 11931 && x <= 12019 || x >= 12032 && x <= 12245 || x >= 12272 && x <= 12287 || x >= 12289 && x <= 12350 || x >= 12353 && x <= 12438 || x >= 12441 && x <= 12543 || x >= 12549 && x <= 12591 || x >= 12593 && x <= 12686 || x >= 12688 && x <= 12771 || x >= 12783 && x <= 12830 || x >= 12832 && x <= 12871 || x >= 12880 && x <= 19903 || x >= 19968 && x <= 42124 || x >= 42128 && x <= 42182 || x >= 43360 && x <= 43388 || x >= 44032 && x <= 55203 || x >= 63744 && x <= 64255 || x >= 65040 && x <= 65049 || x >= 65072 && x <= 65106 || x >= 65108 && x <= 65126 || x >= 65128 && x <= 65131 || x >= 94176 && x <= 94180 || x === 94192 || x === 94193 || x >= 94208 && x <= 100343 || x >= 100352 && x <= 101589 || x >= 101632 && x <= 101640 || x >= 110576 && x <= 110579 || x >= 110581 && x <= 110587 || x === 110589 || x === 110590 || x >= 110592 && x <= 110882 || x === 110898 || x >= 110928 && x <= 110930 || x === 110933 || x >= 110948 && x <= 110951 || x >= 110960 && x <= 111355 || x === 126980 || x === 127183 || x === 127374 || x >= 127377 && x <= 127386 || x >= 127488 && x <= 127490 || x >= 127504 && x <= 127547 || x >= 127552 && x <= 127560 || x === 127568 || x === 127569 || x >= 127584 && x <= 127589 || x >= 127744 && x <= 127776 || x >= 127789 && x <= 127797 || x >= 127799 && x <= 127868 || x >= 127870 && x <= 127891 || x >= 127904 && x <= 127946 || x >= 127951 && x <= 127955 || x >= 127968 && x <= 127984 || x === 127988 || x >= 127992 && x <= 128062 || x === 128064 || x >= 128066 && x <= 128252 || x >= 128255 && x <= 128317 || x >= 128331 && x <= 128334 || x >= 128336 && x <= 128359 || x === 128378 || x === 128405 || x === 128406 || x === 128420 || x >= 128507 && x <= 128591 || x >= 128640 && x <= 128709 || x === 128716 || x >= 128720 && x <= 128722 || x >= 128725 && x <= 128727 || x >= 128732 && x <= 128735 || x === 128747 || x === 128748 || x >= 128756 && x <= 128764 || x >= 128992 && x <= 129003 || x === 129008 || x >= 129292 && x <= 129338 || x >= 129340 && x <= 129349 || x >= 129351 && x <= 129535 || x >= 129648 && x <= 129660 || x >= 129664 && x <= 129672 || x >= 129680 && x <= 129725 || x >= 129727 && x <= 129733 || x >= 129742 && x <= 129755 || x >= 129760 && x <= 129768 || x >= 129776 && x <= 129784 || x >= 131072 && x <= 196605 || x >= 196608 && x <= 262141;
}
var _isNarrowWidth = (codePoint) => !(isFullWidth(codePoint) || isWide(codePoint)), notAsciiRegex = /[^\x20-\x7F]/;
function getStringWidth(text) {
  if (!text)
    return 0;
  if (!notAsciiRegex.test(text))
    return text.length;
  text = text.replace(emoji_regex_default(), "  ");
  let width = 0;
  for (const character of text) {
    const codePoint = character.codePointAt(0);
    codePoint <= 31 || codePoint >= 127 && codePoint <= 159 || codePoint >= 768 && codePoint <= 879 || (width += _isNarrowWidth(codePoint) ? 1 : 2);
  }
  return width;
}
var get_string_width_default = getStringWidth, getDocParts = (doc2) => {
  if (Array.isArray(doc2))
    return doc2;
  if (doc2.type !== DOC_TYPE_FILL)
    throw new Error(`Expect doc to be 'array' or '${DOC_TYPE_FILL}'.`);
  return doc2.parts;
};
function mapDoc(doc2, cb) {
  if (typeof doc2 == "string")
    return cb(doc2);
  const mapped = /* @__PURE__ */ new Map();
  return rec(doc2);
  function rec(doc3) {
    if (mapped.has(doc3))
      return mapped.get(doc3);
    const result = process4(doc3);
    return mapped.set(doc3, result), result;
  }
  function process4(doc3) {
    switch (get_doc_type_default(doc3)) {
      case DOC_TYPE_ARRAY:
        return cb(doc3.map(rec));
      case DOC_TYPE_FILL:
        return cb({
          ...doc3,
          parts: doc3.parts.map(rec)
        });
      case DOC_TYPE_IF_BREAK:
        return cb({
          ...doc3,
          breakContents: rec(doc3.breakContents),
          flatContents: rec(doc3.flatContents)
        });
      case DOC_TYPE_GROUP: {
        let {
          expandedStates,
          contents
        } = doc3;
        return expandedStates ? (expandedStates = expandedStates.map(rec), contents = expandedStates[0]) : contents = rec(contents), cb({
          ...doc3,
          contents,
          expandedStates
        });
      }
      case DOC_TYPE_ALIGN:
      case DOC_TYPE_INDENT:
      case DOC_TYPE_INDENT_IF_BREAK:
      case DOC_TYPE_LABEL:
      case DOC_TYPE_LINE_SUFFIX:
        return cb({
          ...doc3,
          contents: rec(doc3.contents)
        });
      case DOC_TYPE_STRING:
      case DOC_TYPE_CURSOR:
      case DOC_TYPE_TRIM:
      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
      case DOC_TYPE_LINE:
      case DOC_TYPE_BREAK_PARENT:
        return cb(doc3);
      default:
        throw new invalid_doc_error_default(doc3);
    }
  }
}
function breakParentGroup(groupStack) {
  if (groupStack.length > 0) {
    const parentGroup = at_default(
      /* isOptionalObject*/
      !1,
      groupStack,
      -1
    );
    !parentGroup.expandedStates && !parentGroup.break && (parentGroup.break = "propagated");
  }
  return null;
}
function propagateBreaks(doc2) {
  const alreadyVisitedSet = /* @__PURE__ */ new Set(), groupStack = [];
  function propagateBreaksOnEnterFn(doc3) {
    if (doc3.type === DOC_TYPE_BREAK_PARENT && breakParentGroup(groupStack), doc3.type === DOC_TYPE_GROUP) {
      if (groupStack.push(doc3), alreadyVisitedSet.has(doc3))
        return !1;
      alreadyVisitedSet.add(doc3);
    }
  }
  function propagateBreaksOnExitFn(doc3) {
    doc3.type === DOC_TYPE_GROUP && groupStack.pop().break && breakParentGroup(groupStack);
  }
  traverse_doc_default(
    doc2,
    propagateBreaksOnEnterFn,
    propagateBreaksOnExitFn,
    /* shouldTraverseConditionalGroups */
    !0
  );
}
function stripTrailingHardlineFromParts(parts) {
  for (parts = [...parts]; parts.length >= 2 && at_default(
    /* isOptionalObject*/
    !1,
    parts,
    -2
  ).type === DOC_TYPE_LINE && at_default(
    /* isOptionalObject*/
    !1,
    parts,
    -1
  ).type === DOC_TYPE_BREAK_PARENT; )
    parts.length -= 2;
  if (parts.length > 0) {
    const lastPart = stripTrailingHardlineFromDoc(at_default(
      /* isOptionalObject*/
      !1,
      parts,
      -1
    ));
    parts[parts.length - 1] = lastPart;
  }
  return parts;
}
function stripTrailingHardlineFromDoc(doc2) {
  switch (get_doc_type_default(doc2)) {
    case DOC_TYPE_ALIGN:
    case DOC_TYPE_INDENT:
    case DOC_TYPE_INDENT_IF_BREAK:
    case DOC_TYPE_GROUP:
    case DOC_TYPE_LINE_SUFFIX:
    case DOC_TYPE_LABEL: {
      const contents = stripTrailingHardlineFromDoc(doc2.contents);
      return {
        ...doc2,
        contents
      };
    }
    case DOC_TYPE_IF_BREAK:
      return {
        ...doc2,
        breakContents: stripTrailingHardlineFromDoc(doc2.breakContents),
        flatContents: stripTrailingHardlineFromDoc(doc2.flatContents)
      };
    case DOC_TYPE_FILL:
      return {
        ...doc2,
        parts: stripTrailingHardlineFromParts(doc2.parts)
      };
    case DOC_TYPE_ARRAY:
      return stripTrailingHardlineFromParts(doc2);
    case DOC_TYPE_STRING:
      return doc2.replace(/[\n\r]*$/, "");
    case DOC_TYPE_CURSOR:
    case DOC_TYPE_TRIM:
    case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
    case DOC_TYPE_LINE:
    case DOC_TYPE_BREAK_PARENT:
      break;
    default:
      throw new invalid_doc_error_default(doc2);
  }
  return doc2;
}
function stripTrailingHardline(doc2) {
  return stripTrailingHardlineFromDoc(cleanDoc(doc2));
}
function cleanDocFn(doc2) {
  switch (get_doc_type_default(doc2)) {
    case DOC_TYPE_FILL:
      if (doc2.parts.every((part) => part === ""))
        return "";
      break;
    case DOC_TYPE_GROUP:
      if (!doc2.contents && !doc2.id && !doc2.break && !doc2.expandedStates)
        return "";
      if (doc2.contents.type === DOC_TYPE_GROUP && doc2.contents.id === doc2.id && doc2.contents.break === doc2.break && doc2.contents.expandedStates === doc2.expandedStates)
        return doc2.contents;
      break;
    case DOC_TYPE_ALIGN:
    case DOC_TYPE_INDENT:
    case DOC_TYPE_INDENT_IF_BREAK:
    case DOC_TYPE_LINE_SUFFIX:
      if (!doc2.contents)
        return "";
      break;
    case DOC_TYPE_IF_BREAK:
      if (!doc2.flatContents && !doc2.breakContents)
        return "";
      break;
    case DOC_TYPE_ARRAY: {
      const parts = [];
      for (const part of doc2) {
        if (!part)
          continue;
        const [currentPart, ...restParts] = Array.isArray(part) ? part : [part];
        typeof currentPart == "string" && typeof at_default(
          /* isOptionalObject*/
          !1,
          parts,
          -1
        ) == "string" ? parts[parts.length - 1] += currentPart : parts.push(currentPart), parts.push(...restParts);
      }
      return parts.length === 0 ? "" : parts.length === 1 ? parts[0] : parts;
    }
    case DOC_TYPE_STRING:
    case DOC_TYPE_CURSOR:
    case DOC_TYPE_TRIM:
    case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
    case DOC_TYPE_LINE:
    case DOC_TYPE_LABEL:
    case DOC_TYPE_BREAK_PARENT:
      break;
    default:
      throw new invalid_doc_error_default(doc2);
  }
  return doc2;
}
function cleanDoc(doc2) {
  return mapDoc(doc2, (currentDoc) => cleanDocFn(currentDoc));
}
function inheritLabel(doc2, fn) {
  return doc2.type === DOC_TYPE_LABEL ? {
    ...doc2,
    contents: fn(doc2.contents)
  } : fn(doc2);
}
var MODE_BREAK = Symbol("MODE_BREAK"), MODE_FLAT = Symbol("MODE_FLAT"), CURSOR_PLACEHOLDER = Symbol("cursor");
function rootIndent() {
  return {
    value: "",
    length: 0,
    queue: []
  };
}
function makeIndent(ind, options8) {
  return generateInd(ind, {
    type: "indent"
  }, options8);
}
function makeAlign(indent2, widthOrDoc, options8) {
  return widthOrDoc === Number.NEGATIVE_INFINITY ? indent2.root || rootIndent() : widthOrDoc < 0 ? generateInd(indent2, {
    type: "dedent"
  }, options8) : widthOrDoc ? widthOrDoc.type === "root" ? {
    ...indent2,
    root: indent2
  } : generateInd(indent2, {
    type: typeof widthOrDoc == "string" ? "stringAlign" : "numberAlign",
    n: widthOrDoc
  }, options8) : indent2;
}
function generateInd(ind, newPart, options8) {
  const queue = newPart.type === "dedent" ? ind.queue.slice(0, -1) : [...ind.queue, newPart];
  let value = "", length = 0, lastTabs = 0, lastSpaces = 0;
  for (const part of queue)
    switch (part.type) {
      case "indent":
        flush(), options8.useTabs ? addTabs(1) : addSpaces(options8.tabWidth);
        break;
      case "stringAlign":
        flush(), value += part.n, length += part.n.length;
        break;
      case "numberAlign":
        lastTabs += 1, lastSpaces += part.n;
        break;
      default:
        throw new Error(`Unexpected type '${part.type}'`);
    }
  return flushSpaces(), {
    ...ind,
    value,
    length,
    queue
  };
  function addTabs(count) {
    value += "	".repeat(count), length += options8.tabWidth * count;
  }
  function addSpaces(count) {
    value += " ".repeat(count), length += count;
  }
  function flush() {
    options8.useTabs ? flushTabs() : flushSpaces();
  }
  function flushTabs() {
    lastTabs > 0 && addTabs(lastTabs), resetLast();
  }
  function flushSpaces() {
    lastSpaces > 0 && addSpaces(lastSpaces), resetLast();
  }
  function resetLast() {
    lastTabs = 0, lastSpaces = 0;
  }
}
function trim(out) {
  let trimCount = 0, cursorCount = 0, outIndex = out.length;
  outer:
    for (; outIndex--; ) {
      const last = out[outIndex];
      if (last === CURSOR_PLACEHOLDER) {
        cursorCount++;
        continue;
      }
      for (let charIndex = last.length - 1; charIndex >= 0; charIndex--) {
        const char = last[charIndex];
        if (char === " " || char === "	")
          trimCount++;
        else {
          out[outIndex] = last.slice(0, charIndex + 1);
          break outer;
        }
      }
    }
  if (trimCount > 0 || cursorCount > 0)
    for (out.length = outIndex + 1; cursorCount-- > 0; )
      out.push(CURSOR_PLACEHOLDER);
  return trimCount;
}
function fits(next, restCommands, width, hasLineSuffix, groupModeMap, mustBeFlat) {
  if (width === Number.POSITIVE_INFINITY)
    return !0;
  let restIdx = restCommands.length;
  const cmds = [next], out = [];
  for (; width >= 0; ) {
    if (cmds.length === 0) {
      if (restIdx === 0)
        return !0;
      cmds.push(restCommands[--restIdx]);
      continue;
    }
    const {
      mode,
      doc: doc2
    } = cmds.pop();
    switch (get_doc_type_default(doc2)) {
      case DOC_TYPE_STRING:
        out.push(doc2), width -= get_string_width_default(doc2);
        break;
      case DOC_TYPE_ARRAY:
      case DOC_TYPE_FILL: {
        const parts = getDocParts(doc2);
        for (let i2 = parts.length - 1; i2 >= 0; i2--)
          cmds.push({
            mode,
            doc: parts[i2]
          });
        break;
      }
      case DOC_TYPE_INDENT:
      case DOC_TYPE_ALIGN:
      case DOC_TYPE_INDENT_IF_BREAK:
      case DOC_TYPE_LABEL:
        cmds.push({
          mode,
          doc: doc2.contents
        });
        break;
      case DOC_TYPE_TRIM:
        width += trim(out);
        break;
      case DOC_TYPE_GROUP: {
        if (mustBeFlat && doc2.break)
          return !1;
        const groupMode = doc2.break ? MODE_BREAK : mode, contents = doc2.expandedStates && groupMode === MODE_BREAK ? at_default(
          /* isOptionalObject*/
          !1,
          doc2.expandedStates,
          -1
        ) : doc2.contents;
        cmds.push({
          mode: groupMode,
          doc: contents
        });
        break;
      }
      case DOC_TYPE_IF_BREAK: {
        const contents = (doc2.groupId ? groupModeMap[doc2.groupId] || MODE_FLAT : mode) === MODE_BREAK ? doc2.breakContents : doc2.flatContents;
        contents && cmds.push({
          mode,
          doc: contents
        });
        break;
      }
      case DOC_TYPE_LINE:
        if (mode === MODE_BREAK || doc2.hard)
          return !0;
        doc2.soft || (out.push(" "), width--);
        break;
      case DOC_TYPE_LINE_SUFFIX:
        hasLineSuffix = !0;
        break;
      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
        if (hasLineSuffix)
          return !1;
        break;
    }
  }
  return !1;
}
function printDocToString(doc2, options8) {
  const groupModeMap = {}, width = options8.printWidth, newLine = convertEndOfLineToChars(options8.endOfLine);
  let pos2 = 0;
  const cmds = [{
    ind: rootIndent(),
    mode: MODE_BREAK,
    doc: doc2
  }], out = [];
  let shouldRemeasure = !1;
  const lineSuffix2 = [];
  let printedCursorCount = 0;
  for (propagateBreaks(doc2); cmds.length > 0; ) {
    const {
      ind,
      mode,
      doc: doc3
    } = cmds.pop();
    switch (get_doc_type_default(doc3)) {
      case DOC_TYPE_STRING: {
        const formatted = newLine !== `
` ? string_replace_all_default(
          /* isOptionalObject*/
          !1,
          doc3,
          `
`,
          newLine
        ) : doc3;
        out.push(formatted), cmds.length > 0 && (pos2 += get_string_width_default(formatted));
        break;
      }
      case DOC_TYPE_ARRAY:
        for (let i2 = doc3.length - 1; i2 >= 0; i2--)
          cmds.push({
            ind,
            mode,
            doc: doc3[i2]
          });
        break;
      case DOC_TYPE_CURSOR:
        if (printedCursorCount >= 2)
          throw new Error("There are too many 'cursor' in doc.");
        out.push(CURSOR_PLACEHOLDER), printedCursorCount++;
        break;
      case DOC_TYPE_INDENT:
        cmds.push({
          ind: makeIndent(ind, options8),
          mode,
          doc: doc3.contents
        });
        break;
      case DOC_TYPE_ALIGN:
        cmds.push({
          ind: makeAlign(ind, doc3.n, options8),
          mode,
          doc: doc3.contents
        });
        break;
      case DOC_TYPE_TRIM:
        pos2 -= trim(out);
        break;
      case DOC_TYPE_GROUP:
        switch (mode) {
          case MODE_FLAT:
            if (!shouldRemeasure) {
              cmds.push({
                ind,
                mode: doc3.break ? MODE_BREAK : MODE_FLAT,
                doc: doc3.contents
              });
              break;
            }
          case MODE_BREAK: {
            shouldRemeasure = !1;
            const next = {
              ind,
              mode: MODE_FLAT,
              doc: doc3.contents
            }, rem = width - pos2, hasLineSuffix = lineSuffix2.length > 0;
            if (!doc3.break && fits(next, cmds, rem, hasLineSuffix, groupModeMap))
              cmds.push(next);
            else if (doc3.expandedStates) {
              const mostExpanded = at_default(
                /* isOptionalObject*/
                !1,
                doc3.expandedStates,
                -1
              );
              if (doc3.break) {
                cmds.push({
                  ind,
                  mode: MODE_BREAK,
                  doc: mostExpanded
                });
                break;
              } else
                for (let i2 = 1; i2 < doc3.expandedStates.length + 1; i2++)
                  if (i2 >= doc3.expandedStates.length) {
                    cmds.push({
                      ind,
                      mode: MODE_BREAK,
                      doc: mostExpanded
                    });
                    break;
                  } else {
                    const state = doc3.expandedStates[i2], cmd = {
                      ind,
                      mode: MODE_FLAT,
                      doc: state
                    };
                    if (fits(cmd, cmds, rem, hasLineSuffix, groupModeMap)) {
                      cmds.push(cmd);
                      break;
                    }
                  }
            } else
              cmds.push({
                ind,
                mode: MODE_BREAK,
                doc: doc3.contents
              });
            break;
          }
        }
        doc3.id && (groupModeMap[doc3.id] = at_default(
          /* isOptionalObject*/
          !1,
          cmds,
          -1
        ).mode);
        break;
      case DOC_TYPE_FILL: {
        const rem = width - pos2, {
          parts
        } = doc3;
        if (parts.length === 0)
          break;
        const [content, whitespace] = parts, contentFlatCmd = {
          ind,
          mode: MODE_FLAT,
          doc: content
        }, contentBreakCmd = {
          ind,
          mode: MODE_BREAK,
          doc: content
        }, contentFits = fits(contentFlatCmd, [], rem, lineSuffix2.length > 0, groupModeMap, !0);
        if (parts.length === 1) {
          contentFits ? cmds.push(contentFlatCmd) : cmds.push(contentBreakCmd);
          break;
        }
        const whitespaceFlatCmd = {
          ind,
          mode: MODE_FLAT,
          doc: whitespace
        }, whitespaceBreakCmd = {
          ind,
          mode: MODE_BREAK,
          doc: whitespace
        };
        if (parts.length === 2) {
          contentFits ? cmds.push(whitespaceFlatCmd, contentFlatCmd) : cmds.push(whitespaceBreakCmd, contentBreakCmd);
          break;
        }
        parts.splice(0, 2);
        const remainingCmd = {
          ind,
          mode,
          doc: fill(parts)
        }, secondContent = parts[0];
        fits({
          ind,
          mode: MODE_FLAT,
          doc: [content, whitespace, secondContent]
        }, [], rem, lineSuffix2.length > 0, groupModeMap, !0) ? cmds.push(remainingCmd, whitespaceFlatCmd, contentFlatCmd) : contentFits ? cmds.push(remainingCmd, whitespaceBreakCmd, contentFlatCmd) : cmds.push(remainingCmd, whitespaceBreakCmd, contentBreakCmd);
        break;
      }
      case DOC_TYPE_IF_BREAK:
      case DOC_TYPE_INDENT_IF_BREAK: {
        const groupMode = doc3.groupId ? groupModeMap[doc3.groupId] : mode;
        if (groupMode === MODE_BREAK) {
          const breakContents = doc3.type === DOC_TYPE_IF_BREAK ? doc3.breakContents : doc3.negate ? doc3.contents : indent(doc3.contents);
          breakContents && cmds.push({
            ind,
            mode,
            doc: breakContents
          });
        }
        if (groupMode === MODE_FLAT) {
          const flatContents = doc3.type === DOC_TYPE_IF_BREAK ? doc3.flatContents : doc3.negate ? indent(doc3.contents) : doc3.contents;
          flatContents && cmds.push({
            ind,
            mode,
            doc: flatContents
          });
        }
        break;
      }
      case DOC_TYPE_LINE_SUFFIX:
        lineSuffix2.push({
          ind,
          mode,
          doc: doc3.contents
        });
        break;
      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:
        lineSuffix2.length > 0 && cmds.push({
          ind,
          mode,
          doc: hardlineWithoutBreakParent
        });
        break;
      case DOC_TYPE_LINE:
        switch (mode) {
          case MODE_FLAT:
            if (doc3.hard)
              shouldRemeasure = !0;
            else {
              doc3.soft || (out.push(" "), pos2 += 1);
              break;
            }
          case MODE_BREAK:
            if (lineSuffix2.length > 0) {
              cmds.push({
                ind,
                mode,
                doc: doc3
              }, ...lineSuffix2.reverse()), lineSuffix2.length = 0;
              break;
            }
            doc3.literal ? ind.root ? (out.push(newLine, ind.root.value), pos2 = ind.root.length) : (out.push(newLine), pos2 = 0) : (pos2 -= trim(out), out.push(newLine + ind.value), pos2 = ind.length);
            break;
        }
        break;
      case DOC_TYPE_LABEL:
        cmds.push({
          ind,
          mode,
          doc: doc3.contents
        });
        break;
      case DOC_TYPE_BREAK_PARENT:
        break;
      default:
        throw new invalid_doc_error_default(doc3);
    }
    cmds.length === 0 && lineSuffix2.length > 0 && (cmds.push(...lineSuffix2.reverse()), lineSuffix2.length = 0);
  }
  const cursorPlaceholderIndex = out.indexOf(CURSOR_PLACEHOLDER);
  if (cursorPlaceholderIndex !== -1) {
    const otherCursorPlaceholderIndex = out.indexOf(CURSOR_PLACEHOLDER, cursorPlaceholderIndex + 1), beforeCursor = out.slice(0, cursorPlaceholderIndex).join(""), aroundCursor = out.slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex).join(""), afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join("");
    return {
      formatted: beforeCursor + aroundCursor + afterCursor,
      cursorNodeStart: beforeCursor.length,
      cursorNodeText: aroundCursor
    };
  }
  return {
    formatted: out.join("")
  };
}
function getAlignmentSize(text, tabWidth, startIndex = 0) {
  let size = 0;
  for (let i2 = startIndex; i2 < text.length; ++i2)
    text[i2] === "	" ? size = size + tabWidth - size % tabWidth : size++;
  return size;
}
var get_alignment_size_default = getAlignmentSize, _getNodeStackIndex, getNodeStackIndex_fn, _getAncestors, getAncestors_fn, AstPath = class {
  constructor(value) {
    __privateAdd(this, _getNodeStackIndex), __privateAdd(this, _getAncestors), this.stack = [value];
  }
  /** @type {string | null} */
  get key() {
    const {
      stack: stack2,
      siblings
    } = this;
    return at_default(
      /* isOptionalObject*/
      !1,
      stack2,
      siblings === null ? -2 : -4
    ) ?? null;
  }
  /** @type {number | null} */
  get index() {
    return this.siblings === null ? null : at_default(
      /* isOptionalObject*/
      !1,
      this.stack,
      -2
    );
  }
  /** @type {object} */
  get node() {
    return at_default(
      /* isOptionalObject*/
      !1,
      this.stack,
      -1
    );
  }
  /** @type {object | null} */
  get parent() {
    return this.getNode(1);
  }
  /** @type {object | null} */
  get grandparent() {
    return this.getNode(2);
  }
  /** @type {boolean} */
  get isInArray() {
    return this.siblings !== null;
  }
  /** @type {object[] | null} */
  get siblings() {
    const {
      stack: stack2
    } = this, maybeArray = at_default(
      /* isOptionalObject*/
      !1,
      stack2,
      -3
    );
    return Array.isArray(maybeArray) ? maybeArray : null;
  }
  /** @type {object | null} */
  get next() {
    const {
      siblings
    } = this;
    return siblings === null ? null : siblings[this.index + 1];
  }
  /** @type {object | null} */
  get previous() {
    const {
      siblings
    } = this;
    return siblings === null ? null : siblings[this.index - 1];
  }
  /** @type {boolean} */
  get isFirst() {
    return this.index === 0;
  }
  /** @type {boolean} */
  get isLast() {
    const {
      siblings,
      index
    } = this;
    return siblings !== null && index === siblings.length - 1;
  }
  /** @type {boolean} */
  get isRoot() {
    return this.stack.length === 1;
  }
  /** @type {object} */
  get root() {
    return this.stack[0];
  }
  /** @type {object[]} */
  get ancestors() {
    return [...__privateMethod(this, _getAncestors, getAncestors_fn).call(this)];
  }
  // The name of the current property is always the penultimate element of
  // this.stack, and always a string/number/symbol.
  getName() {
    const {
      stack: stack2
    } = this, {
      length
    } = stack2;
    return length > 1 ? at_default(
      /* isOptionalObject*/
      !1,
      stack2,
      -2
    ) : null;
  }
  // The value of the current property is always the final element of
  // this.stack.
  getValue() {
    return at_default(
      /* isOptionalObject*/
      !1,
      this.stack,
      -1
    );
  }
  getNode(count = 0) {
    const stackIndex = __privateMethod(this, _getNodeStackIndex, getNodeStackIndex_fn).call(this, count);
    return stackIndex === -1 ? null : this.stack[stackIndex];
  }
  getParentNode(count = 0) {
    return this.getNode(count + 1);
  }
  // Temporarily push properties named by string arguments given after the
  // callback function onto this.stack, then call the callback with a
  // reference to this (modified) AstPath object. Note that the stack will
  // be restored to its original state after the callback is finished, so it
  // is probably a mistake to retain a reference to the path.
  call(callback, ...names) {
    const {
      stack: stack2
    } = this, {
      length
    } = stack2;
    let value = at_default(
      /* isOptionalObject*/
      !1,
      stack2,
      -1
    );
    for (const name of names)
      value = value[name], stack2.push(name, value);
    try {
      return callback(this);
    } finally {
      stack2.length = length;
    }
  }
  callParent(callback, count = 0) {
    const stackIndex = __privateMethod(this, _getNodeStackIndex, getNodeStackIndex_fn).call(this, count + 1), parentValues = this.stack.splice(stackIndex + 1);
    try {
      return callback(this);
    } finally {
      this.stack.push(...parentValues);
    }
  }
  // Similar to AstPath.prototype.call, except that the value obtained by
  // accessing this.getValue()[name1][name2]... should be array. The
  // callback will be called with a reference to this path object for each
  // element of the array.
  each(callback, ...names) {
    const {
      stack: stack2
    } = this, {
      length
    } = stack2;
    let value = at_default(
      /* isOptionalObject*/
      !1,
      stack2,
      -1
    );
    for (const name of names)
      value = value[name], stack2.push(name, value);
    try {
      for (let i2 = 0; i2 < value.length; ++i2)
        stack2.push(i2, value[i2]), callback(this, i2, value), stack2.length -= 2;
    } finally {
      stack2.length = length;
    }
  }
  // Similar to AstPath.prototype.each, except that the results of the
  // callback function invocations are stored in an array and returned at
  // the end of the iteration.
  map(callback, ...names) {
    const result = [];
    return this.each((path13, index, value) => {
      result[index] = callback(path13, index, value);
    }, ...names), result;
  }
  /**
   * @param {...(
   *   | ((node: any, name: string | null, number: number | null) => boolean)
   *   | undefined
   * )} predicates
   */
  match(...predicates) {
    let stackPointer = this.stack.length - 1, name = null, node = this.stack[stackPointer--];
    for (const predicate of predicates) {
      if (node === void 0)
        return !1;
      let number = null;
      if (typeof name == "number" && (number = name, name = this.stack[stackPointer--], node = this.stack[stackPointer--]), predicate && !predicate(node, name, number))
        return !1;
      name = this.stack[stackPointer--], node = this.stack[stackPointer--];
    }
    return !0;
  }
  /**
   * Traverses the ancestors of the current node heading toward the tree root
   * until it finds a node that matches the provided predicate function. Will
   * return the first matching ancestor. If no such node exists, returns undefined.
   * @param {(node: any) => boolean} predicate
   * @internal Unstable API. Don't use in plugins for now.
   */
  findAncestor(predicate) {
    for (const node of __privateMethod(this, _getAncestors, getAncestors_fn).call(this))
      if (predicate(node))
        return node;
  }
  /**
   * Traverses the ancestors of the current node heading toward the tree root
   * until it finds a node that matches the provided predicate function.
   * returns true if matched node found.
   * @param {(node: any) => boolean} predicate
   * @returns {boolean}
   * @internal Unstable API. Don't use in plugins for now.
   */
  hasAncestor(predicate) {
    for (const node of __privateMethod(this, _getAncestors, getAncestors_fn).call(this))
      if (predicate(node))
        return !0;
    return !1;
  }
};
_getNodeStackIndex = /* @__PURE__ */ new WeakSet();
getNodeStackIndex_fn = function(count) {
  const {
    stack: stack2
  } = this;
  for (let i2 = stack2.length - 1; i2 >= 0; i2 -= 2)
    if (!Array.isArray(stack2[i2]) && --count < 0)
      return i2;
  return -1;
};
_getAncestors = /* @__PURE__ */ new WeakSet();
getAncestors_fn = function* () {
  const {
    stack: stack2
  } = this;
  for (let index = stack2.length - 3; index >= 0; index -= 2) {
    const value = stack2[index];
    Array.isArray(value) || (yield value);
  }
};
var ast_path_default = AstPath;
function isObject2(object) {
  return object !== null && typeof object == "object";
}
var is_object_default = isObject2;
function* getChildren(node, options8) {
  const { getVisitorKeys, filter: filter2 = () => !0 } = options8, isMatchedNode = (node2) => is_object_default(node2) && filter2(node2);
  for (const key2 of getVisitorKeys(node)) {
    const value = node[key2];
    if (Array.isArray(value))
      for (const child of value)
        isMatchedNode(child) && (yield child);
    else
      isMatchedNode(value) && (yield value);
  }
}
function* getDescendants(node, options8) {
  const queue = [node];
  for (let index = 0; index < queue.length; index++) {
    const node2 = queue[index];
    for (const child of getChildren(node2, options8))
      yield child, queue.push(child);
  }
}
function skip(characters) {
  return (text, startIndex, options8) => {
    const backwards = !!options8?.backwards;
    if (startIndex === !1)
      return !1;
    const { length } = text;
    let cursor2 = startIndex;
    for (; cursor2 >= 0 && cursor2 < length; ) {
      const character = text.charAt(cursor2);
      if (characters instanceof RegExp) {
        if (!characters.test(character))
          return cursor2;
      } else if (!characters.includes(character))
        return cursor2;
      backwards ? cursor2-- : cursor2++;
    }
    return cursor2 === -1 || cursor2 === length ? cursor2 : !1;
  };
}
var skipWhitespace = skip(/\s/), skipSpaces = skip(" 	"), skipToLineEnd = skip(",; 	"), skipEverythingButNewLine = skip(/[^\n\r]/);
function skipNewline(text, startIndex, options8) {
  const backwards = !!options8?.backwards;
  if (startIndex === !1)
    return !1;
  const character = text.charAt(startIndex);
  if (backwards) {
    if (text.charAt(startIndex - 1) === "\r" && character === `
`)
      return startIndex - 2;
    if (character === `
` || character === "\r" || character === "\u2028" || character === "\u2029")
      return startIndex - 1;
  } else {
    if (character === "\r" && text.charAt(startIndex + 1) === `
`)
      return startIndex + 2;
    if (character === `
` || character === "\r" || character === "\u2028" || character === "\u2029")
      return startIndex + 1;
  }
  return startIndex;
}
var skip_newline_default = skipNewline;
function hasNewline(text, startIndex, options8 = {}) {
  const idx = skipSpaces(
    text,
    options8.backwards ? startIndex - 1 : startIndex,
    options8
  ), idx2 = skip_newline_default(text, idx, options8);
  return idx !== idx2;
}
var has_newline_default = hasNewline;
function isNonEmptyArray(object) {
  return Array.isArray(object) && object.length > 0;
}
var is_non_empty_array_default = isNonEmptyArray, nonTraversableKeys = /* @__PURE__ */ new Set([
  "tokens",
  "comments",
  "parent",
  "enclosingNode",
  "precedingNode",
  "followingNode"
]), defaultGetVisitorKeys = (node) => Object.keys(node).filter((key2) => !nonTraversableKeys.has(key2));
function createGetVisitorKeysFunction(printerGetVisitorKeys) {
  return printerGetVisitorKeys ? (node) => printerGetVisitorKeys(node, nonTraversableKeys) : defaultGetVisitorKeys;
}
var create_get_visitor_keys_function_default = createGetVisitorKeysFunction;
function describeNodeForDebugging(node) {
  const nodeType = node.type || node.kind || "(unknown type)";
  let nodeName = String(
    node.name || node.id && (typeof node.id == "object" ? node.id.name : node.id) || node.key && (typeof node.key == "object" ? node.key.name : node.key) || node.value && (typeof node.value == "object" ? "" : String(node.value)) || node.operator || ""
  );
  return nodeName.length > 20 && (nodeName = nodeName.slice(0, 19) + "\u2026"), nodeType + (nodeName ? " " + nodeName : "");
}
function addCommentHelper(node, comment) {
  (node.comments ?? (node.comments = [])).push(comment), comment.printed = !1, comment.nodeDescription = describeNodeForDebugging(node);
}
function addLeadingComment(node, comment) {
  comment.leading = !0, comment.trailing = !1, addCommentHelper(node, comment);
}
function addDanglingComment(node, comment, marker) {
  comment.leading = !1, comment.trailing = !1, marker && (comment.marker = marker), addCommentHelper(node, comment);
}
function addTrailingComment(node, comment) {
  comment.leading = !1, comment.trailing = !0, addCommentHelper(node, comment);
}
var childNodesCache = /* @__PURE__ */ new WeakMap();
function getSortedChildNodes(node, options8) {
  if (childNodesCache.has(node))
    return childNodesCache.get(node);
  const {
    printer: {
      getCommentChildNodes,
      canAttachComment,
      getVisitorKeys: printerGetVisitorKeys
    },
    locStart,
    locEnd
  } = options8;
  if (!canAttachComment)
    return [];
  const childNodes = (getCommentChildNodes?.(node, options8) ?? [
    ...getChildren(node, {
      getVisitorKeys: create_get_visitor_keys_function_default(printerGetVisitorKeys)
    })
  ]).flatMap(
    (node2) => canAttachComment(node2) ? [node2] : getSortedChildNodes(node2, options8)
  );
  return childNodes.sort(
    (nodeA, nodeB) => locStart(nodeA) - locStart(nodeB) || locEnd(nodeA) - locEnd(nodeB)
  ), childNodesCache.set(node, childNodes), childNodes;
}
function decorateComment(node, comment, options8, enclosingNode) {
  const { locStart, locEnd } = options8, commentStart = locStart(comment), commentEnd = locEnd(comment), childNodes = getSortedChildNodes(node, options8);
  let precedingNode, followingNode, left = 0, right = childNodes.length;
  for (; left < right; ) {
    const middle = left + right >> 1, child = childNodes[middle], start = locStart(child), end = locEnd(child);
    if (start <= commentStart && commentEnd <= end)
      return decorateComment(child, comment, options8, child);
    if (end <= commentStart) {
      precedingNode = child, left = middle + 1;
      continue;
    }
    if (commentEnd <= start) {
      followingNode = child, right = middle;
      continue;
    }
    throw new Error("Comment location overlaps with node location");
  }
  if (enclosingNode?.type === "TemplateLiteral") {
    const { quasis } = enclosingNode, commentIndex = findExpressionIndexForComment(
      quasis,
      comment,
      options8
    );
    precedingNode && findExpressionIndexForComment(quasis, precedingNode, options8) !== commentIndex && (precedingNode = null), followingNode && findExpressionIndexForComment(quasis, followingNode, options8) !== commentIndex && (followingNode = null);
  }
  return { enclosingNode, precedingNode, followingNode };
}
var returnFalse = () => !1;
function attachComments(ast, options8) {
  const { comments } = ast;
  if (delete ast.comments, !is_non_empty_array_default(comments) || !options8.printer.canAttachComment)
    return;
  const tiesToBreak = [], {
    locStart,
    locEnd,
    printer: {
      experimentalFeatures: {
        // TODO: Make this as default behavior
        avoidAstMutation = !1
      } = {},
      handleComments = {}
    },
    originalText: text
  } = options8, {
    ownLine: handleOwnLineComment = returnFalse,
    endOfLine: handleEndOfLineComment = returnFalse,
    remaining: handleRemainingComment = returnFalse
  } = handleComments, decoratedComments = comments.map((comment, index) => ({
    ...decorateComment(ast, comment, options8),
    comment,
    text,
    options: options8,
    ast,
    isLastComment: comments.length - 1 === index
  }));
  for (const [index, context] of decoratedComments.entries()) {
    const {
      comment,
      precedingNode,
      enclosingNode,
      followingNode,
      text: text2,
      options: options9,
      ast: ast2,
      isLastComment
    } = context;
    if (options9.parser === "json" || options9.parser === "json5" || options9.parser === "jsonc" || options9.parser === "__js_expression" || options9.parser === "__ts_expression" || options9.parser === "__vue_expression" || options9.parser === "__vue_ts_expression") {
      if (locStart(comment) - locStart(ast2) <= 0) {
        addLeadingComment(ast2, comment);
        continue;
      }
      if (locEnd(comment) - locEnd(ast2) >= 0) {
        addTrailingComment(ast2, comment);
        continue;
      }
    }
    let args;
    if (avoidAstMutation ? args = [context] : (comment.enclosingNode = enclosingNode, comment.precedingNode = precedingNode, comment.followingNode = followingNode, args = [comment, text2, options9, ast2, isLastComment]), isOwnLineComment(text2, options9, decoratedComments, index))
      comment.placement = "ownLine", handleOwnLineComment(...args) || (followingNode ? addLeadingComment(followingNode, comment) : precedingNode ? addTrailingComment(precedingNode, comment) : addDanglingComment(enclosingNode || ast2, comment));
    else if (isEndOfLineComment(text2, options9, decoratedComments, index))
      comment.placement = "endOfLine", handleEndOfLineComment(...args) || (precedingNode ? addTrailingComment(precedingNode, comment) : followingNode ? addLeadingComment(followingNode, comment) : addDanglingComment(enclosingNode || ast2, comment));
    else if (comment.placement = "remaining", !handleRemainingComment(...args))
      if (precedingNode && followingNode) {
        const tieCount = tiesToBreak.length;
        tieCount > 0 && tiesToBreak[tieCount - 1].followingNode !== followingNode && breakTies(tiesToBreak, options9), tiesToBreak.push(context);
      } else
        precedingNode ? addTrailingComment(precedingNode, comment) : followingNode ? addLeadingComment(followingNode, comment) : addDanglingComment(enclosingNode || ast2, comment);
  }
  if (breakTies(tiesToBreak, options8), !avoidAstMutation)
    for (const comment of comments)
      delete comment.precedingNode, delete comment.enclosingNode, delete comment.followingNode;
}
var isAllEmptyAndNoLineBreak = (text) => !/[\S\n\u2028\u2029]/.test(text);
function isOwnLineComment(text, options8, decoratedComments, commentIndex) {
  const { comment, precedingNode } = decoratedComments[commentIndex], { locStart, locEnd } = options8;
  let start = locStart(comment);
  if (precedingNode)
    for (let index = commentIndex - 1; index >= 0; index--) {
      const { comment: comment2, precedingNode: currentCommentPrecedingNode } = decoratedComments[index];
      if (currentCommentPrecedingNode !== precedingNode || !isAllEmptyAndNoLineBreak(text.slice(locEnd(comment2), start)))
        break;
      start = locStart(comment2);
    }
  return has_newline_default(text, start, { backwards: !0 });
}
function isEndOfLineComment(text, options8, decoratedComments, commentIndex) {
  const { comment, followingNode } = decoratedComments[commentIndex], { locStart, locEnd } = options8;
  let end = locEnd(comment);
  if (followingNode)
    for (let index = commentIndex + 1; index < decoratedComments.length; index++) {
      const { comment: comment2, followingNode: currentCommentFollowingNode } = decoratedComments[index];
      if (currentCommentFollowingNode !== followingNode || !isAllEmptyAndNoLineBreak(text.slice(end, locStart(comment2))))
        break;
      end = locEnd(comment2);
    }
  return has_newline_default(text, end);
}
function breakTies(tiesToBreak, options8) {
  var _a, _b;
  const tieCount = tiesToBreak.length;
  if (tieCount === 0)
    return;
  const { precedingNode, followingNode } = tiesToBreak[0];
  let gapEndPos = options8.locStart(followingNode), indexOfFirstLeadingComment;
  for (indexOfFirstLeadingComment = tieCount; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {
    const {
      comment,
      precedingNode: currentCommentPrecedingNode,
      followingNode: currentCommentFollowingNode
    } = tiesToBreak[indexOfFirstLeadingComment - 1];
    require$$1__default.default.strictEqual(currentCommentPrecedingNode, precedingNode), require$$1__default.default.strictEqual(currentCommentFollowingNode, followingNode);
    const gap = options8.originalText.slice(options8.locEnd(comment), gapEndPos);
    if (((_b = (_a = options8.printer).isGap) == null ? void 0 : _b.call(_a, gap, options8)) ?? /^[\s(]*$/.test(gap))
      gapEndPos = options8.locStart(comment);
    else
      break;
  }
  for (const [i2, { comment }] of tiesToBreak.entries())
    i2 < indexOfFirstLeadingComment ? addTrailingComment(precedingNode, comment) : addLeadingComment(followingNode, comment);
  for (const node of [precedingNode, followingNode])
    node.comments && node.comments.length > 1 && node.comments.sort((a, b) => options8.locStart(a) - options8.locStart(b));
  tiesToBreak.length = 0;
}
function findExpressionIndexForComment(quasis, comment, options8) {
  const startPos = options8.locStart(comment) - 1;
  for (let i2 = 1; i2 < quasis.length; ++i2)
    if (startPos < options8.locStart(quasis[i2]))
      return i2 - 1;
  return 0;
}
function isPreviousLineEmpty(text, startIndex) {
  let idx = startIndex - 1;
  idx = skipSpaces(text, idx, { backwards: !0 }), idx = skip_newline_default(text, idx, { backwards: !0 }), idx = skipSpaces(text, idx, { backwards: !0 });
  const idx2 = skip_newline_default(text, idx, { backwards: !0 });
  return idx !== idx2;
}
var is_previous_line_empty_default = isPreviousLineEmpty;
function printComment(path13, options8) {
  const comment = path13.node;
  return comment.printed = !0, options8.printer.printComment(path13, options8);
}
function printLeadingComment(path13, options8) {
  var _a;
  const comment = path13.node, parts = [printComment(path13, options8)], { printer: printer2, originalText, locStart, locEnd } = options8;
  if ((_a = printer2.isBlockComment) == null ? void 0 : _a.call(printer2, comment)) {
    const lineBreak = has_newline_default(originalText, locEnd(comment)) ? has_newline_default(originalText, locStart(comment), {
      backwards: !0
    }) ? hardline : line2 : " ";
    parts.push(lineBreak);
  } else
    parts.push(hardline);
  const index = skip_newline_default(
    originalText,
    skipSpaces(originalText, locEnd(comment))
  );
  return index !== !1 && has_newline_default(originalText, index) && parts.push(hardline), parts;
}
function printTrailingComment(path13, options8, previousComment) {
  var _a;
  const comment = path13.node, printed = printComment(path13, options8), { printer: printer2, originalText, locStart } = options8, isBlock = (_a = printer2.isBlockComment) == null ? void 0 : _a.call(printer2, comment);
  if (previousComment?.hasLineSuffix && !previousComment?.isBlock || has_newline_default(originalText, locStart(comment), { backwards: !0 })) {
    const isLineBeforeEmpty = is_previous_line_empty_default(
      originalText,
      locStart(comment)
    );
    return {
      doc: lineSuffix([hardline, isLineBeforeEmpty ? hardline : "", printed]),
      isBlock,
      hasLineSuffix: !0
    };
  }
  return !isBlock || previousComment?.hasLineSuffix ? {
    doc: [lineSuffix([" ", printed]), breakParent],
    isBlock,
    hasLineSuffix: !0
  } : { doc: [" ", printed], isBlock, hasLineSuffix: !1 };
}
function printCommentsSeparately(path13, options8) {
  const value = path13.node;
  if (!value)
    return {};
  const ignored = options8[Symbol.for("printedComments")];
  if ((value.comments || []).filter(
    (comment) => !ignored.has(comment)
  ).length === 0)
    return { leading: "", trailing: "" };
  const leadingParts = [], trailingParts = [];
  let printedTrailingComment;
  return path13.each(() => {
    const comment = path13.node;
    if (ignored?.has(comment))
      return;
    const { leading, trailing } = comment;
    leading ? leadingParts.push(printLeadingComment(path13, options8)) : trailing && (printedTrailingComment = printTrailingComment(
      path13,
      options8,
      printedTrailingComment
    ), trailingParts.push(printedTrailingComment.doc));
  }, "comments"), { leading: leadingParts, trailing: trailingParts };
}
function printComments(path13, doc2, options8) {
  const { leading, trailing } = printCommentsSeparately(path13, options8);
  return !leading && !trailing ? doc2 : inheritLabel(doc2, (doc3) => [leading, doc3, trailing]);
}
function ensureAllCommentsPrinted(options8) {
  const {
    [Symbol.for("comments")]: comments,
    [Symbol.for("printedComments")]: printedComments
  } = options8;
  for (const comment of comments) {
    if (!comment.printed && !printedComments.has(comment))
      throw new Error(
        'Comment "' + comment.value.trim() + '" was not printed. Please report this error!'
      );
    delete comment.printed;
  }
}
function createPrintPreCheckFunction(options8) {
  return () => {
  };
}
var create_print_pre_check_function_default = createPrintPreCheckFunction, core_options_evaluate_default = {
  cursorOffset: {
    category: "Special",
    type: "int",
    default: -1,
    range: {
      start: -1,
      end: 1 / 0,
      step: 1
    },
    description: "Print (to stderr) where a cursor at the given position would move to after formatting.",
    cliCategory: "Editor"
  },
  endOfLine: {
    category: "Global",
    type: "choice",
    default: "lf",
    description: "Which end of line characters to apply.",
    choices: [
      {
        value: "lf",
        description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"
      },
      {
        value: "crlf",
        description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"
      },
      {
        value: "cr",
        description: "Carriage Return character only (\\r), used very rarely"
      },
      {
        value: "auto",
        description: `Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)`
      }
    ]
  },
  filepath: {
    category: "Special",
    type: "path",
    description: "Specify the input filepath. This will be used to do parser inference.",
    cliName: "stdin-filepath",
    cliCategory: "Other",
    cliDescription: "Path to the file to pretend that stdin comes from."
  },
  insertPragma: {
    category: "Special",
    type: "boolean",
    default: !1,
    description: "Insert @format pragma into file's first docblock comment.",
    cliCategory: "Other"
  },
  parser: {
    category: "Global",
    type: "choice",
    default: void 0,
    description: "Which parser to use.",
    exception: (value) => typeof value == "string" || typeof value == "function",
    choices: [
      {
        value: "flow",
        description: "Flow"
      },
      {
        value: "babel",
        description: "JavaScript"
      },
      {
        value: "babel-flow",
        description: "Flow"
      },
      {
        value: "babel-ts",
        description: "TypeScript"
      },
      {
        value: "typescript",
        description: "TypeScript"
      },
      {
        value: "acorn",
        description: "JavaScript"
      },
      {
        value: "espree",
        description: "JavaScript"
      },
      {
        value: "meriyah",
        description: "JavaScript"
      },
      {
        value: "css",
        description: "CSS"
      },
      {
        value: "less",
        description: "Less"
      },
      {
        value: "scss",
        description: "SCSS"
      },
      {
        value: "json",
        description: "JSON"
      },
      {
        value: "json5",
        description: "JSON5"
      },
      {
        value: "jsonc",
        description: "JSON with Comments"
      },
      {
        value: "json-stringify",
        description: "JSON.stringify"
      },
      {
        value: "graphql",
        description: "GraphQL"
      },
      {
        value: "markdown",
        description: "Markdown"
      },
      {
        value: "mdx",
        description: "MDX"
      },
      {
        value: "vue",
        description: "Vue"
      },
      {
        value: "yaml",
        description: "YAML"
      },
      {
        value: "glimmer",
        description: "Ember / Handlebars"
      },
      {
        value: "html",
        description: "HTML"
      },
      {
        value: "angular",
        description: "Angular"
      },
      {
        value: "lwc",
        description: "Lightning Web Components"
      }
    ]
  },
  plugins: {
    type: "path",
    array: !0,
    default: [
      {
        value: []
      }
    ],
    category: "Global",
    description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",
    exception: (value) => typeof value == "string" || typeof value == "object",
    cliName: "plugin",
    cliCategory: "Config"
  },
  printWidth: {
    category: "Global",
    type: "int",
    default: 80,
    description: "The line length where Prettier will try wrap.",
    range: {
      start: 0,
      end: 1 / 0,
      step: 1
    }
  },
  rangeEnd: {
    category: "Special",
    type: "int",
    default: 1 / 0,
    range: {
      start: 0,
      end: 1 / 0,
      step: 1
    },
    description: `Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.`,
    cliCategory: "Editor"
  },
  rangeStart: {
    category: "Special",
    type: "int",
    default: 0,
    range: {
      start: 0,
      end: 1 / 0,
      step: 1
    },
    description: `Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.`,
    cliCategory: "Editor"
  },
  requirePragma: {
    category: "Special",
    type: "boolean",
    default: !1,
    description: `Require either '@prettier' or '@format' to be present in the file's first docblock comment
in order for it to be formatted.`,
    cliCategory: "Other"
  },
  tabWidth: {
    type: "int",
    category: "Global",
    default: 2,
    description: "Number of spaces per indentation level.",
    range: {
      start: 0,
      end: 1 / 0,
      step: 1
    }
  },
  useTabs: {
    category: "Global",
    type: "boolean",
    default: !1,
    description: "Indent with tabs instead of spaces."
  },
  embeddedLanguageFormatting: {
    category: "Global",
    type: "choice",
    default: "auto",
    description: "Control how Prettier formats quoted code embedded in the file.",
    choices: [
      {
        value: "auto",
        description: "Format embedded code if Prettier can automatically identify it."
      },
      {
        value: "off",
        description: "Never automatically format embedded code."
      }
    ]
  }
};
function getSupportInfo({
  plugins = [],
  showDeprecated = !1
} = {}) {
  const languages2 = plugins.flatMap((plugin) => plugin.languages ?? []), options8 = [];
  for (const option of normalizeOptionSettings(Object.assign({}, ...plugins.map(({
    options: options9
  }) => options9), core_options_evaluate_default)))
    !showDeprecated && option.deprecated || (Array.isArray(option.choices) && (showDeprecated || (option.choices = option.choices.filter((choice) => !choice.deprecated)), option.name === "parser" && (option.choices = [...option.choices, ...collectParsersFromLanguages(option.choices, languages2, plugins)])), option.pluginDefaults = Object.fromEntries(plugins.filter((plugin) => {
      var _a;
      return ((_a = plugin.defaultOptions) == null ? void 0 : _a[option.name]) !== void 0;
    }).map((plugin) => [plugin.name, plugin.defaultOptions[option.name]])), options8.push(option));
  return {
    languages: languages2,
    options: options8
  };
}
function* collectParsersFromLanguages(parserChoices, languages2, plugins) {
  const existingParsers = new Set(parserChoices.map((choice) => choice.value));
  for (const language of languages2)
    if (language.parsers) {
      for (const parserName of language.parsers)
        if (!existingParsers.has(parserName)) {
          existingParsers.add(parserName);
          const plugin = plugins.find((plugin2) => plugin2.parsers && Object.prototype.hasOwnProperty.call(plugin2.parsers, parserName));
          let description = language.name;
          plugin?.name && (description += ` (plugin: ${plugin.name})`), yield {
            value: parserName,
            description
          };
        }
    }
}
function normalizeOptionSettings(settings) {
  const options8 = [];
  for (const [name, originalOption] of Object.entries(settings)) {
    const option = {
      name,
      ...originalOption
    };
    Array.isArray(option.default) && (option.default = at_default(
      /* isOptionalObject*/
      !1,
      option.default,
      -1
    ).value), options8.push(option);
  }
  return options8;
}
var hasDeprecationWarned;
function normalizeOptions(options8, optionInfos, {
  logger = !1,
  isCLI = !1,
  passThrough = !1,
  FlagSchema,
  descriptor
} = {}) {
  if (isCLI) {
    if (!FlagSchema)
      throw new Error("'FlagSchema' option is required.");
    if (!descriptor)
      throw new Error("'descriptor' option is required.");
  } else
    descriptor = apiDescriptor;
  const unknown = passThrough ? Array.isArray(passThrough) ? (key2, value) => passThrough.includes(key2) ? {
    [key2]: value
  } : void 0 : (key2, value) => ({
    [key2]: value
  }) : (key2, value, options9) => {
    const {
      _,
      ...schemas2
    } = options9.schemas;
    return levenUnknownHandler(key2, value, {
      ...options9,
      schemas: schemas2
    });
  }, schemas = optionInfosToSchemas(optionInfos, {
    isCLI,
    FlagSchema
  }), normalizer = new Normalizer(schemas, {
    logger,
    unknown,
    descriptor
  }), shouldSuppressDuplicateDeprecationWarnings = logger !== !1;
  shouldSuppressDuplicateDeprecationWarnings && hasDeprecationWarned && (normalizer._hasDeprecationWarned = hasDeprecationWarned);
  const normalized = normalizer.normalize(options8);
  return shouldSuppressDuplicateDeprecationWarnings && (hasDeprecationWarned = normalizer._hasDeprecationWarned), normalized;
}
function optionInfosToSchemas(optionInfos, {
  isCLI,
  FlagSchema
}) {
  const schemas = [];
  isCLI && schemas.push(AnySchema.create({
    name: "_"
  }));
  for (const optionInfo of optionInfos)
    schemas.push(optionInfoToSchema(optionInfo, {
      isCLI,
      optionInfos,
      FlagSchema
    })), optionInfo.alias && isCLI && schemas.push(AliasSchema.create({
      // @ts-expect-error
      name: optionInfo.alias,
      sourceName: optionInfo.name
    }));
  return schemas;
}
function optionInfoToSchema(optionInfo, {
  isCLI,
  optionInfos,
  FlagSchema
}) {
  const {
    name
  } = optionInfo, parameters = {
    name
  };
  let SchemaConstructor;
  const handlers = {};
  switch (optionInfo.type) {
    case "int":
      SchemaConstructor = IntegerSchema, isCLI && (parameters.preprocess = Number);
      break;
    case "string":
      SchemaConstructor = StringSchema;
      break;
    case "choice":
      SchemaConstructor = ChoiceSchema, parameters.choices = optionInfo.choices.map((choiceInfo) => choiceInfo?.redirect ? {
        ...choiceInfo,
        redirect: {
          to: {
            key: optionInfo.name,
            value: choiceInfo.redirect
          }
        }
      } : choiceInfo);
      break;
    case "boolean":
      SchemaConstructor = BooleanSchema;
      break;
    case "flag":
      SchemaConstructor = FlagSchema, parameters.flags = optionInfos.flatMap((optionInfo2) => [optionInfo2.alias, optionInfo2.description && optionInfo2.name, optionInfo2.oppositeDescription && `no-${optionInfo2.name}`].filter(Boolean));
      break;
    case "path":
      SchemaConstructor = StringSchema;
      break;
    default:
      throw new Error(`Unexpected type ${optionInfo.type}`);
  }
  if (optionInfo.exception ? parameters.validate = (value, schema2, utils2) => optionInfo.exception(value) || schema2.validate(value, utils2) : parameters.validate = (value, schema2, utils2) => value === void 0 || schema2.validate(value, utils2), optionInfo.redirect && (handlers.redirect = (value) => value ? {
    to: {
      key: optionInfo.redirect.option,
      value: optionInfo.redirect.value
    }
  } : void 0), optionInfo.deprecated && (handlers.deprecated = !0), isCLI && !optionInfo.array) {
    const originalPreprocess = parameters.preprocess || ((x) => x);
    parameters.preprocess = (value, schema2, utils2) => schema2.preprocess(originalPreprocess(Array.isArray(value) ? at_default(
      /* isOptionalObject*/
      !1,
      value,
      -1
    ) : value), utils2);
  }
  return optionInfo.array ? ArraySchema.create({
    ...isCLI ? {
      preprocess: (v) => Array.isArray(v) ? v : [v]
    } : {},
    ...handlers,
    // @ts-expect-error
    valueSchema: SchemaConstructor.create(parameters)
  }) : SchemaConstructor.create({
    ...parameters,
    ...handlers
  });
}
var normalize_options_default = normalizeOptions, arrayFindLast = (isOptionalObject, array2, callback) => {
  if (!(isOptionalObject && array2 == null)) {
    if (array2.findLast)
      return array2.findLast(callback);
    for (let index = array2.length - 1; index >= 0; index--) {
      const element = array2[index];
      if (callback(element, index, array2))
        return element;
    }
  }
}, array_find_last_default = arrayFindLast;
function getParserPluginByParserName(plugins, parserName) {
  if (!parserName)
    throw new Error("parserName is required.");
  const plugin = array_find_last_default(
    /* isOptionalObject*/
    !1,
    plugins,
    (plugin2) => plugin2.parsers && Object.prototype.hasOwnProperty.call(plugin2.parsers, parserName)
  );
  if (plugin)
    return plugin;
  let message = `Couldn't resolve parser "${parserName}".`;
  throw new ConfigError(message);
}
function getPrinterPluginByAstFormat(plugins, astFormat) {
  if (!astFormat)
    throw new Error("astFormat is required.");
  const plugin = array_find_last_default(
    /* isOptionalObject*/
    !1,
    plugins,
    (plugin2) => plugin2.printers && Object.prototype.hasOwnProperty.call(plugin2.printers, astFormat)
  );
  if (plugin)
    return plugin;
  let message = `Couldn't find plugin for AST format "${astFormat}".`;
  throw new ConfigError(message);
}
function resolveParser({
  plugins,
  parser
}) {
  const plugin = getParserPluginByParserName(plugins, parser);
  return initParser(plugin, parser);
}
function initParser(plugin, parserName) {
  const parserOrParserInitFunction = plugin.parsers[parserName];
  return typeof parserOrParserInitFunction == "function" ? parserOrParserInitFunction() : parserOrParserInitFunction;
}
function initPrinter(plugin, astFormat) {
  const printerOrPrinterInitFunction = plugin.printers[astFormat];
  return typeof printerOrPrinterInitFunction == "function" ? printerOrPrinterInitFunction() : printerOrPrinterInitFunction;
}
var formatOptionsHiddenDefaults = {
  astFormat: "estree",
  printer: {},
  originalText: void 0,
  locStart: null,
  locEnd: null
};
async function normalizeFormatOptions(options8, opts = {}) {
  var _a;
  const rawOptions = { ...options8 };
  if (!rawOptions.parser)
    if (rawOptions.filepath) {
      if (rawOptions.parser = infer_parser_default(rawOptions, {
        physicalFile: rawOptions.filepath
      }), !rawOptions.parser)
        throw new UndefinedParserError(
          `No parser could be inferred for file "${rawOptions.filepath}".`
        );
    } else
      throw new UndefinedParserError(
        "No parser and no file path given, couldn't infer a parser."
      );
  const supportOptions = getSupportInfo({
    plugins: options8.plugins,
    showDeprecated: !0
  }).options, defaults = {
    ...formatOptionsHiddenDefaults,
    ...Object.fromEntries(
      supportOptions.filter((optionInfo) => optionInfo.default !== void 0).map((option) => [option.name, option.default])
    )
  }, parserPlugin = getParserPluginByParserName(
    rawOptions.plugins,
    rawOptions.parser
  ), parser = await initParser(parserPlugin, rawOptions.parser);
  rawOptions.astFormat = parser.astFormat, rawOptions.locEnd = parser.locEnd, rawOptions.locStart = parser.locStart;
  const printerPlugin = (_a = parserPlugin.printers) != null && _a[parser.astFormat] ? parserPlugin : getPrinterPluginByAstFormat(rawOptions.plugins, parser.astFormat), printer2 = await initPrinter(printerPlugin, parser.astFormat);
  rawOptions.printer = printer2;
  const pluginDefaults = printerPlugin.defaultOptions ? Object.fromEntries(
    Object.entries(printerPlugin.defaultOptions).filter(
      ([, value]) => value !== void 0
    )
  ) : {}, mixedDefaults = { ...defaults, ...pluginDefaults };
  for (const [k, value] of Object.entries(mixedDefaults))
    (rawOptions[k] === null || rawOptions[k] === void 0) && (rawOptions[k] = value);
  return rawOptions.parser === "json" && (rawOptions.trailingComma = "none"), normalize_options_default(rawOptions, supportOptions, {
    passThrough: Object.keys(formatOptionsHiddenDefaults),
    ...opts
  });
}
var normalize_format_options_default = normalizeFormatOptions, import_code_frame2 = __toESM(require_lib3(), 1);
async function parse4(originalText, options8) {
  const parser = await resolveParser(options8), text = parser.preprocess ? parser.preprocess(originalText, options8) : originalText;
  options8.originalText = text;
  let ast;
  try {
    ast = await parser.parse(
      text,
      options8,
      // TODO: remove the third argument in v4
      // The duplicated argument is passed as intended, see #10156
      options8
    );
  } catch (error) {
    handleParseError(error, originalText);
  }
  return { text, ast };
}
function handleParseError(error, text) {
  const { loc } = error;
  if (loc) {
    const codeFrame = (0, import_code_frame2.codeFrameColumns)(text, loc, { highlightCode: !0 });
    throw error.message += `
` + codeFrame, error.codeFrame = codeFrame, error;
  }
  throw error;
}
var parse_default = parse4;
async function printEmbeddedLanguages(path13, genericPrint, options8, printAstToDoc2, embeds) {
  const {
    embeddedLanguageFormatting,
    printer: {
      embed,
      hasPrettierIgnore = () => !1,
      getVisitorKeys: printerGetVisitorKeys
    }
  } = options8;
  if (!embed || embeddedLanguageFormatting !== "auto")
    return;
  if (embed.length > 2)
    throw new Error(
      "printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/en/plugins.html#optional-embed"
    );
  const getVisitorKeys = create_get_visitor_keys_function_default(
    embed.getVisitorKeys ?? printerGetVisitorKeys
  ), embedCallResults = [];
  recurse();
  const originalPathStack = path13.stack;
  for (const { print, node, pathStack } of embedCallResults)
    try {
      path13.stack = pathStack;
      const doc2 = await print(textToDocForEmbed, genericPrint, path13, options8);
      doc2 && embeds.set(node, doc2);
    } catch (error) {
      if (process.env.PRETTIER_DEBUG)
        throw error;
    }
  path13.stack = originalPathStack;
  function textToDocForEmbed(text, partialNextOptions) {
    return textToDoc(text, partialNextOptions, options8, printAstToDoc2);
  }
  function recurse() {
    const { node } = path13;
    if (node === null || typeof node != "object" || hasPrettierIgnore(path13))
      return;
    for (const key2 of getVisitorKeys(node))
      Array.isArray(node[key2]) ? path13.each(recurse, key2) : path13.call(recurse, key2);
    const result = embed(path13, options8);
    if (result) {
      if (typeof result == "function") {
        embedCallResults.push({
          print: result,
          node,
          pathStack: [...path13.stack]
        });
        return;
      }
      embeds.set(node, result);
    }
  }
}
async function textToDoc(text, partialNextOptions, parentOptions, printAstToDoc2) {
  const options8 = await normalize_format_options_default(
    {
      ...parentOptions,
      ...partialNextOptions,
      parentParser: parentOptions.parser,
      originalText: text
    },
    { passThrough: !0 }
  ), { ast } = await parse_default(text, options8), doc2 = await printAstToDoc2(ast, options8);
  return stripTrailingHardline(doc2);
}
function printIgnored(path13, options8) {
  const {
    originalText,
    [Symbol.for("comments")]: comments,
    locStart,
    locEnd,
    [Symbol.for("printedComments")]: printedComments
  } = options8, { node } = path13, start = locStart(node), end = locEnd(node);
  for (const comment of comments)
    locStart(comment) >= start && locEnd(comment) <= end && printedComments.add(comment);
  return originalText.slice(start, end);
}
var print_ignored_default = printIgnored;
async function printAstToDoc(ast, options8) {
  ({ ast } = await prepareToPrint(ast, options8));
  const cache3 = /* @__PURE__ */ new Map(), path13 = new ast_path_default(ast), ensurePrintingNode = create_print_pre_check_function_default(), embeds = /* @__PURE__ */ new Map();
  await printEmbeddedLanguages(path13, mainPrint, options8, printAstToDoc, embeds);
  const doc2 = await callPluginPrintFunction(
    path13,
    options8,
    mainPrint,
    void 0,
    embeds
  );
  return ensureAllCommentsPrinted(options8), doc2;
  function mainPrint(selector, args) {
    return selector === void 0 || selector === path13 ? mainPrintInternal(args) : Array.isArray(selector) ? path13.call(() => mainPrintInternal(args), ...selector) : path13.call(() => mainPrintInternal(args), selector);
  }
  function mainPrintInternal(args) {
    ensurePrintingNode(path13);
    const value = path13.node;
    if (value == null)
      return "";
    const shouldCache = value && typeof value == "object" && args === void 0;
    if (shouldCache && cache3.has(value))
      return cache3.get(value);
    const doc3 = callPluginPrintFunction(path13, options8, mainPrint, args, embeds);
    return shouldCache && cache3.set(value, doc3), doc3;
  }
}
function callPluginPrintFunction(path13, options8, printPath, args, embeds) {
  var _a;
  const { node } = path13, { printer: printer2 } = options8;
  let doc2;
  return (_a = printer2.hasPrettierIgnore) != null && _a.call(printer2, path13) ? doc2 = print_ignored_default(path13, options8) : embeds.has(node) ? doc2 = embeds.get(node) : doc2 = printer2.print(path13, options8, printPath, args), node === options8.cursorNode && (doc2 = inheritLabel(doc2, (doc3) => [cursor, doc3, cursor])), printer2.printComment && (!printer2.willPrintOwnComments || !printer2.willPrintOwnComments(path13, options8)) && (doc2 = printComments(path13, doc2, options8)), doc2;
}
async function prepareToPrint(ast, options8) {
  const comments = ast.comments ?? [];
  options8[Symbol.for("comments")] = comments, options8[Symbol.for("tokens")] = ast.tokens ?? [], options8[Symbol.for("printedComments")] = /* @__PURE__ */ new Set(), attachComments(ast, options8);
  const {
    printer: { preprocess }
  } = options8;
  return ast = preprocess ? await preprocess(ast, options8) : ast, { ast, comments };
}
function getCursorNode(ast, options8) {
  const { cursorOffset, locStart, locEnd } = options8, getVisitorKeys = create_get_visitor_keys_function_default(
    options8.printer.getVisitorKeys
  ), nodeContainsCursor = (node) => locStart(node) <= cursorOffset && locEnd(node) >= cursorOffset;
  let cursorNode = ast;
  for (const node of getDescendants(ast, {
    getVisitorKeys,
    filter: nodeContainsCursor
  }))
    cursorNode = node;
  return cursorNode;
}
var get_cursor_node_default = getCursorNode;
function massageAst(ast, options8) {
  const {
    printer: {
      massageAstNode: cleanFunction,
      getVisitorKeys: printerGetVisitorKeys
    }
  } = options8;
  if (!cleanFunction)
    return ast;
  const getVisitorKeys = create_get_visitor_keys_function_default(printerGetVisitorKeys), ignoredProperties = cleanFunction.ignoredProperties ?? /* @__PURE__ */ new Set();
  return recurse(ast);
  function recurse(node, parent) {
    if (!(node !== null && typeof node == "object"))
      return node;
    if (Array.isArray(node))
      return node.map((child) => recurse(child, parent)).filter(Boolean);
    const newObj = {}, childrenKeys = new Set(getVisitorKeys(node));
    for (const key2 in node)
      !Object.prototype.hasOwnProperty.call(node, key2) || ignoredProperties.has(key2) || (childrenKeys.has(key2) ? newObj[key2] = recurse(node[key2], node) : newObj[key2] = node[key2]);
    const result = cleanFunction(node, newObj, parent);
    if (result !== null)
      return result ?? newObj;
  }
}
var massage_ast_default = massageAst, isJsonParser = ({ parser }) => parser === "json" || parser === "json5" || parser === "jsonc" || parser === "json-stringify";
function findCommonAncestor(startNodeAndParents, endNodeAndParents) {
  const startNodeAndAncestors = [
    startNodeAndParents.node,
    ...startNodeAndParents.parentNodes
  ], endNodeAndAncestors = /* @__PURE__ */ new Set([
    endNodeAndParents.node,
    ...endNodeAndParents.parentNodes
  ]);
  return startNodeAndAncestors.find(
    (node) => jsonSourceElements.has(node.type) && endNodeAndAncestors.has(node)
  );
}
function dropRootParents(parents) {
  let lastParentIndex = parents.length - 1;
  for (; ; ) {
    const parent = parents[lastParentIndex];
    if (parent?.type === "Program" || parent?.type === "File")
      lastParentIndex--;
    else
      break;
  }
  return parents.slice(0, lastParentIndex + 1);
}
function findSiblingAncestors(startNodeAndParents, endNodeAndParents, { locStart, locEnd }) {
  let resultStartNode = startNodeAndParents.node, resultEndNode = endNodeAndParents.node;
  if (resultStartNode === resultEndNode)
    return {
      startNode: resultStartNode,
      endNode: resultEndNode
    };
  const startNodeStart = locStart(startNodeAndParents.node);
  for (const endParent of dropRootParents(endNodeAndParents.parentNodes))
    if (locStart(endParent) >= startNodeStart)
      resultEndNode = endParent;
    else
      break;
  const endNodeEnd = locEnd(endNodeAndParents.node);
  for (const startParent of dropRootParents(startNodeAndParents.parentNodes)) {
    if (locEnd(startParent) <= endNodeEnd)
      resultStartNode = startParent;
    else
      break;
    if (resultStartNode === resultEndNode)
      break;
  }
  return {
    startNode: resultStartNode,
    endNode: resultEndNode
  };
}
function findNodeAtOffset(node, offset, options8, predicate, parentNodes = [], type2) {
  const { locStart, locEnd } = options8, start = locStart(node), end = locEnd(node);
  if (!(offset > end || offset < start || type2 === "rangeEnd" && offset === start || type2 === "rangeStart" && offset === end)) {
    for (const childNode of getSortedChildNodes(node, options8)) {
      const childResult = findNodeAtOffset(
        childNode,
        offset,
        options8,
        predicate,
        [node, ...parentNodes],
        type2
      );
      if (childResult)
        return childResult;
    }
    if (!predicate || predicate(node, parentNodes[0]))
      return {
        node,
        parentNodes
      };
  }
}
function isJsSourceElement(type2, parentType) {
  return parentType !== "DeclareExportDeclaration" && type2 !== "TypeParameterDeclaration" && (type2 === "Directive" || type2 === "TypeAlias" || type2 === "TSExportAssignment" || type2.startsWith("Declare") || type2.startsWith("TSDeclare") || type2.endsWith("Statement") || type2.endsWith("Declaration"));
}
var jsonSourceElements = /* @__PURE__ */ new Set([
  "JsonRoot",
  "ObjectExpression",
  "ArrayExpression",
  "StringLiteral",
  "NumericLiteral",
  "BooleanLiteral",
  "NullLiteral",
  "UnaryExpression",
  "TemplateLiteral"
]), graphqlSourceElements = /* @__PURE__ */ new Set([
  "OperationDefinition",
  "FragmentDefinition",
  "VariableDefinition",
  "TypeExtensionDefinition",
  "ObjectTypeDefinition",
  "FieldDefinition",
  "DirectiveDefinition",
  "EnumTypeDefinition",
  "EnumValueDefinition",
  "InputValueDefinition",
  "InputObjectTypeDefinition",
  "SchemaDefinition",
  "OperationTypeDefinition",
  "InterfaceTypeDefinition",
  "UnionTypeDefinition",
  "ScalarTypeDefinition"
]);
function isSourceElement(opts, node, parentNode) {
  if (!node)
    return !1;
  switch (opts.parser) {
    case "flow":
    case "babel":
    case "babel-flow":
    case "babel-ts":
    case "typescript":
    case "acorn":
    case "espree":
    case "meriyah":
    case "__babel_estree":
      return isJsSourceElement(node.type, parentNode?.type);
    case "json":
    case "json5":
    case "jsonc":
    case "json-stringify":
      return jsonSourceElements.has(node.type);
    case "graphql":
      return graphqlSourceElements.has(node.kind);
    case "vue":
      return node.tag !== "root";
  }
  return !1;
}
function calculateRange(text, opts, ast) {
  let { rangeStart: start, rangeEnd: end, locStart, locEnd } = opts;
  require$$1__default.default.ok(end > start);
  const firstNonWhitespaceCharacterIndex = text.slice(start, end).search(/\S/), isAllWhitespace = firstNonWhitespaceCharacterIndex === -1;
  if (!isAllWhitespace)
    for (start += firstNonWhitespaceCharacterIndex; end > start && !/\S/.test(text[end - 1]); --end)
      ;
  const startNodeAndParents = findNodeAtOffset(
    ast,
    start,
    opts,
    (node, parentNode) => isSourceElement(opts, node, parentNode),
    [],
    "rangeStart"
  ), endNodeAndParents = (
    // No need find Node at `end`, it will be the same as `startNodeAndParents`
    isAllWhitespace ? startNodeAndParents : findNodeAtOffset(
      ast,
      end,
      opts,
      (node) => isSourceElement(opts, node),
      [],
      "rangeEnd"
    )
  );
  if (!startNodeAndParents || !endNodeAndParents)
    return {
      rangeStart: 0,
      rangeEnd: 0
    };
  let startNode, endNode;
  if (isJsonParser(opts)) {
    const commonAncestor = findCommonAncestor(
      startNodeAndParents,
      endNodeAndParents
    );
    startNode = commonAncestor, endNode = commonAncestor;
  } else
    ({ startNode, endNode } = findSiblingAncestors(
      startNodeAndParents,
      endNodeAndParents,
      opts
    ));
  return {
    rangeStart: Math.min(locStart(startNode), locStart(endNode)),
    rangeEnd: Math.max(locEnd(startNode), locEnd(endNode))
  };
}
var BOM = "\uFEFF", CURSOR = Symbol("cursor");
async function coreFormat(originalText, opts, addAlignmentSize = 0) {
  if (!originalText || originalText.trim().length === 0)
    return {
      formatted: "",
      cursorOffset: -1,
      comments: []
    };
  const {
    ast,
    text
  } = await parse_default(originalText, opts);
  opts.cursorOffset >= 0 && (opts.cursorNode = get_cursor_node_default(ast, opts));
  let doc2 = await printAstToDoc(ast, opts);
  addAlignmentSize > 0 && (doc2 = addAlignmentToDoc([hardline, doc2], addAlignmentSize, opts.tabWidth));
  const result = printDocToString(doc2, opts);
  if (addAlignmentSize > 0) {
    const trimmed = result.formatted.trim();
    result.cursorNodeStart !== void 0 && (result.cursorNodeStart -= result.formatted.indexOf(trimmed)), result.formatted = trimmed + convertEndOfLineToChars(opts.endOfLine);
  }
  const comments = opts[Symbol.for("comments")];
  if (opts.cursorOffset >= 0) {
    let oldCursorNodeStart, oldCursorNodeText, cursorOffsetRelativeToOldCursorNode, newCursorNodeStart, newCursorNodeText;
    if (opts.cursorNode && result.cursorNodeText ? (oldCursorNodeStart = opts.locStart(opts.cursorNode), oldCursorNodeText = text.slice(oldCursorNodeStart, opts.locEnd(opts.cursorNode)), cursorOffsetRelativeToOldCursorNode = opts.cursorOffset - oldCursorNodeStart, newCursorNodeStart = result.cursorNodeStart, newCursorNodeText = result.cursorNodeText) : (oldCursorNodeStart = 0, oldCursorNodeText = text, cursorOffsetRelativeToOldCursorNode = opts.cursorOffset, newCursorNodeStart = 0, newCursorNodeText = result.formatted), oldCursorNodeText === newCursorNodeText)
      return {
        formatted: result.formatted,
        cursorOffset: newCursorNodeStart + cursorOffsetRelativeToOldCursorNode,
        comments
      };
    const oldCursorNodeCharArray = oldCursorNodeText.split("");
    oldCursorNodeCharArray.splice(cursorOffsetRelativeToOldCursorNode, 0, CURSOR);
    const newCursorNodeCharArray = newCursorNodeText.split(""), cursorNodeDiff = (0, import_diff.diffArrays)(oldCursorNodeCharArray, newCursorNodeCharArray);
    let cursorOffset = newCursorNodeStart;
    for (const entry of cursorNodeDiff)
      if (entry.removed) {
        if (entry.value.includes(CURSOR))
          break;
      } else
        cursorOffset += entry.count;
    return {
      formatted: result.formatted,
      cursorOffset,
      comments
    };
  }
  return {
    formatted: result.formatted,
    cursorOffset: -1,
    comments
  };
}
async function formatRange(originalText, opts) {
  const {
    ast,
    text
  } = await parse_default(originalText, opts), {
    rangeStart,
    rangeEnd
  } = calculateRange(text, opts, ast), rangeString = text.slice(rangeStart, rangeEnd), rangeStart2 = Math.min(rangeStart, text.lastIndexOf(`
`, rangeStart) + 1), indentString = text.slice(rangeStart2, rangeStart).match(/^\s*/)[0], alignmentSize = get_alignment_size_default(indentString, opts.tabWidth), rangeResult = await coreFormat(rangeString, {
    ...opts,
    rangeStart: 0,
    rangeEnd: Number.POSITIVE_INFINITY,
    // Track the cursor offset only if it's within our range
    cursorOffset: opts.cursorOffset > rangeStart && opts.cursorOffset <= rangeEnd ? opts.cursorOffset - rangeStart : -1,
    // Always use `lf` to format, we'll replace it later
    endOfLine: "lf"
  }, alignmentSize), rangeTrimmed = rangeResult.formatted.trimEnd();
  let {
    cursorOffset
  } = opts;
  cursorOffset > rangeEnd ? cursorOffset += rangeTrimmed.length - rangeString.length : rangeResult.cursorOffset >= 0 && (cursorOffset = rangeResult.cursorOffset + rangeStart);
  let formatted = text.slice(0, rangeStart) + rangeTrimmed + text.slice(rangeEnd);
  if (opts.endOfLine !== "lf") {
    const eol = convertEndOfLineToChars(opts.endOfLine);
    cursorOffset >= 0 && eol === `\r
` && (cursorOffset += countEndOfLineChars(formatted.slice(0, cursorOffset), `
`)), formatted = string_replace_all_default(
      /* isOptionalObject*/
      !1,
      formatted,
      `
`,
      eol
    );
  }
  return {
    formatted,
    cursorOffset,
    comments: rangeResult.comments
  };
}
function ensureIndexInText(text, index, defaultValue) {
  return typeof index != "number" || Number.isNaN(index) || index < 0 || index > text.length ? defaultValue : index;
}
function normalizeIndexes(text, options8) {
  let {
    cursorOffset,
    rangeStart,
    rangeEnd
  } = options8;
  return cursorOffset = ensureIndexInText(text, cursorOffset, -1), rangeStart = ensureIndexInText(text, rangeStart, 0), rangeEnd = ensureIndexInText(text, rangeEnd, text.length), {
    ...options8,
    cursorOffset,
    rangeStart,
    rangeEnd
  };
}
function normalizeInputAndOptions(text, options8) {
  let {
    cursorOffset,
    rangeStart,
    rangeEnd,
    endOfLine
  } = normalizeIndexes(text, options8);
  const hasBOM = text.charAt(0) === BOM;
  if (hasBOM && (text = text.slice(1), cursorOffset--, rangeStart--, rangeEnd--), endOfLine === "auto" && (endOfLine = guessEndOfLine(text)), text.includes("\r")) {
    const countCrlfBefore = (index) => countEndOfLineChars(text.slice(0, Math.max(index, 0)), `\r
`);
    cursorOffset -= countCrlfBefore(cursorOffset), rangeStart -= countCrlfBefore(rangeStart), rangeEnd -= countCrlfBefore(rangeEnd), text = normalizeEndOfLine(text);
  }
  return {
    hasBOM,
    text,
    options: normalizeIndexes(text, {
      ...options8,
      cursorOffset,
      rangeStart,
      rangeEnd,
      endOfLine
    })
  };
}
async function hasPragma(text, options8) {
  const selectedParser = await resolveParser(options8);
  return !selectedParser.hasPragma || selectedParser.hasPragma(text);
}
async function formatWithCursor(originalText, originalOptions) {
  let {
    hasBOM,
    text,
    options: options8
  } = normalizeInputAndOptions(originalText, await normalize_format_options_default(originalOptions));
  if (options8.rangeStart >= options8.rangeEnd && text !== "" || options8.requirePragma && !await hasPragma(text, options8))
    return {
      formatted: originalText,
      cursorOffset: originalOptions.cursorOffset,
      comments: []
    };
  let result;
  return options8.rangeStart > 0 || options8.rangeEnd < text.length ? result = await formatRange(text, options8) : (!options8.requirePragma && options8.insertPragma && options8.printer.insertPragma && !await hasPragma(text, options8) && (text = options8.printer.insertPragma(text)), result = await coreFormat(text, options8)), hasBOM && (result.formatted = BOM + result.formatted, result.cursorOffset >= 0 && result.cursorOffset++), result;
}
async function parse5(originalText, originalOptions, devOptions) {
  const {
    text,
    options: options8
  } = normalizeInputAndOptions(originalText, await normalize_format_options_default(originalOptions)), parsed = await parse_default(text, options8);
  return devOptions && (devOptions.preprocessForPrint && (parsed.ast = await prepareToPrint(parsed.ast, options8)), devOptions.massage && (parsed.ast = massage_ast_default(parsed.ast, options8))), parsed;
}
async function formatAst(ast, options8) {
  options8 = await normalize_format_options_default(options8);
  const doc2 = await printAstToDoc(ast, options8);
  return printDocToString(doc2, options8);
}
async function formatDoc(doc2, options8) {
  const text = printDocToDebug(doc2), {
    formatted
  } = await formatWithCursor(text, {
    ...options8,
    parser: "__js_expression"
  });
  return formatted;
}
async function printToDoc(originalText, options8) {
  options8 = await normalize_format_options_default(options8);
  const {
    ast
  } = await parse_default(originalText, options8);
  return printAstToDoc(ast, options8);
}
async function printDocToString2(doc2, options8) {
  return printDocToString(doc2, await normalize_format_options_default(options8));
}
var option_categories_exports = {};
__export(option_categories_exports, {
  CATEGORY_CONFIG: () => CATEGORY_CONFIG,
  CATEGORY_EDITOR: () => CATEGORY_EDITOR,
  CATEGORY_FORMAT: () => CATEGORY_FORMAT,
  CATEGORY_GLOBAL: () => CATEGORY_GLOBAL,
  CATEGORY_OTHER: () => CATEGORY_OTHER,
  CATEGORY_OUTPUT: () => CATEGORY_OUTPUT,
  CATEGORY_SPECIAL: () => CATEGORY_SPECIAL
});
var CATEGORY_CONFIG = "Config", CATEGORY_EDITOR = "Editor", CATEGORY_FORMAT = "Format", CATEGORY_OTHER = "Other", CATEGORY_OUTPUT = "Output", CATEGORY_GLOBAL = "Global", CATEGORY_SPECIAL = "Special", builtin_plugins_proxy_exports = {};
__export(builtin_plugins_proxy_exports, {
  languages: () => languages,
  options: () => options7,
  parsers: () => parsers,
  printers: () => printers
});
var languages_evaluate_default = [
  {
    linguistLanguageId: 50,
    name: "CSS",
    type: "markup",
    tmScope: "source.css",
    aceMode: "css",
    codemirrorMode: "css",
    codemirrorMimeType: "text/css",
    color: "#563d7c",
    extensions: [
      ".css",
      ".wxss"
    ],
    parsers: [
      "css"
    ],
    vscodeLanguageIds: [
      "css"
    ]
  },
  {
    linguistLanguageId: 262764437,
    name: "PostCSS",
    type: "markup",
    color: "#dc3a0c",
    tmScope: "source.postcss",
    group: "CSS",
    extensions: [
      ".pcss",
      ".postcss"
    ],
    aceMode: "text",
    parsers: [
      "css"
    ],
    vscodeLanguageIds: [
      "postcss"
    ]
  },
  {
    linguistLanguageId: 198,
    name: "Less",
    type: "markup",
    color: "#1d365d",
    aliases: [
      "less-css"
    ],
    extensions: [
      ".less"
    ],
    tmScope: "source.css.less",
    aceMode: "less",
    codemirrorMode: "css",
    codemirrorMimeType: "text/css",
    parsers: [
      "less"
    ],
    vscodeLanguageIds: [
      "less"
    ]
  },
  {
    linguistLanguageId: 329,
    name: "SCSS",
    type: "markup",
    color: "#c6538c",
    tmScope: "source.css.scss",
    aceMode: "scss",
    codemirrorMode: "css",
    codemirrorMimeType: "text/x-scss",
    extensions: [
      ".scss"
    ],
    parsers: [
      "scss"
    ],
    vscodeLanguageIds: [
      "scss"
    ]
  }
], common_options_evaluate_default = {
  bracketSpacing: {
    category: "Common",
    type: "boolean",
    default: !0,
    description: "Print spaces between brackets.",
    oppositeDescription: "Do not print spaces between brackets."
  },
  singleQuote: {
    category: "Common",
    type: "boolean",
    default: !1,
    description: "Use single quotes instead of double quotes."
  },
  proseWrap: {
    category: "Common",
    type: "choice",
    default: "preserve",
    description: "How to wrap prose.",
    choices: [
      {
        value: "always",
        description: "Wrap prose if it exceeds the print width."
      },
      {
        value: "never",
        description: "Do not wrap prose."
      },
      {
        value: "preserve",
        description: "Wrap prose as-is."
      }
    ]
  },
  bracketSameLine: {
    category: "Common",
    type: "boolean",
    default: !1,
    description: "Put > of opening tags on the last line instead of on a new line."
  },
  singleAttributePerLine: {
    category: "Common",
    type: "boolean",
    default: !1,
    description: "Enforce single attribute per line in HTML, Vue and JSX."
  }
}, options = {
  singleQuote: common_options_evaluate_default.singleQuote
}, options_default = options, languages_evaluate_default2 = [
  {
    linguistLanguageId: 139,
    name: "GraphQL",
    type: "data",
    color: "#e10098",
    extensions: [
      ".graphql",
      ".gql",
      ".graphqls"
    ],
    tmScope: "source.graphql",
    aceMode: "text",
    parsers: [
      "graphql"
    ],
    vscodeLanguageIds: [
      "graphql"
    ]
  }
], options2 = {
  bracketSpacing: common_options_evaluate_default.bracketSpacing
}, options_default2 = options2, languages_evaluate_default3 = [
  {
    linguistLanguageId: 155,
    name: "Handlebars",
    type: "markup",
    color: "#f7931e",
    aliases: [
      "hbs",
      "htmlbars"
    ],
    extensions: [
      ".handlebars",
      ".hbs"
    ],
    tmScope: "text.html.handlebars",
    aceMode: "handlebars",
    parsers: [
      "glimmer"
    ],
    vscodeLanguageIds: [
      "handlebars"
    ]
  }
], languages_evaluate_default4 = [
  {
    linguistLanguageId: 146,
    name: "Angular",
    type: "markup",
    tmScope: "text.html.basic",
    aceMode: "html",
    codemirrorMode: "htmlmixed",
    codemirrorMimeType: "text/html",
    color: "#e34c26",
    aliases: [
      "xhtml"
    ],
    extensions: [
      ".component.html"
    ],
    parsers: [
      "angular"
    ],
    vscodeLanguageIds: [
      "html"
    ],
    filenames: []
  },
  {
    linguistLanguageId: 146,
    name: "HTML",
    type: "markup",
    tmScope: "text.html.basic",
    aceMode: "html",
    codemirrorMode: "htmlmixed",
    codemirrorMimeType: "text/html",
    color: "#e34c26",
    aliases: [
      "xhtml"
    ],
    extensions: [
      ".html",
      ".hta",
      ".htm",
      ".html.hl",
      ".inc",
      ".xht",
      ".xhtml",
      ".mjml"
    ],
    parsers: [
      "html"
    ],
    vscodeLanguageIds: [
      "html"
    ]
  },
  {
    linguistLanguageId: 146,
    name: "Lightning Web Components",
    type: "markup",
    tmScope: "text.html.basic",
    aceMode: "html",
    codemirrorMode: "htmlmixed",
    codemirrorMimeType: "text/html",
    color: "#e34c26",
    aliases: [
      "xhtml"
    ],
    extensions: [],
    parsers: [
      "lwc"
    ],
    vscodeLanguageIds: [
      "html"
    ],
    filenames: []
  },
  {
    linguistLanguageId: 391,
    name: "Vue",
    type: "markup",
    color: "#41b883",
    extensions: [
      ".vue"
    ],
    tmScope: "text.html.vue",
    aceMode: "html",
    parsers: [
      "vue"
    ],
    vscodeLanguageIds: [
      "vue"
    ]
  }
], CATEGORY_HTML = "HTML", options3 = {
  bracketSameLine: common_options_evaluate_default.bracketSameLine,
  htmlWhitespaceSensitivity: {
    category: CATEGORY_HTML,
    type: "choice",
    default: "css",
    description: "How to handle whitespaces in HTML.",
    choices: [
      {
        value: "css",
        description: "Respect the default value of CSS display property."
      },
      {
        value: "strict",
        description: "Whitespaces are considered sensitive."
      },
      {
        value: "ignore",
        description: "Whitespaces are considered insensitive."
      }
    ]
  },
  singleAttributePerLine: common_options_evaluate_default.singleAttributePerLine,
  vueIndentScriptAndStyle: {
    category: CATEGORY_HTML,
    type: "boolean",
    default: !1,
    description: "Indent script and style tags in Vue files."
  }
}, options_default3 = options3, languages_evaluate_default5 = [
  {
    linguistLanguageId: 183,
    name: "JavaScript",
    type: "programming",
    tmScope: "source.js",
    aceMode: "javascript",
    codemirrorMode: "javascript",
    codemirrorMimeType: "text/javascript",
    color: "#f1e05a",
    aliases: [
      "js",
      "node"
    ],
    extensions: [
      ".js",
      "._js",
      ".bones",
      ".cjs",
      ".es",
      ".es6",
      ".frag",
      ".gs",
      ".jake",
      ".javascript",
      ".jsb",
      ".jscad",
      ".jsfl",
      ".jslib",
      ".jsm",
      ".jspre",
      ".jss",
      ".mjs",
      ".njs",
      ".pac",
      ".sjs",
      ".ssjs",
      ".xsjs",
      ".xsjslib",
      ".wxs"
    ],
    filenames: [
      "Jakefile"
    ],
    interpreters: [
      "chakra",
      "d8",
      "gjs",
      "js",
      "node",
      "nodejs",
      "qjs",
      "rhino",
      "v8",
      "v8-shell",
      "zx"
    ],
    parsers: [
      "babel",
      "acorn",
      "espree",
      "meriyah",
      "babel-flow",
      "babel-ts",
      "flow",
      "typescript"
    ],
    vscodeLanguageIds: [
      "javascript",
      "mongo"
    ]
  },
  {
    linguistLanguageId: 183,
    name: "Flow",
    type: "programming",
    tmScope: "source.js",
    aceMode: "javascript",
    codemirrorMode: "javascript",
    codemirrorMimeType: "text/javascript",
    color: "#f1e05a",
    aliases: [],
    extensions: [
      ".js.flow"
    ],
    filenames: [],
    interpreters: [
      "chakra",
      "d8",
      "gjs",
      "js",
      "node",
      "nodejs",
      "qjs",
      "rhino",
      "v8",
      "v8-shell"
    ],
    parsers: [
      "flow",
      "babel-flow"
    ],
    vscodeLanguageIds: [
      "javascript"
    ]
  },
  {
    linguistLanguageId: 183,
    name: "JSX",
    type: "programming",
    tmScope: "source.js.jsx",
    aceMode: "javascript",
    codemirrorMode: "jsx",
    codemirrorMimeType: "text/jsx",
    color: void 0,
    aliases: void 0,
    extensions: [
      ".jsx"
    ],
    filenames: void 0,
    interpreters: void 0,
    parsers: [
      "babel",
      "babel-flow",
      "babel-ts",
      "flow",
      "typescript",
      "espree",
      "meriyah"
    ],
    vscodeLanguageIds: [
      "javascriptreact"
    ],
    group: "JavaScript"
  },
  {
    linguistLanguageId: 378,
    name: "TypeScript",
    type: "programming",
    color: "#3178c6",
    aliases: [
      "ts"
    ],
    interpreters: [
      "deno",
      "ts-node"
    ],
    extensions: [
      ".ts",
      ".cts",
      ".mts"
    ],
    tmScope: "source.ts",
    aceMode: "typescript",
    codemirrorMode: "javascript",
    codemirrorMimeType: "application/typescript",
    parsers: [
      "typescript",
      "babel-ts"
    ],
    vscodeLanguageIds: [
      "typescript"
    ]
  },
  {
    linguistLanguageId: 94901924,
    name: "TSX",
    type: "programming",
    color: "#3178c6",
    group: "TypeScript",
    extensions: [
      ".tsx"
    ],
    tmScope: "source.tsx",
    aceMode: "javascript",
    codemirrorMode: "jsx",
    codemirrorMimeType: "text/jsx",
    parsers: [
      "typescript",
      "babel-ts"
    ],
    vscodeLanguageIds: [
      "typescriptreact"
    ]
  }
], CATEGORY_JAVASCRIPT = "JavaScript", options4 = {
  arrowParens: {
    category: CATEGORY_JAVASCRIPT,
    type: "choice",
    default: "always",
    description: "Include parentheses around a sole arrow function parameter.",
    choices: [
      {
        value: "always",
        description: "Always include parens. Example: `(x) => x`"
      },
      {
        value: "avoid",
        description: "Omit parens when possible. Example: `x => x`"
      }
    ]
  },
  bracketSameLine: common_options_evaluate_default.bracketSameLine,
  bracketSpacing: common_options_evaluate_default.bracketSpacing,
  jsxBracketSameLine: {
    category: CATEGORY_JAVASCRIPT,
    type: "boolean",
    description: "Put > on the last line instead of at a new line.",
    deprecated: "2.4.0"
  },
  semi: {
    category: CATEGORY_JAVASCRIPT,
    type: "boolean",
    default: !0,
    description: "Print semicolons.",
    oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them."
  },
  experimentalTernaries: {
    category: CATEGORY_JAVASCRIPT,
    type: "boolean",
    default: !1,
    description: "Use curious ternaries, with the question mark after the condition.",
    oppositeDescription: "Default behavior of ternaries; keep question marks on the same line as the consequent."
  },
  singleQuote: common_options_evaluate_default.singleQuote,
  jsxSingleQuote: {
    category: CATEGORY_JAVASCRIPT,
    type: "boolean",
    default: !1,
    description: "Use single quotes in JSX."
  },
  quoteProps: {
    category: CATEGORY_JAVASCRIPT,
    type: "choice",
    default: "as-needed",
    description: "Change when properties in objects are quoted.",
    choices: [
      {
        value: "as-needed",
        description: "Only add quotes around object properties where required."
      },
      {
        value: "consistent",
        description: "If at least one property in an object requires quotes, quote all properties."
      },
      {
        value: "preserve",
        description: "Respect the input use of quotes in object properties."
      }
    ]
  },
  trailingComma: {
    category: CATEGORY_JAVASCRIPT,
    type: "choice",
    default: "all",
    description: "Print trailing commas wherever possible when multi-line.",
    choices: [
      {
        value: "all",
        description: "Trailing commas wherever possible (including function arguments)."
      },
      {
        value: "es5",
        description: "Trailing commas where valid in ES5 (objects, arrays, etc.)"
      },
      { value: "none", description: "No trailing commas." }
    ]
  },
  singleAttributePerLine: common_options_evaluate_default.singleAttributePerLine
}, options_default4 = options4, languages_evaluate_default6 = [
  {
    linguistLanguageId: 174,
    name: "JSON.stringify",
    type: "data",
    color: "#292929",
    tmScope: "source.json",
    aceMode: "json",
    codemirrorMode: "javascript",
    codemirrorMimeType: "application/json",
    aliases: [
      "geojson",
      "jsonl",
      "topojson"
    ],
    extensions: [
      ".importmap"
    ],
    filenames: [
      "package.json",
      "package-lock.json",
      "composer.json"
    ],
    parsers: [
      "json-stringify"
    ],
    vscodeLanguageIds: [
      "json"
    ]
  },
  {
    linguistLanguageId: 174,
    name: "JSON",
    type: "data",
    color: "#292929",
    tmScope: "source.json",
    aceMode: "json",
    codemirrorMode: "javascript",
    codemirrorMimeType: "application/json",
    aliases: [
      "geojson",
      "jsonl",
      "topojson"
    ],
    extensions: [
      ".json",
      ".4DForm",
      ".4DProject",
      ".avsc",
      ".geojson",
      ".gltf",
      ".har",
      ".ice",
      ".JSON-tmLanguage",
      ".mcmeta",
      ".tfstate",
      ".tfstate.backup",
      ".topojson",
      ".webapp",
      ".webmanifest",
      ".yy",
      ".yyp"
    ],
    filenames: [
      ".all-contributorsrc",
      ".arcconfig",
      ".auto-changelog",
      ".c8rc",
      ".htmlhintrc",
      ".imgbotconfig",
      ".nycrc",
      ".tern-config",
      ".tern-project",
      ".watchmanconfig",
      "Pipfile.lock",
      "composer.lock",
      "flake.lock",
      "mcmod.info",
      ".babelrc",
      ".jscsrc",
      ".jshintrc",
      ".jslintrc",
      ".swcrc"
    ],
    parsers: [
      "json"
    ],
    vscodeLanguageIds: [
      "json"
    ]
  },
  {
    linguistLanguageId: 423,
    name: "JSON with Comments",
    type: "data",
    color: "#292929",
    group: "JSON",
    tmScope: "source.js",
    aceMode: "javascript",
    codemirrorMode: "javascript",
    codemirrorMimeType: "text/javascript",
    aliases: [
      "jsonc"
    ],
    extensions: [
      ".jsonc",
      ".code-snippets",
      ".code-workspace",
      ".sublime-build",
      ".sublime-commands",
      ".sublime-completions",
      ".sublime-keymap",
      ".sublime-macro",
      ".sublime-menu",
      ".sublime-mousemap",
      ".sublime-project",
      ".sublime-settings",
      ".sublime-theme",
      ".sublime-workspace",
      ".sublime_metrics",
      ".sublime_session"
    ],
    filenames: [],
    parsers: [
      "jsonc"
    ],
    vscodeLanguageIds: [
      "jsonc"
    ]
  },
  {
    linguistLanguageId: 175,
    name: "JSON5",
    type: "data",
    color: "#267CB9",
    extensions: [
      ".json5"
    ],
    tmScope: "source.js",
    aceMode: "javascript",
    codemirrorMode: "javascript",
    codemirrorMimeType: "application/json",
    parsers: [
      "json5"
    ],
    vscodeLanguageIds: [
      "json5"
    ]
  }
], languages_evaluate_default7 = [
  {
    linguistLanguageId: 222,
    name: "Markdown",
    type: "prose",
    color: "#083fa1",
    aliases: [
      "md",
      "pandoc"
    ],
    aceMode: "markdown",
    codemirrorMode: "gfm",
    codemirrorMimeType: "text/x-gfm",
    wrap: !0,
    extensions: [
      ".md",
      ".livemd",
      ".markdown",
      ".mdown",
      ".mdwn",
      ".mkd",
      ".mkdn",
      ".mkdown",
      ".ronn",
      ".scd",
      ".workbook"
    ],
    filenames: [
      "contents.lr",
      "README"
    ],
    tmScope: "text.md",
    parsers: [
      "markdown"
    ],
    vscodeLanguageIds: [
      "markdown"
    ]
  },
  {
    linguistLanguageId: 222,
    name: "MDX",
    type: "prose",
    color: "#083fa1",
    aliases: [
      "md",
      "pandoc"
    ],
    aceMode: "markdown",
    codemirrorMode: "gfm",
    codemirrorMimeType: "text/x-gfm",
    wrap: !0,
    extensions: [
      ".mdx"
    ],
    filenames: [],
    tmScope: "text.md",
    parsers: [
      "mdx"
    ],
    vscodeLanguageIds: [
      "mdx"
    ]
  }
], options5 = {
  proseWrap: common_options_evaluate_default.proseWrap,
  singleQuote: common_options_evaluate_default.singleQuote
}, options_default5 = options5, languages_evaluate_default8 = [
  {
    linguistLanguageId: 407,
    name: "YAML",
    type: "data",
    color: "#cb171e",
    tmScope: "source.yaml",
    aliases: [
      "yml"
    ],
    extensions: [
      ".yml",
      ".mir",
      ".reek",
      ".rviz",
      ".sublime-syntax",
      ".syntax",
      ".yaml",
      ".yaml-tmlanguage",
      ".yaml.sed",
      ".yml.mysql"
    ],
    filenames: [
      ".clang-format",
      ".clang-tidy",
      ".gemrc",
      "CITATION.cff",
      "glide.lock",
      ".prettierrc",
      ".stylelintrc",
      ".lintstagedrc"
    ],
    aceMode: "yaml",
    codemirrorMode: "yaml",
    codemirrorMimeType: "text/x-yaml",
    parsers: [
      "yaml"
    ],
    vscodeLanguageIds: [
      "yaml",
      "ansible",
      "home-assistant"
    ]
  }
], options6 = {
  bracketSpacing: common_options_evaluate_default.bracketSpacing,
  singleQuote: common_options_evaluate_default.singleQuote,
  proseWrap: common_options_evaluate_default.proseWrap
}, options_default6 = options6;
function createParsersAndPrinters(modules) {
  const parsers2 = /* @__PURE__ */ Object.create(null), printers2 = /* @__PURE__ */ Object.create(null);
  for (const {
    importPlugin: importPlugin2,
    parsers: parserNames = [],
    printers: printerNames = []
  } of modules) {
    const loadPlugin2 = async () => {
      const plugin = await importPlugin2();
      return Object.assign(parsers2, plugin.parsers), Object.assign(printers2, plugin.printers), plugin;
    };
    for (const parserName of parserNames)
      parsers2[parserName] = async () => (await loadPlugin2()).parsers[parserName];
    for (const printerName of printerNames)
      printers2[printerName] = async () => (await loadPlugin2()).printers[printerName];
  }
  return { parsers: parsers2, printers: printers2 };
}
var options7 = {
  ...options_default,
  ...options_default2,
  ...options_default3,
  ...options_default4,
  ...options_default5,
  ...options_default6
}, languages = [
  ...languages_evaluate_default,
  ...languages_evaluate_default2,
  ...languages_evaluate_default3,
  ...languages_evaluate_default4,
  ...languages_evaluate_default5,
  ...languages_evaluate_default6,
  ...languages_evaluate_default7,
  ...languages_evaluate_default8
], { parsers, printers } = createParsersAndPrinters([
  {
    importPlugin: () => Promise.resolve().then(function() {
      return require("./acorn.js");
    }),
    parsers: ["acorn", "espree"]
  },
  {
    importPlugin: () => Promise.resolve().then(function() {
      return require("./angular.js");
    }),
    parsers: [
      "__ng_action",
      "__ng_binding",
      "__ng_interpolation",
      "__ng_directive"
    ]
  },
  {
    importPlugin: () => Promise.resolve().then(function() {
      return require("./babel.js");
    }),
    parsers: [
      "babel",
      "babel-flow",
      "babel-ts",
      "__js_expression",
      "__ts_expression",
      "__vue_expression",
      "__vue_ts_expression",
      "__vue_event_binding",
      "__vue_ts_event_binding",
      "__babel_estree",
      "json",
      "json5",
      "jsonc",
      "json-stringify"
    ]
  },
  {
    importPlugin: () => Promise.resolve().then(function() {
      return require("./estree.js");
    }),
    printers: ["estree", "estree-json"]
  },
  {
    importPlugin: () => Promise.resolve().then(function() {
      return require("./flow.js");
    }),
    parsers: ["flow"]
  },
  {
    importPlugin: () => Promise.resolve().then(function() {
      return require("./glimmer.js");
    }),
    parsers: ["glimmer"],
    printers: ["glimmer"]
  },
  {
    importPlugin: () => Promise.resolve().then(function() {
      return require("./graphql.js");
    }),
    parsers: ["graphql"],
    printers: ["graphql"]
  },
  {
    importPlugin: () => Promise.resolve().then(function() {
      return require("./html.js");
    }),
    parsers: ["html", "angular", "vue", "lwc"],
    printers: ["html"]
  },
  {
    importPlugin: () => Promise.resolve().then(function() {
      return require("./markdown.js");
    }),
    parsers: ["markdown", "mdx", "remark"],
    printers: ["mdast"]
  },
  {
    importPlugin: () => Promise.resolve().then(function() {
      return require("./meriyah.js");
    }),
    parsers: ["meriyah"]
  },
  {
    importPlugin: () => Promise.resolve().then(function() {
      return require("./postcss.js");
    }),
    parsers: ["css", "less", "scss"],
    printers: ["postcss"]
  },
  {
    importPlugin: () => Promise.resolve().then(function() {
      return require("./typescript.js");
    }),
    parsers: ["typescript"]
  },
  {
    importPlugin: () => Promise.resolve().then(function() {
      return require("./yaml.js");
    }),
    parsers: ["yaml"],
    printers: ["yaml"]
  }
]);
function loadBuiltinPlugins() {
  return [builtin_plugins_proxy_exports];
}
var load_builtin_plugins_default = loadBuiltinPlugins;
function importFromDirectory(specifier, directory) {
  return import_from_file_default(specifier, path__namespace.default.join(directory, "noop.js"));
}
var import_from_directory_default = importFromDirectory;
async function importPlugin(name, cwd) {
  if (path__namespace.default.isAbsolute(name))
    return import(require$$0.pathToFileURL(name).href);
  try {
    return await import(require$$0.pathToFileURL(path__namespace.default.resolve(name)).href);
  } catch {
    return import_from_directory_default(name, cwd);
  }
}
async function loadPluginWithoutCache(plugin, cwd) {
  const module2 = await importPlugin(plugin, cwd);
  return { name: plugin, ...module2.default ?? module2 };
}
var cache2 = /* @__PURE__ */ new Map();
function loadPlugin(plugin) {
  if (typeof plugin != "string")
    return plugin;
  const cwd = process.cwd(), cacheKey = JSON.stringify({ name: plugin, cwd });
  return cache2.has(cacheKey) || cache2.set(cacheKey, loadPluginWithoutCache(plugin, cwd)), cache2.get(cacheKey);
}
function clearCache2() {
  cache2.clear();
}
function loadPlugins(plugins = []) {
  return Promise.all(plugins.map((plugin) => loadPlugin(plugin)));
}
var load_plugins_default = loadPlugins;
function omit(object, keys) {
  return keys = new Set(keys), Object.fromEntries(
    Object.entries(object).filter(([key2]) => !keys.has(key2))
  );
}
var object_omit_default = omit, version_evaluate_default = "3.2.5", public_exports = {};
__export(public_exports, {
  addDanglingComment: () => addDanglingComment,
  addLeadingComment: () => addLeadingComment,
  addTrailingComment: () => addTrailingComment,
  getAlignmentSize: () => get_alignment_size_default,
  getIndentSize: () => get_indent_size_default,
  getMaxContinuousCount: () => get_max_continuous_count_default,
  getNextNonSpaceNonCommentCharacter: () => get_next_non_space_non_comment_character_default,
  getNextNonSpaceNonCommentCharacterIndex: () => getNextNonSpaceNonCommentCharacterIndex2,
  getStringWidth: () => get_string_width_default,
  hasNewline: () => has_newline_default,
  hasNewlineInRange: () => has_newline_in_range_default,
  hasSpaces: () => has_spaces_default,
  isNextLineEmpty: () => isNextLineEmpty2,
  isNextLineEmptyAfterIndex: () => is_next_line_empty_default,
  isPreviousLineEmpty: () => isPreviousLineEmpty2,
  makeString: () => make_string_default,
  skip: () => skip,
  skipEverythingButNewLine: () => skipEverythingButNewLine,
  skipInlineComment: () => skip_inline_comment_default,
  skipNewline: () => skip_newline_default,
  skipSpaces: () => skipSpaces,
  skipToLineEnd: () => skipToLineEnd,
  skipTrailingComment: () => skip_trailing_comment_default,
  skipWhitespace: () => skipWhitespace
});
function skipInlineComment(text, startIndex) {
  if (startIndex === !1)
    return !1;
  if (text.charAt(startIndex) === "/" && text.charAt(startIndex + 1) === "*") {
    for (let i2 = startIndex + 2; i2 < text.length; ++i2)
      if (text.charAt(i2) === "*" && text.charAt(i2 + 1) === "/")
        return i2 + 2;
  }
  return startIndex;
}
var skip_inline_comment_default = skipInlineComment;
function skipTrailingComment(text, startIndex) {
  return startIndex === !1 ? !1 : text.charAt(startIndex) === "/" && text.charAt(startIndex + 1) === "/" ? skipEverythingButNewLine(text, startIndex) : startIndex;
}
var skip_trailing_comment_default = skipTrailingComment;
function getNextNonSpaceNonCommentCharacterIndex(text, startIndex) {
  let oldIdx = null, nextIdx = startIndex;
  for (; nextIdx !== oldIdx; )
    oldIdx = nextIdx, nextIdx = skipSpaces(text, nextIdx), nextIdx = skip_inline_comment_default(text, nextIdx), nextIdx = skip_trailing_comment_default(text, nextIdx), nextIdx = skip_newline_default(text, nextIdx);
  return nextIdx;
}
var get_next_non_space_non_comment_character_index_default = getNextNonSpaceNonCommentCharacterIndex;
function isNextLineEmpty(text, startIndex) {
  let oldIdx = null, idx = startIndex;
  for (; idx !== oldIdx; )
    oldIdx = idx, idx = skipToLineEnd(text, idx), idx = skip_inline_comment_default(text, idx), idx = skipSpaces(text, idx);
  return idx = skip_trailing_comment_default(text, idx), idx = skip_newline_default(text, idx), idx !== !1 && has_newline_default(text, idx);
}
var is_next_line_empty_default = isNextLineEmpty;
function getIndentSize(value, tabWidth) {
  const lastNewlineIndex = value.lastIndexOf(`
`);
  return lastNewlineIndex === -1 ? 0 : get_alignment_size_default(
    // All the leading whitespaces
    value.slice(lastNewlineIndex + 1).match(/^[\t ]*/)[0],
    tabWidth
  );
}
var get_indent_size_default = getIndentSize;
function escapeStringRegexp(string) {
  if (typeof string != "string")
    throw new TypeError("Expected a string");
  return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function getMaxContinuousCount(text, searchString) {
  const results = text.match(
    new RegExp(`(${escapeStringRegexp(searchString)})+`, "g")
  );
  return results === null ? 0 : results.reduce(
    (maxCount, result) => Math.max(maxCount, result.length / searchString.length),
    0
  );
}
var get_max_continuous_count_default = getMaxContinuousCount;
function getNextNonSpaceNonCommentCharacter(text, startIndex) {
  const index = get_next_non_space_non_comment_character_index_default(text, startIndex);
  return index === !1 ? "" : text.charAt(index);
}
var get_next_non_space_non_comment_character_default = getNextNonSpaceNonCommentCharacter;
function hasNewlineInRange(text, startIndex, endIndex) {
  for (let i2 = startIndex; i2 < endIndex; ++i2)
    if (text.charAt(i2) === `
`)
      return !0;
  return !1;
}
var has_newline_in_range_default = hasNewlineInRange;
function hasSpaces(text, startIndex, options8 = {}) {
  return skipSpaces(
    text,
    options8.backwards ? startIndex - 1 : startIndex,
    options8
  ) !== startIndex;
}
var has_spaces_default = hasSpaces;
function makeString(rawText, enclosingQuote, unescapeUnnecessaryEscapes) {
  const otherQuote = enclosingQuote === '"' ? "'" : '"', raw = string_replace_all_default(
    /* isOptionalObject*/
    !1,
    rawText,
    /\\(.)|(["'])/gs,
    (match, escaped, quote) => escaped === otherQuote ? escaped : quote === enclosingQuote ? "\\" + quote : quote || (unescapeUnnecessaryEscapes && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(escaped) ? escaped : "\\" + escaped)
  );
  return enclosingQuote + raw + enclosingQuote;
}
var make_string_default = makeString;
function legacyGetNextNonSpaceNonCommentCharacterIndex(text, node, locEnd) {
  return get_next_non_space_non_comment_character_index_default(
    text,
    locEnd(node)
  );
}
function getNextNonSpaceNonCommentCharacterIndex2(text, startIndex) {
  return arguments.length === 2 || typeof startIndex == "number" ? get_next_non_space_non_comment_character_index_default(text, startIndex) : (
    // @ts-expect-error -- expected
    // eslint-disable-next-line prefer-rest-params
    legacyGetNextNonSpaceNonCommentCharacterIndex(...arguments)
  );
}
function legacyIsPreviousLineEmpty(text, node, locStart) {
  return is_previous_line_empty_default(text, locStart(node));
}
function isPreviousLineEmpty2(text, startIndex) {
  return arguments.length === 2 || typeof startIndex == "number" ? is_previous_line_empty_default(text, startIndex) : (
    // @ts-expect-error -- expected
    // eslint-disable-next-line prefer-rest-params
    legacyIsPreviousLineEmpty(...arguments)
  );
}
function legacyIsNextLineEmpty(text, node, locEnd) {
  return is_next_line_empty_default(text, locEnd(node));
}
function isNextLineEmpty2(text, startIndex) {
  return arguments.length === 2 || typeof startIndex == "number" ? is_next_line_empty_default(text, startIndex) : (
    // @ts-expect-error -- expected
    // eslint-disable-next-line prefer-rest-params
    legacyIsNextLineEmpty(...arguments)
  );
}
function withPlugins(fn, optionsArgumentIndex = 1) {
  return async (...args) => {
    const options8 = args[optionsArgumentIndex] ?? {}, { plugins = [] } = options8;
    return args[optionsArgumentIndex] = {
      ...options8,
      plugins: (await Promise.all([
        load_builtin_plugins_default(),
        // TODO: standalone version allow `plugins` to be `prettierPlugins` which is an object, should allow that too
        load_plugins_default(plugins)
      ])).flat()
    }, fn(...args);
  };
}
var formatWithCursor2 = withPlugins(formatWithCursor);
async function format2(text, options8) {
  const { formatted } = await formatWithCursor2(text, {
    ...options8,
    cursorOffset: -1
  });
  return formatted;
}
async function check(text, options8) {
  return await format2(text, options8) === text;
}
async function clearCache3() {
  clearCache(), clearCache2();
}
var getFileInfo2 = withPlugins(get_file_info_default), getSupportInfo2 = withPlugins(getSupportInfo, 0), sharedWithCli = {
  errors: errors_exports,
  optionCategories: option_categories_exports,
  createIsIgnoredFunction,
  formatOptionsHiddenDefaults,
  normalizeOptions: normalize_options_default,
  getSupportInfoWithoutPlugins: getSupportInfo,
  normalizeOptionSettings,
  vnopts: {
    ChoiceSchema,
    apiDescriptor
  },
  fastGlob: import_fast_glob.default,
  utils: {
    isNonEmptyArray: is_non_empty_array_default,
    partition: partition_default,
    omit: object_omit_default
  },
  mockable: mockable_default
}, debugApis = {
  parse: withPlugins(parse5),
  formatAST: withPlugins(formatAst),
  formatDoc: withPlugins(formatDoc),
  printToDoc: withPlugins(printToDoc),
  printDocToString: withPlugins(printDocToString2),
  mockable: mockable_default
};
async function getAndWriteJourneySchema(data) {
  const { schemasPath, useTypeScript, schemaUrl } = data;
  try {
    const documentTypes = await fetchJourneySchema(schemaUrl), fileExtension = useTypeScript ? "ts" : "js";
    for (const documentType of documentTypes) {
      const filePath = path__namespace.default.join(schemasPath, `${documentType.name}.${fileExtension}`);
      await fs__default.default.writeFile(filePath, await assembleJourneySchemaTypeFileContent(documentType));
    }
    const indexContent = await assembleJourneyIndexContent(documentTypes);
    await fs__default.default.writeFile(path__namespace.default.join(schemasPath, `index.${fileExtension}`), indexContent);
  } catch (error) {
    throw new Error(`Failed to fetch remote schema: ${error.message}`);
  }
}
async function getAndWriteJourneySchemaWorker(workerData) {
  const workerPath = await cliWorker.getCliWorkerPath("getAndWriteJourneySchema");
  return new Promise((resolve, reject) => {
    const worker = new worker_threads.Worker(workerPath, {
      workerData,
      env: {
        // eslint-disable-next-line no-process-env
        ...process.env,
        // Dynamic HTTPS imports are currently behind a Node flag
        NODE_OPTIONS: "--experimental-network-imports",
        NODE_NO_WARNINGS: "1"
      }
    });
    worker.on("message", (message) => {
      message.type === "success" ? resolve() : (message.error.message = `Import schema worker failed: ${message.error.message}`, reject(message.error));
    }), worker.on("error", (error) => {
      error.message = `Import schema worker failed: ${error.message}`, reject(error);
    }), worker.on("exit", (code) => {
      code !== 0 && reject(new Error(`Worker stopped with exit code ${code}`));
    });
  });
}
async function fetchJourneyConfig(apiClient, projectId) {
  if (!projectId)
    throw new Error("ProjectId is required");
  if (!/^[a-zA-Z0-9-]+$/.test(projectId))
    throw new Error("Invalid projectId");
  try {
    const response = await apiClient({
      requireUser: !0,
      requireProject: !0,
      api: { projectId }
    }).config({ apiVersion: "v2024-02-23" }).request({
      method: "GET",
      uri: `/journey/projects/${projectId}`
    });
    return {
      projectId: response.projectId,
      datasetName: response.dataset,
      displayName: response.displayName || "Sanity Project",
      // The endpoint returns a signed URL that can be used to fetch the schema as ESM
      schemaUrl: response.schemaUrl,
      isFirstProject: !0
    };
  } catch {
    throw new Error(`Failed to fetch remote schema config: ${projectId}`);
  }
}
async function fetchJourneySchema(schemaUrl) {
  try {
    return (await import(schemaUrl)).default;
  } catch {
    throw new Error(`Failed to fetch remote schema: ${schemaUrl}`);
  }
}
async function assembleJourneySchemaTypeFileContent(schemaType) {
  const serialised = wrapSchemaTypeInHelpers(schemaType), imports = getImports(serialised), prettifiedSchemaType = await format2(serialised, { parser: "typescript" });
  return `${imports}

export const ${schemaType.name} = ${prettifiedSchemaType}
`;
}
function assembleJourneyIndexContent(schemas) {
  const sortedSchema = schemas.slice().sort((a, b) => a.name > b.name ? 1 : -1), imports = sortedSchema.map((schema2) => `import { ${schema2.name} } from './${schema2.name}'`), exports2 = sortedSchema.map((schema2) => schema2.name).join(","), fileContents = `${imports.join(`
`)}

export const schemaTypes = [${exports2}]`;
  return format2(fileContents, { parser: "typescript" });
}
function getImports(schemaType) {
  const defaultImports = ["defineType", "defineField"];
  return schemaType.includes("defineArrayMember") && defaultImports.push("defineArrayMember"), `import { ${defaultImports.join(", ")} } from 'sanity'`;
}
function wrapSchemaTypeInHelpers(schemaType, root2 = !0) {
  if (root2)
    return generateSchemaDefinition(schemaType, "defineType");
  if (schemaType.type === "array")
    return `${generateSchemaDefinition(schemaType, "defineField")},`;
  return `${generateSchemaDefinition(schemaType, "defineField")},`;
  function generateSchemaDefinition(object, definitionType) {
    const { fields, preview, of, ...otherProperties } = object, serializedProps = serialize(otherProperties), fieldsDef = fields && `fields: [${fields.map((f) => wrapSchemaTypeInHelpers(f, !1)).join("")}],`, ofDef = of && `of: [${of.map((f) => `defineArrayMember({${serialize(f)}})`).join(",")}],`, previewDef = preview && `preview: {${serialize(preview)}}`, combinedDefinitions = [serializedProps, fieldsDef, ofDef, previewDef].filter(Boolean).join(",");
    return `${definitionType}({ ${combinedDefinitions} })`;
  }
  function serialize(obj) {
    return Object.entries(obj).map(([key2, value]) => key2 === "prepare" ? `${value.toString()}` : typeof value == "string" ? `${key2}: "${value}"` : typeof value == "object" ? `${key2}: ${JSON.stringify(value)}` : `${key2}: ${value}`).join(",");
  }
}
exports.fetchJourneyConfig = fetchJourneyConfig;
exports.getAndWriteJourneySchema = getAndWriteJourneySchema;
exports.getAndWriteJourneySchemaWorker = getAndWriteJourneySchemaWorker;
//# sourceMappingURL=journeyConfig.js.map
